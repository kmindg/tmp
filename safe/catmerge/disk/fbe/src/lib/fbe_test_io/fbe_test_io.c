/***************************************************************************
 * Copyright (C) EMC Corporation 2008
 * All rights reserved.
 * Licensed material -- property of EMC Corporation
 ***************************************************************************/

/*!**************************************************************************
 * @file fbe_test_io.c
 ***************************************************************************
 *
 * @brief
 *  This file contains general I/O testing functions for the FBE io test
 *  library.
 *
 * HISTORY
 *   8/8/2008:  Created. RPF
 *
 ***************************************************************************/

/*************************
 *   INCLUDE FILES
 *************************/
#include "fbe/fbe_winddk.h"
#include "fbe/fbe_transport.h"
#include "fbe_topology.h"
#include "fbe_transport_memory.h"
//#include "mut.h"
#include "fbe_test_io_object.h"
#include "fbe_test_io_api.h"
#include "fbe_test_io_private.h"
#include "fbe/fbe_api_sep_io_interface.h"

/*************************
 *   FUNCTION DEFINITIONS
 *************************/

/* This structure defines a set of parameters for configuring the way that sg
 * lists get generated by the I/O library. 
 *  
 * This allows the user to change how sgs are generated in order to exercise 
 * different code paths or different permutations of test cases. 
 */
typedef struct fbe_test_io_sg_parameters_s
{
    /* Max allowed bytes per sg on a write/read.
     */
    fbe_u32_t write_max_bytes_per_sg;
    fbe_u32_t read_max_bytes_per_sg;

    /* The below boolean determines if we use 
     * the offset style of sg or not on reads and writes. 
     */
    fbe_bool_t b_write_use_offset;
    fbe_bool_t b_read_use_offset;
}
fbe_test_io_sg_parameters_t;

/* Global instance of this structure.
 * Defaults are to use 16kb max per sg entry and to always use the sg offsets. 
 */
fbe_test_io_sg_parameters_t fbe_test_io_sg_parameters = { (520*32), (520*32), 1, 1 };

/* Simple accessors for the fbe_test_io_sg_parameters structure.
 */
fbe_u32_t fbe_test_io_get_write_max_bytes_per_sg(void)
{
    return fbe_test_io_sg_parameters.write_max_bytes_per_sg;
}
void fbe_test_io_set_write_max_bytes_per_sg(fbe_u32_t bytes)
{
    fbe_test_io_sg_parameters.write_max_bytes_per_sg = bytes;
    return;
}
fbe_bool_t fbe_test_io_get_write_use_sg_offset(void)
{
    return fbe_test_io_sg_parameters.b_write_use_offset;
}
void fbe_test_io_set_write_use_sg_offset(fbe_bool_t b_use_offset)
{
    fbe_test_io_sg_parameters.b_write_use_offset = b_use_offset;
    return;
}
fbe_u32_t fbe_test_io_get_read_max_bytes_per_sg(void)
{
    return fbe_test_io_sg_parameters.read_max_bytes_per_sg;
}
void fbe_test_io_set_read_max_bytes_per_sg(fbe_u32_t bytes)
{
    fbe_test_io_sg_parameters.read_max_bytes_per_sg = bytes;
    return;
}
fbe_bool_t fbe_test_io_get_read_use_sg_offset(void)
{
    return fbe_test_io_sg_parameters.b_read_use_offset;
}
void fbe_test_io_set_read_use_sg_offset(fbe_bool_t b_use_offset)
{
    fbe_test_io_sg_parameters.b_read_use_offset = b_use_offset;
    return;
}
/* end accessor functions for fbe_test_io_sg_parameters */

/*! @todo we should Default to physical package.
 */
static fbe_bool_t fbe_test_io_b_use_sep = FBE_FALSE;

/* accessors for choosing between physical and logical packages. */
fbe_bool_t fbe_test_io_get_use_sep(void)
{
    return fbe_test_io_b_use_sep;
}
void fbe_test_io_set_use_sep(fbe_bool_t b_use_sep)
{
    fbe_test_io_b_use_sep = b_use_sep;
    return;
}
/*!***************************************************************
 * fbe_test_io_send_block_payload()
 ****************************************************************
 * @brief
 *  This function sends a block command for the given params.
 *  The purpose of this fn is to choose between a sep and
 *  a physical package payload.
 *
 * @param object_id - Object being sent to.
 * @param opcode - Operation to use for this command.
 * @param lba - Start logical block address of command.
 * @param blocks - Total blocks for transfer.
 * @param block_size - Block size to use in command.
 * @param opt_block_size - Optimal block size to use in command.
 * @param sg_p - Scatter gather pointer.
 * @param pre_read_desc_p - The edge descriptor pointer for this cmd.
 * @param transport_qualifier_p - The qualifier from the transport.
 * @param block_status_p - The status of the block payload.
 *
 * @return
 *  fbe_status_t - FBE_STATUS_OK - if no error.
 *
 * @version
 *  08/29/08 - Created. RPF
 *
 ****************************************************************/
fbe_status_t 
fbe_test_io_send_block_payload(fbe_object_id_t object_id,
                               fbe_payload_block_operation_opcode_t opcode,
                               fbe_lba_t lba,
                               fbe_block_count_t blocks,
                               fbe_block_size_t block_size,
                               fbe_block_size_t opt_block_size,
                               fbe_sg_element_t * const sg_p,
                               fbe_payload_pre_read_descriptor_t * const pre_read_desc_p,
                               fbe_packet_attr_t * const transport_qualifier_p,
                               fbe_api_block_status_values_t * const block_status_p)
{
    fbe_status_t status;

    if (fbe_test_io_get_use_sep())
    {
        /* Use Storage Extent Package.
         */
        status = fbe_api_sep_io_interface_send_block_payload( object_id,
                                                              opcode,
                                                              lba,    /* lba */
                                                              blocks,    /* blocks */
                                                              block_size,    /* requested block size */
                                                              opt_block_size,
                                                              sg_p,    /* Sg element */
                                                              pre_read_desc_p,    /* edge descriptor */
                                                              transport_qualifier_p,
                                                              (fbe_api_sep_block_status_values_t *const)block_status_p );
    }
    else
    {
        /* Use Physical Package.
         */
        status = fbe_api_logical_drive_interface_send_block_payload( object_id,
                                                                     opcode,
                                                                     lba,    /* lba */
                                                                     blocks,    /* blocks */
                                                                     block_size,    /* requested block size */
                                                                     opt_block_size,
                                                                     sg_p,    /* Sg element */
                                                                     pre_read_desc_p,    /* edge descriptor */
                                                                     transport_qualifier_p,
                                                                     block_status_p );
    }
    return status;
}
/**************************************
 * end fbe_test_io_send_block_payload
 **************************************/

fbe_status_t fbe_test_io_get_block_size(const fbe_object_id_t object_id,
                                        fbe_block_transport_negotiate_t *const negotiate_p,
                                        fbe_payload_block_operation_status_t *const block_status_p,
                                        fbe_payload_block_operation_qualifier_t *const block_qualifier)
{
    fbe_status_t status;
    if (fbe_test_io_get_use_sep())
    {
        /* Use Storage Extent Package.
         */
        status = fbe_api_sep_io_interface_get_block_size( object_id, negotiate_p, 
                                                          block_status_p, block_qualifier );
    }
    else
    {
        /* Use Physical Package.
         */
        status = fbe_api_logical_drive_get_drive_block_size( object_id, negotiate_p, 
                                                          block_status_p, block_qualifier );
    }
    return status;
}
/*!***************************************************************
 * @fn fbe_test_io_write_read_check(
 *                         fbe_object_id_t object_id,
 *                         fbe_test_io_pattern_t pattern,
 *                         fbe_u32_t pass_count,
 *                         fbe_lba_t lba,
 *                         fbe_block_count_t blocks,
 *                         fbe_block_size_t exported_block_size,
 *                         fbe_block_size_t exported_opt_block_size,
 *                         fbe_block_size_t imported_block_size,
 *                         fbe_u32_t *const qualifier_p )
 ****************************************************************
 * @brief
 *  This function performs a single write, followed by a single
 *  read and pattern check.
 *
 * @param object_id - Object ID to issue read/check to.
 * @param pass_count - Pass count to use when seeding.
 * @param lba - Start logical block address to check.
 * @param blocks - Total blocks.
 * @param exported_block_size - Exported block size to use.
 * @param exported_opt_block_size - Exported optimal block size to use.
 * @param imported_block_size - Imported block size to use.
 * @param write_status_p - The write status.
 * @param write_qualifier_p - The write qualifier.
 * @param read_status_p - The read status.
 * @param read_qualifier_p - The read qualifier.
 *
 * @return
 *  The status of the operation.
 *  Anything other than FBE_STATUS_OK indicates failure.
 *
 * HISTORY:
 *  11/26/08 - Created. RPF
 *
 ****************************************************************/
fbe_status_t fbe_test_io_write_read_check( fbe_object_id_t object_id,
                                           fbe_lba_t lba,
                                           fbe_block_count_t blocks,
                                           fbe_block_size_t exported_block_size,
                                           fbe_block_size_t exported_opt_block_size,
                                           fbe_block_size_t imported_block_size,
                                           fbe_payload_block_operation_status_t *const write_status_p,
                                           fbe_payload_block_operation_qualifier_t * const write_qualifier_p,
                                           fbe_payload_block_operation_status_t *const read_status_p,
                                           fbe_payload_block_operation_qualifier_t * const read_qualifier_p )
{

    fbe_status_t status = FBE_STATUS_OK;
    fbe_u32_t qualifier;
    fbe_api_block_status_values_t block_status_values;

    /* Issue the seeded write for this range.
     */
    status = fbe_test_io_write_pattern( object_id,
                                        FBE_IO_TEST_TASK_PATTERN_ADDRESS_PASS_COUNT,
                                        0x55,
                                        FBE_PAYLOAD_BLOCK_OPERATION_OPCODE_WRITE,
                                        lba,
                                        blocks,
                                        exported_block_size,
                                        exported_opt_block_size,
                                        imported_block_size,
                                        &block_status_values,
                                        &qualifier );
    //MUT_ASSERT_INT_EQUAL(status, FBE_STATUS_OK);
    *write_status_p = block_status_values.status;
    *write_qualifier_p = block_status_values.qualifier;

    /* If block status was good, then issue a read and check the pattern in the data that
     * was returned. 
     */
    if (*write_status_p == FBE_PAYLOAD_BLOCK_OPERATION_STATUS_SUCCESS)
    {
        fbe_payload_block_operation_status_t block_status;
        fbe_payload_block_operation_qualifier_t block_qualifier;
        status = fbe_test_io_read_check_pattern( object_id,
                                                 FBE_IO_TEST_TASK_PATTERN_ADDRESS_PASS_COUNT,
                                                 0x55,    /* Pass count. */
                                                 lba,
                                                 blocks,
                                                 exported_block_size,
                                                 exported_opt_block_size,
                                                 imported_block_size,
                                                 &block_status,
                                                 &block_qualifier,
                                                 &qualifier );
        //MUT_ASSERT_INT_EQUAL(status, FBE_STATUS_OK);
        *read_status_p = block_status;
        *read_qualifier_p = block_qualifier;
    }
    return status;
}
/* end fbe_test_io_write_read_check() */

/*!***************************************************************
 * @fn fbe_test_get_word_pattern(fbe_lba_t lba, 
 *                               fbe_u32_t word_index,
 *                               fbe_u32_t tag,
 *                               fbe_test_io_pattern_t pattern_type,
 *                               fbe_u32_t pass_count,
 *                               fbe_block_size_t block_size,
 *                               fbe_block_count_t block_count,
 *                               fbe_block_count_t block_offset)
 ****************************************************************
 * @brief
 *  This function returns the correct pattern for a word in a block.
 *
 * @param lba - Start logical block address.
 * @param word_index - Index of word in buffer.
 * @param tag - Tag to set into buffer, typically an object id.
 * @param pattern_type - Pattern to set into buffer.
 * @param pass_count - Pass count to use when seeding.
 * @param block_size - Exported block size.
 * @param block_count - Total blocks of operation.
 * @param block_offset - Block offset for a chain of blocks.
 *
 * @return The pattern for this word.
 *
 * HISTORY:
 *  11/12/07 - Created. RPF
 *
 ****************************************************************/
fbe_u64_t fbe_test_get_word_pattern(fbe_lba_t lba, 
                                    fbe_u32_t word_index,
                                    fbe_u32_t tag,
                                    fbe_test_io_pattern_t pattern_type,
                                    fbe_u32_t pass_count,
                                    fbe_block_size_t block_size, 
                                    fbe_block_count_t block_count,
                                    fbe_block_count_t block_offset)
{
    fbe_u64_t pattern = 0;

    if (pattern_type == FBE_IO_TEST_TASK_PATTERN_FFS)
    {
        /* For this pattern all bytes get FF.
         */
        pattern = 0xFFFFFFFFFFFFFF00 | pass_count;
    }
    else if (pattern_type == FBE_IO_TEST_TASK_PATTERN_ZEROS)
    {
        /* For this pattern all words get the zeros.
         */
        pattern = 0x0;
    }
    else  if (word_index == 5)
    {
        /* Next word gets the block size.
         */
        pattern = block_size;
    }

    else if (word_index == 6)
    {
        /* Next word gets the block count.
         */
        pattern = block_count;
    }
    else if (word_index == 7)
    {
        /* Next word gets the block offset.
         */
        pattern = block_offset;
    }

    else if (word_index == 8)
    {
        /* Next word gets the tag.
         */
        pattern = tag;
    }
    else if (pattern_type == FBE_IO_TEST_TASK_PATTERN_ADDRESS_PASS_COUNT)
    {
        /* Other words get the lba.
         */
        pattern = (((fbe_u64_t)lba) & 0x00FFFFFFFFFFFFFF) | ((((fbe_u64_t)pass_count) & 0xFF) << 56);
    }
    return pattern;
}
/* end fbe_test_get_word_pattern() */

/*!***************************************************************
 * @fn fbe_test_fill_seeded_pattern(
 *                     fbe_u32_t tag,
 *                     fbe_test_io_pattern_t pattern,
 *                     fbe_u32_t pass_count, fbe_lba_t lba,
 *                     fbe_block_count_t block_count,
 *                     fbe_block_size_t block_size,
 *                     fbe_u8_t *const data_p)
 ****************************************************************
 * @brief
 *  This function sets a pattern into a given buffer.
 *
 * @param tag - Tag to set into buffer, typically an object id.
 * @param pattern - Pattern to set into buffer.
 * @param pass_count - Pass count to use when seeding.
 * @param lba - Start logical block address.
 * @param block_count - Total blocks of operation.
 * @param block_size - Exported block size.
 * @param data_p - Pointer to the block to set pattern into.
 *
 * @return None.
 *
 * HISTORY:
 *  11/12/07 - Created. RPF
 *
 ****************************************************************/
void fbe_test_fill_seeded_pattern(fbe_u32_t tag,
                                  fbe_test_io_pattern_t pattern,
                                  fbe_u32_t pass_count,
                                  fbe_lba_t lba, 
                                  fbe_block_count_t block_count, 
                                  fbe_block_size_t block_size, 
                                  fbe_u8_t *const data_p)
{
    fbe_lba_t current_lba = lba;
    fbe_lba_t max_lba = lba + block_count;
    fbe_u8_t *current_data_p = data_p;
    fbe_u32_t words_in_block = block_size / sizeof(fbe_u64_t);

    /* Loop over all the LBAs in the transfer. 
     * For each LBA, seed it with the pattern specified by the input args. 
     */
    while (current_lba < max_lba)
    {
        fbe_u64_t *current_block_p = (fbe_u64_t *)current_data_p;
        fbe_u32_t current_word;
        fbe_block_count_t block_offset = (fbe_block_count_t)(current_lba - lba);

        /* Loop over all the words in this block and seed each one with a 
         * pattern. 
         */
        for (current_word = 0; current_word < words_in_block; current_word++)
        {
            /* Set the correct pattern into the current word.
             */
            current_block_p[current_word] = 
                fbe_test_get_word_pattern(current_lba,
                                          current_word,
                                          tag,
                                          pattern,
                                          pass_count,
                                          block_size,
                                          block_count,
                                          block_offset);
        }/* end for current_word = 0; current_word < words_in block. */
        
        current_data_p += block_size;
        current_lba++;
    }/* End while current_lba < lba */

    return;
}
/* fbe_test_fill_seeded_pattern() */

/*!***************************************************************
 * @fn fbe_test_check_buffer_for_pattern(
 *                     fbe_u32_t tag,
 *                     fbe_test_io_pattern_t pattern,
 *                     fbe_u32_t pass_count, fbe_lba_t lba,
 *                     fbe_block_count_t block_count,
 *                     fbe_block_count_t operation_block_count,
 *                     fbe_block_count_t block_offset,
 *                     fbe_block_size_t block_size,
 *                     fbe_u8_t *const data_p)
 ****************************************************************
 * @brief
 *  This function tests a buffer for a pattern.
 *
 * @param tag - Tag to set into buffer, typically an object id.
 * @param pattern - Pattern to set into buffer.
 * @param pass_count - Pass count to use when seeding.
 * @param lba - Start logical block address.
 * @param block_count - Total blocks of operation.
 * @param operation_block_count - Block count used in the original operation,
 * this is what was seeded into the block.
 * @param block_offset - Offset from the start of the overall transfer.
 * @param block_size - Exported block size in bytes.
 * @param data_p - Pointer to the block to set pattern into.
 *
 * @return
 *  The status of the pattern check.
 *  FBE_STATUS_GENERIC_FAILURE - Indicates failure.
 *
 * HISTORY:
 *  11/12/07 - Created. RPF
 *
 ****************************************************************/
fbe_status_t fbe_test_check_buffer_for_pattern(fbe_u32_t tag,
                                               fbe_test_io_pattern_t pattern,
                                               fbe_u32_t pass_count,
                                               fbe_lba_t lba, 
                                               fbe_block_count_t block_count,
                                               fbe_block_count_t operation_block_count,
                                               fbe_block_count_t block_offset,
                                               fbe_block_size_t block_size,
                                               fbe_u8_t *const data_p)
{
    fbe_lba_t current_lba = lba;
    fbe_lba_t max_lba = lba + block_count;
    fbe_u8_t *current_data_p = data_p;
    fbe_status_t status = FBE_STATUS_OK;
    fbe_u32_t words_in_block = block_size / sizeof(fbe_u64_t);
    
    /* Loop over all the blocks in the range.
     */
    while (current_lba < max_lba &&
           status == FBE_STATUS_OK)
    {
        fbe_u64_t *current_block_p = (fbe_u64_t *)current_data_p;
        fbe_u32_t current_word;
        
        /* Loop over all the words in the block.
         */
        for (current_word = 0; current_word < words_in_block; current_word++)
        {
            /* Check this word for the correct pattern.
             */
            if (current_block_p[current_word] != 
                fbe_test_get_word_pattern(current_lba,
                                          current_word,
                                          tag,
                                          pattern,
                                          pass_count,
                                          block_size,
                                          operation_block_count,
                                          block_offset))
            {
                /* Incorrect pattern found, break out with error.
                 */
                status = FBE_STATUS_GENERIC_FAILURE;
                break;
            }
        } /* end for current_word = 0; current_word < words_in block. */
        
        current_data_p += block_size;
        current_lba++;
        block_offset++;
    } /* End while current_lba < lba and status == FBE_STATUS_OK */

    return status;
}
/* fbe_test_check_buffer_for_pattern() */

/*!***************************************************************
 * @fn fbe_test_io_issue_write(fbe_object_id_t object_id,
 *                       fbe_payload_block_operation_opcode_t opcode,
 *                       fbe_lba_t lba,
 *                       fbe_block_count_t blocks,
 *                       fbe_block_size_t exported_block_size,
 *                       fbe_block_size_t exported_opt_block_size,
 *                       fbe_block_size_t imported_block_size, 
 *                       fbe_sg_element_t *const sg_p,
 *                       fbe_api_block_status_values_t * const block_status_p,
 *                       fbe_u32_t * const qualifier_p)
 ****************************************************************
 * @brief
 *  This function performs a write according to the logical
 *  drive operation semantics.
 *
 *  In cases where a pre-read is required, it will be performed,
 *  and the received edge blocks will be supplied on the write.
 *
 * @param object_id - Object ID to write.
 * @param opcode - Operation to use for this write.
 * @param lba - Start logical block address of write.
 * @param blocks - Total blocks to write.
 * @param exported_block_size - Exported block size to use in write.
 * @param exported_opt_block_size - Exported optimal block size 
 *                                 to use in write.
 * @param imported_block_size - The imported block size in bytes.
 * @param sg_p - Scatter gather pointer.
 * @param block_status_p - The block operation status.
 * @param block_qualifier_p - The packet qualifier status.
 *
 * @return
 *  The status of the write.
 *  Anything other than FBE_STATUS_OK indicates failure.
 *
 * HISTORY:
 *  11/12/07 - Created. RPF
 *
 ****************************************************************/
fbe_status_t 
fbe_test_io_issue_write( fbe_object_id_t object_id,
                         fbe_payload_block_operation_opcode_t opcode,
                         fbe_lba_t lba,
                         fbe_block_count_t blocks,
                         fbe_block_size_t exported_block_size,
                         fbe_block_size_t exported_opt_block_size,
                         fbe_block_size_t imported_block_size,
                         fbe_sg_element_t * const sg_p,
                         fbe_api_block_status_values_t * const block_status_p,
                         fbe_u32_t *const qualifier_p )
{
    fbe_status_t status = FBE_STATUS_OK;
    fbe_sg_element_t * pre_read_sg_p = NULL;
    fbe_payload_pre_read_descriptor_t pre_read_desc;
    fbe_payload_pre_read_descriptor_t *pre_read_desc_p;
    fbe_lba_t edge_lba = 0;
    fbe_block_count_t edge_blocks = 0;

    /* Determine if we need to read extra edges.
     */
    edge_lba = lba;
    edge_blocks = blocks;
    fbe_logical_drive_get_pre_read_lba_blocks_for_write( exported_block_size,
                                                         exported_opt_block_size,
                                                         imported_block_size,
                                                         &edge_lba,
                                                         &edge_blocks );
    if (edge_lba != lba || edge_blocks != blocks)
    {
        /* Get the memory for our sg.
         */
        pre_read_sg_p = 
            fbe_test_io_alloc_memory_with_sg_offset(/* Bytes to alloc. */
                                                    exported_block_size * edge_blocks,
                                                    0, 0, /* offset and extra length */
                                                    fbe_test_io_get_read_max_bytes_per_sg());

        /* If we could not allocate memory we cannot continue.
         */
        //MUT_ASSERT_NOT_NULL(pre_read_sg_p);

        /* Clear out the edge buffer before we send it.
         */
        fbe_zero_memory(fbe_sg_element_address(pre_read_sg_p), 
                      (fbe_u32_t)(exported_block_size * edge_blocks));

        /* Send the read to fetch the edges.
         */
        status = fbe_test_io_send_block_payload( object_id,
                                                 FBE_PAYLOAD_BLOCK_OPERATION_OPCODE_READ,
                                                 edge_lba, /* lba */
                                                 edge_blocks, /* blocks */
                                                 exported_block_size, /* requested block size */
                                                 exported_opt_block_size,
                                                 pre_read_sg_p, /* Sg element */
                                                 NULL, /* edge descriptor */
                                                 qualifier_p,
                                                 block_status_p );
        
        /* If the pre-read failed, just return bad status.
         */
        if ((status != FBE_STATUS_OK) || 
            (block_status_p->status != FBE_PAYLOAD_BLOCK_OPERATION_STATUS_SUCCESS))
        {
            /* If necessary, free the memory we allocated.
             */
            fbe_test_io_free_memory_with_sg(&pre_read_sg_p);
            return status;
        }
        /* Setup our edge descriptor.
         */
        pre_read_desc_p = &pre_read_desc;
        fbe_payload_pre_read_descriptor_set_lba(pre_read_desc_p, edge_lba);
        fbe_payload_pre_read_descriptor_set_block_count(pre_read_desc_p, edge_blocks);
        fbe_payload_pre_read_descriptor_set_sg_list(pre_read_desc_p, pre_read_sg_p);
    }
    else
    {
        /* This is an aligned write, no need for an edge descriptor.
         */
        pre_read_desc_p = NULL;
    }

    /* Issue the write command for this range.
     */
    status = fbe_test_io_send_block_payload( object_id,
                                             opcode,
                                             lba,
                                             blocks,
                                             exported_block_size, /* requested block size */
                                             exported_opt_block_size,
                                             sg_p, /* Sg descriptor */
                                             pre_read_desc_p,
                                             qualifier_p,
                                             block_status_p );

    /* If necessary, free the memory we allocated.
     */
    fbe_test_io_free_memory_with_sg(&pre_read_sg_p);
    
    return status;
}
/* end fbe_test_io_issue_write() */

/*!***************************************************************
 * @fn fbe_test_io_issue_write_same(
 *                       fbe_object_id_t object_id,
 *                       fbe_lba_t lba,
 *                       fbe_block_count_t blocks,
 *                       fbe_block_size_t exported_block_size,
 *                       fbe_block_size_t exported_opt_block_size,
 *                       fbe_sg_element_t * const sg_p,
 *                       fbe_u32_t * const qualifier_p )
 ****************************************************************
 * @brief
 *  This function performs a write same operation.
 *
 * @param object_id - Object ID to write same.
 * @param lba - Start logical block address of write same.
 * @param blocks - Total blocks to write same.
 * @param exported_block_size - Exported block size to use in write same.
 * @param exported_opt_block_size - Exported optimal block size 
 *                                 to use in write same.
 * @param sg_p - Scatter gather pointer.
 * @param qualifier_p - The qualifier status.
 *
 * @return
 *  The status of the write same.
 *  Anything other than FBE_STATUS_OK indicates failure.
 *
 * HISTORY:
 *  02/12/08 - Created. RPF
 *
 ****************************************************************/
fbe_u32_t 
fbe_test_io_issue_write_same( fbe_object_id_t object_id,
                              fbe_lba_t lba,
                              fbe_block_count_t blocks,
                              fbe_block_size_t exported_block_size,
                              fbe_block_size_t exported_opt_block_size,
                              fbe_sg_element_t * const sg_p,
                              fbe_u32_t * const qualifier_p )
{
    fbe_status_t status = FBE_STATUS_OK;
    fbe_u32_t qualifier;
    fbe_api_block_status_values_t block_status;

    /* Issue the write same command for this range.
     */
    status = fbe_test_io_send_block_payload( object_id,
                                             FBE_PAYLOAD_BLOCK_OPERATION_OPCODE_WRITE_SAME,
                                             lba,
                                             blocks,
                                             exported_block_size, /* requested block size */
                                             exported_opt_block_size,
                                             sg_p,    /* Sg element */
                                             NULL,    /* edge descriptor */
                                             &qualifier,
                                             &block_status  );
    //MUT_ASSERT_INT_EQUAL_MSG(status, 
//                           FBE_STATUS_OK,
//                           "fbe_test_io_issue_write_same() fbe_test_send_io_block_command() transport failed for write same.");
    //_ASSERT_INT_EQUAL_MSG(block_status.status, 
//                           FBE_PAYLOAD_BLOCK_OPERATION_STATUS_SUCCESS,
//                           "fbe_test_io_issue_write_same() fbe_test_send_io_block_command() block write same failed.");

    return status;
}
/* end fbe_test_io_issue_write_same() */

/*!***************************************************************
 * @fn fbe_test_io_write_same_pattern(
 *                              fbe_object_id_t object_id,
 *                              fbe_test_io_pattern_t pattern,
 *                              fbe_u32_t pass_count,
 *                              fbe_payload_block_operation_opcode_t opcode,
 *                              fbe_lba_t lba,
 *                              fbe_block_count_t blocks,
 *                              fbe_u32_t exported_block_size,
 *                              fbe_block_size_t imported_block_size,
 *                              fbe_block_size_t exported_opt_block_size,
 *                              fbe_u32_t * const qualifier_p)
 ****************************************************************
 * @brief
 *  This function performs a write with pattern.
 *
 * @param object_id - Object ID to write same.
 * @param pattern - Pattern to write same. 
 * @param pass_count - Pass count to use when seeding.
 * @param opcode - Operation to use for this write same.
 * @param lba - Start logical block address of write same.
 * @param blocks - Total blocks to write same.
 * @param exported_block_size - Exported block size to use in write same.
 * @param imported_block_size - Imported block size to use in write same.
 * @param exported_opt_block_size - Exported optimal block size
 *                                 to use in write same.
 * @param qualifier_p - The qualifier status.
 *
 * @return
 *  The status of the write same.
 *  Anything other than FBE_STATUS_OK indicates failure.
 *
 * HISTORY:
 *  11/26/07 - Created. RPF
 *
 ****************************************************************/
fbe_status_t 
fbe_test_io_write_same_pattern(fbe_object_id_t object_id,
                               fbe_test_io_pattern_t pattern,
                               fbe_u32_t pass_count,
                               fbe_payload_block_operation_opcode_t opcode,
                               fbe_lba_t lba,
                               fbe_block_count_t blocks,
                               fbe_u32_t exported_block_size,
                               fbe_block_size_t imported_block_size,
                               fbe_block_size_t exported_opt_block_size,
                               fbe_u32_t * const qualifier_p )
{
    fbe_sg_element_t *sg_p;
    fbe_status_t status;

    /* Allocate memory including the sg list since we need memory for this
     * transfer. 
     * Note that since this is a write same, we only allocate a single block, 
     * since the interface assumes only a single exported block is being sent. 
     */
    sg_p = fbe_test_io_alloc_memory_with_sg(exported_block_size);

    if (sg_p == NULL)
    {
        status = FBE_STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }

    /* Put a pattern into this buffer.
     * Note that we only fill the pattern for the single block we are sending. 
     */
    fbe_test_fill_seeded_pattern(object_id, pattern, pass_count, lba, 1, exported_block_size, 
                                 fbe_sg_element_address(sg_p));

    /* Issue the write same.
     */
    status = fbe_test_io_issue_write_same(object_id,
                                          lba,
                                          blocks,
                                          exported_block_size,
                                          exported_opt_block_size,
                                          sg_p,
                                          qualifier_p);
    /* Since we are done with the memory, free it.
     */
    fbe_test_io_free_memory_with_sg(&sg_p);

    return status;
}
/* end fbe_test_io_write_same_pattern() */

/*!***************************************************************
 * @fn fbe_test_io_alloc_memory_with_sg(fbe_u32_t bytes)
 ****************************************************************
 * @brief
 *  This function allocates an sg list with (bytes) worth of
 *  associated memory.
 * 
 * @param bytes - Bytes to allocate.
 *
 * @return
 *  Returns the newly allocated sg list with memory.
 *  NULL Indicates failure.
 *
 * HISTORY:
 *  11/26/07 - Created. RPF
 *
 ****************************************************************/
fbe_sg_element_t * fbe_test_io_alloc_memory_with_sg( fbe_u32_t bytes )
{
    fbe_sg_element_t *sg_p;
    fbe_u8_t *sectors_p;
    fbe_u8_t *memory_p;

    /* Allocate the memory.
     * We also reserve 2 sg entries for the sg list we are using. 
     * (one for the sg entry with data and one for the null terminator).
     */
    memory_p = malloc(bytes + (sizeof(fbe_sg_element_t) * 2));
    
    if (memory_p == NULL)
    {
        return NULL;
    }
    /* Place sg at beginning of memory.
     */
    sg_p = (fbe_sg_element_t *)memory_p;

    /* Place data memory after the sg memory (2 sg entries).
     */
    sectors_p = memory_p + (sizeof(fbe_sg_element_t) * 2);

    /* Init the sgs with the memory we just allocated.
     */
    fbe_sg_element_init(&sg_p[0], bytes, sectors_p);
    fbe_sg_element_terminate(&sg_p[1]);
    
    return sg_p;
}
/* end fbe_test_io_alloc_memory_with_sg() */

/*!***************************************************************
 * @fn fbe_test_io_free_memory_with_sg(fbe_sg_element_t **sg_p)
 ****************************************************************
 * @brief
 *  This function frees an sg list and associated memory.
 *
 * @param sg_p - SG list with memory to free.
 *
 * @return None.
 *
 * HISTORY:
 *  11/26/07 - Created. RPF
 *
 ****************************************************************/
void fbe_test_io_free_memory_with_sg( fbe_sg_element_t **sg_p )
{
    /* If the sg ptr is not null, then free it.
     * When we allocated, we did so in one big chunk for sg and data, 
     * so we can simply free this one chunk. 
     */
    if (*sg_p != NULL)
    {
        free(*sg_p);
        
        /* Set this to NULL to indicate it is already freed.
         */
        *sg_p = NULL;
    }
    return;
}
/* end fbe_test_io_free_memory_with_sg() */

/*!**************************************************************
 * @fn fbe_test_io_alloc_memory_with_sg_offset(fbe_u32_t bytes,
 *                                             fbe_u32_t sg_offset,
 *                                             fbe_u32_t sg_extra_length,
 *                                             fbe_u32_t max_bytes_per_sg_entry)
 ****************************************************************
 * @brief
 *  Allocate an sg list with an offset.
 *
 * @param bytes - total bytes of memory to allocate.
 * @param sg_offset - total offset to apply to sg.
 * @param sg_extra_length - Added length at end of sg to alloc.
 * @param max_bytes_per_sg_entry - Most bytes we will allow
 *                                 for any sg entry.
 *
 * @return fbe_sg_element_t * - the allocated sg list or NULL
 *                            if it could not be allocated.
 *
 * HISTORY:
 *  8/1/2008 - Created. RPF
 *
 ****************************************************************/

fbe_sg_element_t * fbe_test_io_alloc_memory_with_sg_offset( fbe_u64_t bytes,
                                                            fbe_u64_t sg_offset,
                                                            fbe_u64_t sg_extra_length,
                                                            fbe_u64_t max_bytes_per_sg_entry)
{
    fbe_sg_element_t *sg_p;
    fbe_u8_t *sectors_p;
    fbe_u64_t sg_length = 0;
    fbe_u64_t sg_index;
    fbe_u8_t *memory_p;

    /* Determine how large an sg we need. 
     * First account for the offset, extra length and terminator. 
     */
    sg_length += sg_offset;
    sg_length += sg_extra_length;
    sg_length++;

    /* Next decide how many sgs we need for the memory.
     */
    sg_length += bytes / max_bytes_per_sg_entry;
    sg_length += bytes % max_bytes_per_sg_entry ? 1 : 0;

    /* Allocate the memory.  We also allocate the sg memory at the same time.
     */
    memory_p = malloc((fbe_u32_t)(bytes + (sizeof(fbe_sg_element_t) * sg_length)));
    
    if (memory_p == NULL)
    {
        return NULL;
    }

    /* Clear out the memory (and sg) before we use it.
     */
    fbe_zero_memory(memory_p, 
                  (fbe_u32_t)(bytes + (sizeof(fbe_sg_element_t) * sg_length)));

    /* Place sg at beginning of memory.
     */
    sg_p = (fbe_sg_element_t *)memory_p;

    /* Place data memory after the sg memory.
     */
    sectors_p = memory_p + (sizeof(fbe_sg_element_t) * sg_length);

    /* Apply the input offset to the sg.
     */
    sg_index = sg_offset;

    /* Init the sgs with the memory we just allocated.
     */
    while (bytes > 0)
    {
        /* Fill each sg entry with either our max allowed or the remaining 
         * bytes. 
         */
        fbe_u64_t current_bytes = FBE_MIN(bytes, max_bytes_per_sg_entry);
        fbe_sg_element_init(&sg_p[sg_index], (fbe_u32_t)current_bytes, sectors_p);

        /* We should not exceed the length of the sg we allocated.
         */
        //MUT_ASSERT_TRUE(sg_index < sg_length);
        sg_index++;
        bytes -= current_bytes;
        sectors_p += current_bytes;
    }
    /* Terminate the list.
     */
    fbe_sg_element_terminate(&sg_p[sg_index]);
    
    return sg_p;
}
/******************************************
 * end fbe_test_io_alloc_memory_with_sg_offset()
 ******************************************/

/*!***************************************************************
 * @fn fbe_test_io_write_pattern(
 *                          fbe_object_id_t object_id,
 *                          fbe_test_io_pattern_t pattern,
 *                          fbe_u32_t pass_count,
 *                          fbe_payload_block_operation_opcode_t opcode,
 *                          fbe_lba_t lba,
 *                          fbe_block_count_t blocks,
 *                          fbe_u32_t exported_block_size,
 *                          fbe_block_size_t exported_opt_block_size,
 *                          fbe_block_size_t imported_block_size,
 *                          fbe_api_block_status_values_t * const block_status_p,
 *                          fbe_u32_t * const qualifier_p)
 ****************************************************************
 * @brief
 *  This function performs a write with pattern.
 *
 * @param object_id - Object ID to write.
 * @param pattern - Pattern to write. 
 * @param pass_count - Pass count to use when seeding.
 * @param opcode - Operation to use for this write.
 * @param lba - Start logical block address of write.
 * @param blocks - Total blocks to write.
 * @param exported_block_size - Exported block size to use in write.
 * @param exported_opt_block_size - Number of exported blocks in the optimal
 *                                  block size
 * @param imported_block_size - Imported block size to use in write.
 * @param block_status_p - The block payload status.
 * @param qualifier_p - The packet qualifier.
 *
 * @return
 *  The status of the write.
 *  Anything other than FBE_STATUS_OK indicates failure.
 *
 * HISTORY:
 *  11/26/07 - Created. RPF
 *
 ****************************************************************/
fbe_status_t 
fbe_test_io_write_pattern( fbe_object_id_t object_id,
                           fbe_test_io_pattern_t pattern,
                           fbe_u32_t pass_count,
                           fbe_payload_block_operation_opcode_t opcode,
                           fbe_lba_t lba,
                           fbe_block_count_t blocks,
                           fbe_u32_t exported_block_size,
                           fbe_block_size_t exported_opt_block_size,
                           fbe_block_size_t imported_block_size,
                           fbe_api_block_status_values_t * const block_status_p,
                           fbe_u32_t * const qualifier_p )
{
    fbe_sg_element_t *sg_p;
    fbe_status_t status;

    /* Get the memory for our sg.
     */ 
    sg_p = fbe_test_io_alloc_memory_with_sg_offset(exported_block_size * blocks,    /* Bytes to alloc. */
                                                   0, 0, /* offset and extra length */
                                                   fbe_test_io_get_write_max_bytes_per_sg());
    
    if (sg_p == NULL)
    {
        /* We cannot continue if no memory is available.
         */
        status = FBE_STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }
    /* Fill out the sg we allocated with this pattern.
     * We start filling the pattern after any offset we might have in the sg. 
     */
    fbe_test_fill_seeded_pattern(object_id, pattern, pass_count, 
                                 lba, blocks, exported_block_size, 
                                 fbe_sg_element_address(sg_p));

    status = fbe_test_io_issue_write(object_id,
                                     opcode,
                                     lba,
                                     blocks,
                                     exported_block_size,
                                     exported_opt_block_size,
                                     imported_block_size,
                                     sg_p,
                                     block_status_p,
                                     qualifier_p);

    fbe_test_io_free_memory_with_sg(&sg_p);
    
    return status;
}
/* end fbe_test_io_write_pattern() */

/*!***************************************************************
 * @fn fbe_test_io_issue_read(fbe_object_id_t object_id,   
 *                            fbe_payload_block_operation_opcode_t opcode,
 *                            fbe_u32_t pass_count,
 *                            fbe_lba_t lba,
 *                            fbe_block_count_t blocks,
 *                            fbe_block_size_t exported_block_size,
 *                            fbe_block_size_t exported_opt_block_size,
 *                            fbe_block_size_t imported_block_size,   
 *                            fbe_lba_t bad_lba,
 *                            fbe_api_block_status_values_t *const block_status_p,
 *                            fbe_u32_t * const qualifier_p)
 ****************************************************************
 * @brief
 *  This function performs a read.
 *
 * @param object_id - Object ID to read.   
 * @param opcode - The opcode to issue for this read.   
 *                 Allows us to treat different opcodes like a read operation   
 *                 Such as read and remap or read.   
 * @param pass_count - Pass count to use when seeding.
 * @param lba - Start logical block address of read.
 * @param blocks - Total blocks to read.
 * @param exported_block_size - Exported block size in bytes to use in read.
 * @param exported_opt_block_size - Number of exported blocks per optimal block.
 * @param imported_block_size - Imported block size in bytes.
 * @param block_status_p - The block operation status.
 * @param qualifier_p - The qualifier status.
 *
 * @return
 *  The status of the read.
 *  Anything other than FBE_STATUS_OK indicates failure.
 *
 * HISTORY:
 *  11/26/07 - Created. RPF
 *
 ****************************************************************/
fbe_status_t 
fbe_test_io_issue_read( fbe_object_id_t object_id,
                        fbe_payload_block_operation_opcode_t opcode,
                        fbe_u32_t pass_count,
                        fbe_lba_t lba,
                        fbe_block_count_t blocks,
                        fbe_block_size_t exported_block_size,
                        fbe_block_size_t exported_opt_block_size,
                        fbe_block_size_t imported_block_size,
                        fbe_api_block_status_values_t *const block_status_p,
                        fbe_u32_t * const qualifier_p )
{
    fbe_sg_element_t *sg_p;
    fbe_status_t status;

    /* Get the memory for our sg.
     */ 
    sg_p = fbe_test_io_alloc_memory_with_sg_offset(exported_block_size * blocks, /* Bytes to alloc. */
                                                   0, 0, /* offset and extra length */
                                                   fbe_test_io_get_read_max_bytes_per_sg());
    
    if (sg_p == NULL)
    {
        status = FBE_STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }

    /* Clear out the buffer before we send it.
     * We start clearing out after any offset we might have in the sg. 
     */
    fbe_zero_memory(fbe_sg_element_address(sg_p), (fbe_u32_t)(exported_block_size * blocks));

    /* Send the operation and free the memory.
     */
    status = fbe_test_io_send_block_payload( 
                                             object_id,
                                             opcode,
                                             lba,
                                             blocks,
                                             exported_block_size, /* requested block size */
                                             exported_opt_block_size,
                                             sg_p, /* Scatter gather ptr */
                                             NULL, /* edge descriptor */
                                             qualifier_p,
                                             block_status_p );
    fbe_test_io_free_memory_with_sg(&sg_p);
    return status;
}
/* end fbe_test_io_issue_read() */

/*!***************************************************************
 * @fn fbe_test_io_issue_verify(fbe_object_id_t object_id,
 *                            fbe_u32_t pass_count,
 *                            fbe_lba_t lba,
 *                            fbe_block_count_t blocks,
 *                            fbe_block_size_t exported_block_size,
 *                            fbe_block_size_t exported_opt_block_size,
 *                            fbe_u32_t *const qualifier_p)
 ****************************************************************
 * @brief
 *  This function performs a verify.
 *
 * @param object_id - Object ID to write.
 * @param pass_count - Pass count to use when seeding.
 * @param lba - Start logical block address of verify.
 * @param blocks - Total blocks to verify.
 * @param exported_block_size - Exported block size in bytes to use in verify.
 * @param exported_opt_block_size - Exported optimum block size in exported
 *                                  blocks to use in verify.
 * @param qualifier_p - The qualifier status.
 *
 * @return
 *  The status of the operation.
 *  Anything other than FBE_STATUS_OK indicates failure.
 *
 * HISTORY:
 *  05/20/08 - Created. RPF
 *
 ****************************************************************/
fbe_status_t 
fbe_test_io_issue_verify( fbe_object_id_t object_id,
                          fbe_u32_t pass_count,
                          fbe_lba_t lba,
                          fbe_block_count_t blocks,
                          fbe_block_size_t exported_block_size,
                          fbe_block_size_t exported_opt_block_size,
                          fbe_u32_t *const qualifier_p )
{
    fbe_status_t status;
    fbe_api_block_status_values_t block_status;

    /* Send the operation and free the memory.
     */
    status = fbe_test_io_send_block_payload( object_id,
                                             FBE_PAYLOAD_BLOCK_OPERATION_OPCODE_VERIFY,
                                             lba,
                                             blocks,
                                             exported_block_size, /* requested block size */
                                             exported_opt_block_size,
                                             NULL, /* Sg element */
                                             NULL, /* edge descriptor */
                                             qualifier_p,
                                             &block_status );
//  MUT_ASSERT_INT_EQUAL_MSG(status,
//                           FBE_STATUS_OK,
//                           "fbe_test_io_issue_verify() fbe_test_send_io_block_command() transport failed for verify.");
//  MUT_ASSERT_INT_EQUAL_MSG(block_status.status,
//                           FBE_PAYLOAD_BLOCK_OPERATION_STATUS_SUCCESS,
//                           "fbe_test_io_issue_verify() fbe_test_send_io_block_command() block verify failed.");
    return status;
}
/* end fbe_test_io_issue_verify() */

/*!***************************************************************
 * @fn fbe_test_io_read_check_pattern(
 *                         fbe_object_id_t object_id,
 *                         fbe_test_io_pattern_t pattern,
 *                         fbe_u32_t pass_count,
 *                         fbe_lba_t lba,
 *                         fbe_block_count_t blocks,
 *                         fbe_block_size_t exported_block_size,
 *                         fbe_block_size_t exported_opt_block_size,
 *                         fbe_block_size_t imported_block_size,
 *                         fbe_payload_block_operation_status_t * const block_status_p,
 *                         fbe_payload_block_operation_qualifier_t * const block_qualifier_p,
 *                         fbe_u32_t * const qualifier_p)
 ****************************************************************
 * @brief
 *  This function performs a read and pattern check.
 *
 * @param object_id - Object ID to issue read/check to.
 * @param pattern - Pattern to check for.
 * @param pass_count - Pass count to use when seeding.
 * @param lba - Start logical block address to check.
 * @param blocks - Total blocks.
 * @param exported_block_size - Exported block size to use.
 * @param exported_opt_block_size - Exported optimal block size to use.
 * @param imported_block_size - Imported block size to use.
 * @param block_status_p - The block payload status.
 * @param block_qualifier_p - The block payload qualifier.
 * @param qualifier_p - The qualifier status.
 *
 * @return
 *  The status of the read/check.
 *  Anything other than FBE_STATUS_OK indicates failure.
 *
 * HISTORY:
 *  11/26/07 - Created. RPF
 *
 ****************************************************************/
fbe_status_t fbe_test_io_read_check_pattern( fbe_object_id_t object_id,
                                             fbe_test_io_pattern_t pattern,
                                             fbe_u32_t pass_count,
                                             fbe_lba_t lba,
                                             const fbe_block_count_t blocks,
                                             fbe_block_size_t exported_block_size,
                                             fbe_block_size_t exported_opt_block_size,
                                             fbe_block_size_t imported_block_size,
                                             fbe_payload_block_operation_status_t * const block_status_p,
                                             fbe_payload_block_operation_qualifier_t * const block_qualifier_p,
                                             fbe_u32_t * const qualifier_p )
{
    fbe_sg_element_t *sg_p;
    fbe_status_t status;
    fbe_api_block_status_values_t block_status;

//  MUT_ASSERT_INT_NOT_EQUAL_MSG(pattern,
//                               FBE_IO_TEST_TASK_PATTERN_NONE,
//                               "pattern must not be FBE_IO_TEST_TASK_PATTERN_NONE");

    /* Allocate our sg with memory.
     */
    sg_p = fbe_test_io_alloc_memory_with_sg_offset(exported_block_size * blocks, /* Bytes to alloc. */
                                                   0, 0, /* offset and extra length */
                                                   fbe_test_io_get_read_max_bytes_per_sg() );
    if (sg_p == NULL)
    {
        /* If we are unable to allocate, return an error.
         */
        status = FBE_STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }

    /* Send the operation.
     */
    status = fbe_test_io_send_block_payload( object_id,
                                             FBE_PAYLOAD_BLOCK_OPERATION_OPCODE_READ,
                                             lba,
                                             blocks,
                                             exported_block_size, /* requested block size */
                                             exported_opt_block_size,
                                             sg_p, /* Sg element */
                                             NULL, /* edge descriptor */
                                             qualifier_p,
                                             &block_status  );
    *block_status_p = block_status.status;
    *block_qualifier_p = block_status.qualifier;

    /* If something went wrong with the read, return status now.
     */
    if ((status != FBE_STATUS_OK) || (*block_status_p != FBE_PAYLOAD_BLOCK_OPERATION_STATUS_SUCCESS))
    {
        fbe_test_io_free_memory_with_sg(&sg_p);
        return status;
    }

    /* Next, check the pattern in the blocks we read.
     */

    {
        /* We start off the current SG at the point where our memory starts 
         * (after any sg offset we might have). 
         */
        fbe_sg_element_t *current_sg_p = sg_p;
        fbe_block_count_t current_blocks = blocks;
        fbe_lba_t current_lba = lba;
        fbe_block_count_t total_blocks = 0;

        /* Loop over each of the sg entries, checking the pattern for each.
         * We increment the lba and total blocks for the number of blocks 
         * in the sg element. 
         */
        while (total_blocks < blocks)
        {
            /* Our block count is the number of exported blocks in this sg 
             * entry. 
             */
            current_blocks = fbe_sg_element_count(current_sg_p) / exported_block_size;

            /* Check the pattern for this sg entry's memory.
             */
            status = fbe_test_check_buffer_for_pattern(object_id, pattern, 
                                                       pass_count, current_lba, 
                                                       current_blocks,
                                                       blocks, /* original operation block count. */
                                                       total_blocks, /* offset from start of transfer. */
                                                       exported_block_size, 
                                                       fbe_sg_element_address(current_sg_p));
            if (status != FBE_STATUS_OK)
            {
//              mut_printf(MUT_LOG_HIGH, "logical drive: Read pattern incorrect "
//                                       "for lba: %lld bl: %d Status: %d",
//                         lba, blocks, status);
                break;
            }
            /* Increment the lba and blocks for the total blocks in this sg 
             * element. 
             */
            current_lba += current_blocks;
            total_blocks += current_blocks;
            current_sg_p++;
        }
    } /* end if status is good. */
    
    fbe_test_io_free_memory_with_sg(&sg_p);
    return status;
}
/* end fbe_test_io_read_check_pattern() */

/*************************
 * end file fbe_test_io.c
 *************************/

