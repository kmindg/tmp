/***************************************************************************
 * Copyright (C) EMC Corporation 2008
 * All rights reserved.
 * Licensed material -- property of EMC Corporation
 ***************************************************************************/

/**************************************************************************
 * fbe_all_enclosure_functions_test.c
 ***************************************************************************
 *
 *  This file contains test functions for testing the main
 *  functions for the sas viper enclosure
 *
 * HISTORY
 *   9/19/2008:  Created. DP
 *
 ***************************************************************************/

/*************************
 *   INCLUDE FILES
 *************************/
#include "fbe_ses.h"
#include "sas_viper_enclosure_private.h"
#include "fbe_enclosure_test_prototypes.h"
#include "fbe_transport_memory.h"
#include "fbe_interface.h"
#include "fbe_enclosure_data_access_public.h"
//#include "edal_eses_enclosure_data.h"
#include "mut.h"
#include "fbe_sas_port.h"
#include "fbe_scsi.h"
#include "fbe_eses_enclosure_config.h"
#include "fbe_physical_package.h"

#define NUM_ACTUAL_ELEM_GROUPS 8
#define MAX_SUBENCL_NUM   5
#define FBE_ESES_MAX_NUM  20
#define MAX_ENCL_DATA_BLOCK 2
#define TEST_FBE_ASSERT_AT_COMPILE_TIME FBE_ASSERT_AT_COMPILE_TIME(((FBE_ESES_MAX_NUM * sizeof(fbe_eses_elem_group_t))+ \
                                (FBE_SAS_VIPER_ENCLOSURE_NUMBER_OF_SLOTS * sizeof(fbe_eses_enclosure_drive_info_t))) \
                               < FBE_MEMORY_CHUNK_SIZE)
/************
 * STRUCTS
 ************/
typedef struct 
{
    fbe_u8_t                         subencl_id;
    fbe_enclosure_component_types_t  comp_type;
    fbe_u8_t                         comp_index;
    fbe_u8_t                         side_id;
} test_fbe_eses_subencl_mapping_t;

fbe_status_t test_fbe_lifecycle_set_state(fbe_lifecycle_const_t * p_class_const,
                                     struct fbe_base_object_s * p_object,
                                     fbe_lifecycle_state_t new_state);
/* temp for testing - DP*/
fbe_status_t fbe_set_components_elem_group_test(fbe_eses_elem_group_t * elem_group);
// utility function
extern fbe_enclosure_component_block_t *fbe_sas_viper_init_component_block(fbe_sas_viper_enclosure_t * viperEnclPtr, fbe_u8_t *buffer);
void test_fbe_eses_setup_test_environ(fbe_eses_enclosure_t * eses_enclosure);

fbe_object_handle_t test_object_handle;
extern fbe_u8_t test_encl_comp_data[MAX_ENCL_DATA_BLOCK*FBE_MEMORY_CHUNK_SIZE];
extern fbe_eses_elem_group_t test_eses_elem_group[FBE_SAS_VIPER_ENCLOSURE_NUMBER_OF_POSSIBLE_ELEM_GROUPS];

fbe_u8_t   fbe_sas_viper_enclosure_drive_slot_to_phy_id11[FBE_SAS_VIPER_ENCLOSURE_NUMBER_OF_SLOTS]=
{20, 22, 23, 21, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9};

fbe_u8_t   fbe_sas_viper_enclosure_phy_index_to_phy_id11[FBE_SAS_VIPER_ENCLOSURE_NUMBER_OF_EXPANDER_PHYS]=
{0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23};
fbe_eses_elem_group_t  eses_elem_group_table [NUM_ACTUAL_ELEM_GROUPS]  = 
{
 //elem_type, num_possible_elems, subencl_id, first_elem_index, byte_offset
 { SES_ELEM_TYPE_PS, 1, 3, 114,512 },
 { SES_ELEM_TYPE_SAS_CONN, 4 , 0 , 38,172 },
 { SES_ELEM_TYPE_ARRAY_DEV_SLOT, 15 , 0 , 48,216 },
 { SES_ELEM_TYPE_EXP_PHY,23 , 0 , 65,296 },
 { SES_ELEM_TYPE_SAS_EXP , 23 , 0 , 0,8  },
 { SES_ELEM_TYPE_COOLING , 2 , 3 , 115,520},
 { SES_ELEM_TYPE_TEMP_SENSOR , 1 , 0 , 112,496  },
 { SES_ELEM_TYPE_INVALID , 0 , 0 ,0 , 0 }
};      

test_fbe_eses_subencl_mapping_t  test_fbe_eses_subencl_mapping_table [MAX_SUBENCL_NUM] = 
{
  //{subencl_id, EDAL comp type, EDAL comp index}, 
 { 0, FBE_ENCL_LCC, 0, 0},
 { 1, FBE_ENCL_LCC, 1, 1},
 { 2, FBE_ENCL_ENCLOSURE, 0, 0},
 { 3, FBE_ENCL_POWER_SUPPLY, 0, 0},
 { 4, FBE_ENCL_POWER_SUPPLY, 1, 1}
};   

#define MAX_VALUES 11
#define MIN_VALUES 0
#define BUFFER_MAX  11
#define MIN_INDEX 0
#define ARRAY_INDEX 465

typedef  struct scsi_status_table_t{
int opcode;
int scsi_status ;
int cdb_request_status ;
int enclosure_return_status ;
fbe_u8_t sense_info_buffer_test1;
fbe_u8_t sense_info_buffer_test2 ;
fbe_u8_t sense_info_buffer_test3 ;
fbe_u8_t sense_info_buffer_test4 ;
}scsi_status_table_t;   


scsi_status_table_t  scsi_hardcoded[ARRAY_INDEX ] = {

    //for opcode FBE_ESES_PAGE_OPCODE_GET_CONFIGURATION
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_SUCCESS , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,  FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_BUSY, FBE_ENCLOSURE_STATUS_BUSY , NULL,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,   FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },  
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,   FBE_PAYLOAD_CDB_SCSI_STATUS_BUSY,       NULL  ,   FBE_ENCLOSURE_STATUS_BUSY  , NULL,NULL,NULL,NULL     },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,   FBE_PAYLOAD_CDB_SCSI_STATUS_TASK_SET_FULL, NULL,  FBE_ENCLOSURE_STATUS_BUSY    , NULL,NULL,NULL,NULL                                                    },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },     
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_OVERRUN , FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x01   },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x01   },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_GET_CONFIGURATION,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
            
        
   //for opcode FBE_ESES_PAGE_OPCODE_GET_ENCL_STATUS
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_SUCCESS , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,  FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_BUSY, FBE_ENCLOSURE_STATUS_BUSY , NULL,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,   FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },  
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,   FBE_PAYLOAD_CDB_SCSI_STATUS_BUSY,       NULL  ,   FBE_ENCLOSURE_STATUS_BUSY  , NULL,NULL,NULL,NULL     },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,   FBE_PAYLOAD_CDB_SCSI_STATUS_TASK_SET_FULL, NULL,  FBE_ENCLOSURE_STATUS_BUSY    , NULL,NULL,NULL,NULL                                                    },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },     
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_OVERRUN , FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },  
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   }, 
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_GET_ENCL_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },    


   //for opcode FBE_ESES_PAGE_OPCODE_SET_TRACE_BUF_INFO_CTRL 

  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_SUCCESS , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,  FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_ENCLOSURE_STATUS_BUSY, FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,   FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },  
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,   FBE_PAYLOAD_CDB_SCSI_STATUS_BUSY,       NULL  ,   FBE_ENCLOSURE_STATUS_BUSY  , NULL,NULL,NULL,NULL     },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,   FBE_PAYLOAD_CDB_SCSI_STATUS_TASK_SET_FULL, NULL,  FBE_ENCLOSURE_STATUS_BUSY    , NULL,NULL,NULL,NULL                                                    },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,   FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },     
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_OVERRUN , FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL   } ,                    
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x01   },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x01   }, 
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },  
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },     
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_SET_TRACE_BUF_INFO_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },        
        
    
   //for opcode FBE_ESES_PAGE_OPCODE_GET_EMC_SPECIFIC_STATUS 
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_SUCCESS , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,  FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_BUSY, FBE_ENCLOSURE_STATUS_BUSY , NULL,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,   FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },  
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,   FBE_PAYLOAD_CDB_SCSI_STATUS_BUSY,       NULL  ,   FBE_ENCLOSURE_STATUS_BUSY  , NULL,NULL,NULL,NULL     },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,   FBE_PAYLOAD_CDB_SCSI_STATUS_TASK_SET_FULL, NULL,  FBE_ENCLOSURE_STATUS_BUSY    , NULL,NULL,NULL,NULL                                                    },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },     
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_OVERRUN , FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },    
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_UNSUPPORTED_PAGE_HANDLED,0x70, 0x05,0x35,0x01   },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_UNSUPPORTED_PAGE_HANDLED,0x70, 0x05,0x35,0x01   },  
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },  
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },      
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_GET_EMC_SPECIFIC_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },          
            
            
   //for opcode FBE_ESES_PAGE_OPCODE_GET_DOWNLOAD_STATUS 

  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_SUCCESS , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,  FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_BUSY, FBE_ENCLOSURE_STATUS_BUSY , NULL,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,   FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },  
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,   FBE_PAYLOAD_CDB_SCSI_STATUS_BUSY,       NULL  ,   FBE_ENCLOSURE_STATUS_BUSY  , NULL,NULL,NULL,NULL     },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,   FBE_PAYLOAD_CDB_SCSI_STATUS_TASK_SET_FULL, NULL,  FBE_ENCLOSURE_STATUS_BUSY    , NULL,NULL,NULL,NULL                                                    },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },     
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_OVERRUN , FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL   }    ,      
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },  
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x01   },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x01   }, 
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },      
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },         
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_GET_DOWNLOAD_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },        
            

   //for opcode FBE_ESES_PAGE_OPCODE_DOWNLOAD_FIRMWARE 
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_SUCCESS , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,  FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_BUSY, FBE_ENCLOSURE_STATUS_BUSY , NULL,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,   FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },    
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,   FBE_PAYLOAD_CDB_SCSI_STATUS_BUSY,       NULL  ,   FBE_ENCLOSURE_STATUS_BUSY  , NULL,NULL,NULL,NULL     },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,   FBE_PAYLOAD_CDB_SCSI_STATUS_TASK_SET_FULL, NULL,  FBE_ENCLOSURE_STATUS_BUSY    , NULL,NULL,NULL,NULL                                                    },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },   
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_OVERRUN , FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },    
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x01   },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x01   },       
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },        
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },               
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_DOWNLOAD_FIRMWARE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },      
                

  //for opcode FBE_ESES_PAGE_OPCODE_GET_TRACE_BUF_INFO_STATUS 
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_SUCCESS , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,  FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_BUSY, FBE_ENCLOSURE_STATUS_BUSY , NULL,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,   FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },    
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,   FBE_PAYLOAD_CDB_SCSI_STATUS_BUSY,       NULL  ,   FBE_ENCLOSURE_STATUS_BUSY  , NULL,NULL,NULL,NULL     },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,   FBE_PAYLOAD_CDB_SCSI_STATUS_TASK_SET_FULL, NULL,  FBE_ENCLOSURE_STATUS_BUSY    , NULL,NULL,NULL,NULL                                                    },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },   
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_OVERRUN , FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x01   },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x01   },   
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },                   
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_GET_TRACE_BUF_INFO_STATUS,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   }   ,


   //for opcode FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL      

  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_SUCCESS , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,  FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_BUSY, FBE_ENCLOSURE_STATUS_BUSY , NULL,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,   FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },  
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,   FBE_PAYLOAD_CDB_SCSI_STATUS_BUSY,       NULL  ,   FBE_ENCLOSURE_STATUS_BUSY  , NULL,NULL,NULL,NULL     },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,   FBE_PAYLOAD_CDB_SCSI_STATUS_TASK_SET_FULL, NULL,  FBE_ENCLOSURE_STATUS_BUSY    , NULL,NULL,NULL,NULL                                                    },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },     
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_OVERRUN , FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },    
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },   
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_SET_EMC_SPECIFIC_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },


   //for opcode FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL      

  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_SUCCESS , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,  FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_BUSY, FBE_ENCLOSURE_STATUS_BUSY , NULL,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,   FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },  
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,   FBE_PAYLOAD_CDB_SCSI_STATUS_BUSY,       NULL  ,   FBE_ENCLOSURE_STATUS_BUSY  , NULL,NULL,NULL,NULL     },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,   FBE_PAYLOAD_CDB_SCSI_STATUS_TASK_SET_FULL, NULL,  FBE_ENCLOSURE_STATUS_BUSY    , NULL,NULL,NULL,NULL                                                    },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },     
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_OVERRUN , FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },    
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },   
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_SET_ENCL_CTRL,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },

   // for opcode    FBE_ESES_CTRL_OPCODE_READ_BUF

  {  FBE_ESES_CTRL_OPCODE_READ_BUF, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_SUCCESS , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,  FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_BUSY, FBE_ENCLOSURE_STATUS_BUSY , NULL,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,   FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },  
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,   FBE_PAYLOAD_CDB_SCSI_STATUS_BUSY,       NULL  ,   FBE_ENCLOSURE_STATUS_BUSY  , NULL,NULL,NULL,NULL     },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,   FBE_PAYLOAD_CDB_SCSI_STATUS_TASK_SET_FULL, NULL,  FBE_ENCLOSURE_STATUS_BUSY    , NULL,NULL,NULL,NULL                                                    },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },     
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_OVERRUN , FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   }, 
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },    
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_READ_BUF,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },


 // for opcode  FBE_ESES_CTRL_OPCODE_MODE_SENSE 
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_SUCCESS , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,  FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_BUSY, FBE_ENCLOSURE_STATUS_BUSY , NULL,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,   FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },  
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,   FBE_PAYLOAD_CDB_SCSI_STATUS_BUSY,       NULL  ,   FBE_ENCLOSURE_STATUS_BUSY  , NULL,NULL,NULL,NULL     },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,   FBE_PAYLOAD_CDB_SCSI_STATUS_TASK_SET_FULL, NULL,  FBE_ENCLOSURE_STATUS_BUSY    , NULL,NULL,NULL,NULL                                                    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },     
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_OVERRUN , FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_UNSUPPORTED_PAGE_HANDLED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_UNSUPPORTED_PAGE_HANDLED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },   
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },  
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SENSE,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },

  //for opcode FBE_ESES_CTRL_OPCODE_MODE_SELECT
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_SUCCESS , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,  FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_BUSY, FBE_ENCLOSURE_STATUS_BUSY , NULL,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,   FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },  
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,   FBE_PAYLOAD_CDB_SCSI_STATUS_BUSY,       NULL  ,   FBE_ENCLOSURE_STATUS_BUSY  , NULL,NULL,NULL,NULL     },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,   FBE_PAYLOAD_CDB_SCSI_STATUS_TASK_SET_FULL, NULL,  FBE_ENCLOSURE_STATUS_BUSY    , NULL,NULL,NULL,NULL                                                    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },     
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_OVERRUN , FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_UNSUPPORTED_PAGE_HANDLED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_UNSUPPORTED_PAGE_HANDLED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },  
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   }, 
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_MODE_SELECT,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
    
  //for opcode FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_SUCCESS , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,  FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_BUSY, FBE_ENCLOSURE_STATUS_BUSY , NULL,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,   FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },  
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,   FBE_PAYLOAD_CDB_SCSI_STATUS_BUSY,       NULL  ,   FBE_ENCLOSURE_STATUS_BUSY  , NULL,NULL,NULL,NULL     },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,   FBE_PAYLOAD_CDB_SCSI_STATUS_TASK_SET_FULL, NULL,  FBE_ENCLOSURE_STATUS_BUSY    , NULL,NULL,NULL,NULL                                                    },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },     
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_OVERRUN , FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   }, 
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },    
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_GET_INQUIRY_DATA,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },


  //    fpr opcode FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY

  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_SUCCESS , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,  FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_BUSY, FBE_ENCLOSURE_STATUS_BUSY , NULL,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,  FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,  FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,  FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,  FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,  FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },  
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,   FBE_PAYLOAD_CDB_SCSI_STATUS_BUSY,       NULL  ,   FBE_ENCLOSURE_STATUS_BUSY  , NULL,NULL,NULL,NULL     },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,   FBE_PAYLOAD_CDB_SCSI_STATUS_TASK_SET_FULL, NULL,  FBE_ENCLOSURE_STATUS_BUSY    , NULL,NULL,NULL,NULL                                                    },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x72,NULL,NULL,NULL    } ,
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,NULL,NULL,NULL    },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x3F,0x00    },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x06,0x29,0x00    },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x31,0x00     },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0B,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x0A,NULL,NULL  },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70,0x06,0x2a,0x01   },     
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_OVERRUN , FBE_ENCLOSURE_STATUS_CDB_REQUEST_FAILED , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN , FBE_ENCLOSURE_STATUS_OK , NULL,NULL,NULL,NULL   },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ENCL_FUNC_UNSUPPORTED,0x70, 0x05,0x35,0x001   },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_CMD_FAILED,0x70, 0x05,0x35,0x04   },    
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_ILLEGAL_REQUEST,0x70, 0x05,0x26,0x00   },   
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   },
  {  FBE_ESES_CTRL_OPCODE_VALIDATE_IDENTITY,    FBE_PAYLOAD_CDB_SCSI_STATUS_RESERVATION_CONFLICT,  NULL, FBE_ENCLOSURE_STATUS_HARDWARE_ERROR,0x70, 0x04,0x35,0x04   }   
  };


/***************************************************************
 *  test_fbe_eses_build_receive_diagnostic_results_cdb()
 ****************************************************************
 * 
 *  Validates the size of the CDB and builds the CDB to 
 *  send "RECEIVE_DIAGNOSTIC_RESULTS" command.
 *
 * @param 
 *                    
 *
 * @return status
 *
 * HISTORY:
 *  8/22/2008 - Created. DP
 *
 ****************************************************************/

void test_fbe_eses_build_receive_diagnostic_results_cdb(void)
{

    fbe_eses_receive_diagnostic_results_cdb_t *cdb_page;
    fbe_status_t status;
    fbe_u16_t response_buffer_size = 0;
    fbe_u16_t cdb_buffer_size = SAS_PORT_MAX_SES_CDB_SIZE;
    ses_pg_code_enum page_code = 0;
    fbe_u8_t cdb[32];

    mut_printf(MUT_LOG_MEDIUM, "%s %s ",__FILE__, __FUNCTION__);
    
    /*------------------------------Test 1-----------------------------------*/
    //                                                                       //
    //    pagecode =  SES_PG_CODE_ADDL_ELEM_STAT                             //
    //    response_buffer_size = ESES_ENCLOSURE_ADDL_STATUS_PAGE_MAX_SIZE  ..//
    //                                                                       //
    /*-----------------------------------------------------------------------*/
   
    page_code =  SES_PG_CODE_ADDL_ELEM_STAT;
    response_buffer_size = ESES_ENCLOSURE_ADDL_STATUS_PAGE_MAX_SIZE;    

    status = fbe_eses_build_receive_diagnostic_results_cdb(cdb, 
                                                          SAS_PORT_MAX_SES_CDB_SIZE, 
                                                          response_buffer_size,
                                                          page_code);

    MUT_ASSERT_TRUE(status == FBE_STATUS_OK);
    
    cdb_page = (fbe_eses_receive_diagnostic_results_cdb_t *)cdb;
   
    MUT_ASSERT_TRUE(cdb_page->operation_code == FBE_SCSI_RECEIVE_DIAGNOSTIC);
    MUT_ASSERT_TRUE(cdb_page->page_code_valid == 1);
    MUT_ASSERT_TRUE(cdb_page->rsvd == 0);
    MUT_ASSERT_TRUE(cdb_page->page_code == page_code);
    MUT_ASSERT_TRUE(cdb_page->alloc_length_msbyte == ((response_buffer_size & 0xFF00) >> 8));
    MUT_ASSERT_TRUE(cdb_page->alloc_length_lsbyte == (response_buffer_size & 0xFF));
    MUT_ASSERT_TRUE(cdb_page->control == 0);


    /*---------------------------Test 2--------------------------------------*/
    //                                                                       //
    //    pagecode =  SES_PG_CODE_ENCL_STAT                                  //
    //    response_buffer_size = ESES_ENCLOSURE_STATUS_PAGE_MAX_SIZE  .......//
    //                                                                       //
    /*-----------------------------------------------------------------------*/
   
    page_code =  SES_PG_CODE_ENCL_STAT;
    response_buffer_size = ESES_ENCLOSURE_STATUS_PAGE_MAX_SIZE;

    status = fbe_eses_build_receive_diagnostic_results_cdb(cdb,
                                                          SAS_PORT_MAX_SES_CDB_SIZE, 
                                                          response_buffer_size,
                                                          page_code);

    MUT_ASSERT_TRUE(status == FBE_STATUS_OK);

    cdb_page = (fbe_eses_receive_diagnostic_results_cdb_t *)cdb;
   
    MUT_ASSERT_TRUE(cdb_page->operation_code == FBE_SCSI_RECEIVE_DIAGNOSTIC);
    MUT_ASSERT_TRUE(cdb_page->page_code_valid == 1);
    MUT_ASSERT_TRUE(cdb_page->rsvd == 0);
    MUT_ASSERT_TRUE(cdb_page->page_code == page_code);
    MUT_ASSERT_TRUE(cdb_page->alloc_length_msbyte == ((response_buffer_size & 0xFF00) >> 8));
    MUT_ASSERT_TRUE(cdb_page->alloc_length_lsbyte == (response_buffer_size & 0xFF));
    MUT_ASSERT_TRUE(cdb_page->control == 0); 

    /*---------------------------Test 3----------------------------------------*/
    //                                                                         //
    //    cdb_buffer_size < SAS_PORT_MAX_SES_CDB_SIZE;                         //
    //    pagecode =  SES_PG_CODE_ENCL_STAT                                    //
    //    response_buffer_size = ESES_ENCLOSURE_STATUS_PAGE_MAX_SIZE           //
    //                                                                         //
    /*-------------------------------------------------------------------------*/

    cdb_buffer_size = SAS_PORT_MAX_SES_CDB_SIZE - 1;

    status = fbe_eses_build_receive_diagnostic_results_cdb(cdb, 
                                                          cdb_buffer_size, 
                                                          response_buffer_size,
                                                          page_code);
    
    MUT_ASSERT_TRUE(status == FBE_STATUS_GENERIC_FAILURE);

    /*---------------------------Test 4-----------------------------------------------*/
    //                                                                         .......//
    //    If cdb == NULL (At this time this case is not handled in orignal function)..//
    //             So commented for time being                                        //
    /*--------------------------------------------------------------------------------*/

    /*cdb_buffer_size = SAS_PORT_MAX_SES_CDB_SIZE;

    status = fbe_eses_build_receive_diagnostic_results_cdb(NULL, 
                                                          cdb_buffer_size, 
                                                          response_buffer_size,
                                                          page_code);

    MUT_ASSERT_TRUE(status == FBE_STATUS_OK);
    MUT_ASSERT_TRUE(status = FBE_STATUS_GENERIC_FAILURE);*/
    
    return;
}
/******************************************
 * end test_fbe_eses_build_receive_diagnostic_results_cdb()
 ******************************************/

/***************************************************************
 *  test_fbe_eses_build_send_diagnostic_cdb()
 ****************************************************************
 * 
 *  Validates size of the CDB and builds the CDB to send "SEND_DIAGNOSTIC"
 *  command which sends the control page to the EMA in the LCC.
 *
 * @param  cdb, 
 *                         
 *
 * @return Status
 *
 * HISTORY:
 *  8/22/2008 - Created. DP
 *
 ****************************************************************/

void test_fbe_eses_build_send_diagnostic_cdb(void)
{
    fbe_eses_send_diagnostic_cdb_t *cdb_page;
    fbe_status_t status;
    fbe_u16_t cmd_buffer_size = 16;
    fbe_u16_t cdb_buffer_size = SAS_PORT_MAX_SES_CDB_SIZE;
    fbe_u8_t cdb[32];
    fbe_u16_t i = 0;
    

    mut_printf(MUT_LOG_MEDIUM, "%s %s ",__FILE__, __FUNCTION__);

    /*---------------------------Test 1-----------------------------------------*/
    //                                                                          //
    //    cdb_buffer_size = SAS_PORT_MAX_SES_CDB_SIZE;                          //
    //    cmd_buffer_size = 16   to  16+100 < 1000                              //
    //                                                                          //
    /*--------------------------------------------------------------------------*/

    for(i = cmd_buffer_size; i < 1000; i = i+100)
    {
    status = fbe_eses_build_send_diagnostic_cdb(cdb,
                                                cdb_buffer_size, 
                                                i);
        
    MUT_ASSERT_TRUE(status == FBE_STATUS_OK);

    cdb_page = (fbe_eses_send_diagnostic_cdb_t *)cdb;

    MUT_ASSERT_TRUE(cdb_page->operation_code == FBE_SCSI_SEND_DIAGNOSTIC);
    MUT_ASSERT_TRUE(cdb_page->page_format == 1);
    MUT_ASSERT_TRUE(cdb_page->unit_offline == 0);
    MUT_ASSERT_TRUE(cdb_page->device_offline == 0);
    MUT_ASSERT_TRUE(cdb_page->self_test == 0);
    MUT_ASSERT_TRUE(cdb_page->self_test_code == 0);
    MUT_ASSERT_TRUE(cdb_page->rsvd == 0);
    MUT_ASSERT_TRUE(cdb_page->rsvd1 == 0);
    MUT_ASSERT_TRUE(cdb_page->param_list_length_msbyte == ((i & 0xFF00) >> 8));
    MUT_ASSERT_TRUE(cdb_page->param_list_length_lsbyte == (i & 0xFF));
    MUT_ASSERT_TRUE(cdb_page->control == 0);

    }

    /*---------------------------Test 2-------------------------------------------*/
    //                                                                            //
    //    cdb_buffer_size < SAS_PORT_MAX_SES_CDB_SIZE;                            //
    //    cmd_buffer_size = 16                                                    //
    //                                                                            //
    /*----------------------------------------------------------------------------*/

    cdb_buffer_size = SAS_PORT_MAX_SES_CDB_SIZE - 1;

    status = fbe_eses_build_send_diagnostic_cdb(cdb,
                                                cdb_buffer_size, 
                                                cmd_buffer_size);
    
    MUT_ASSERT_TRUE(status == FBE_STATUS_GENERIC_FAILURE);

    /*---------------------------Test 3---------------------------------------------*/
    //                                                                              //
    //    If cdb == NULL (At this time this case is not handled in orignal function)//
    //             So commented for time being                                      //
    /*------------------------------------------------------------------------------*/

    /*cdb_buffer_size = SAS_PORT_MAX_SES_CDB_SIZE;

    status = fbe_eses_build_send_diagnostic_cdb(NULL,
                                                cdb_buffer_size, 
                                                cmd_buffer_size);

    MUT_ASSERT_TRUE(status == FBE_STATUS_OK);
    MUT_ASSERT_TRUE(status = FBE_STATUS_GENERIC_FAILURE);*/

    
    return;
}
/******************************************
 * end test_fbe_eses_build_receive_diagnostic_results_cdb()
 ******************************************/

/*!**************************************************************
 *  @fn test_fbe_eses_setup_test_environ(fbe_eses_enclosure_t * eses_enclosure)
 ****************************************************************
 * @brief
 *    Set up the element group in eses enclosure object and 
 *    subenclosure mapping in EDAL. 
 *   
 * @param  eses_enclosure - The pointer to the eses enclosure. *                        
 *
 * @return NONE
 *
 * HISTORY:
 *  4-Mar-2009 PHE - Created. 
 *
 ****************************************************************/
void test_fbe_eses_setup_test_environ(fbe_eses_enclosure_t * eses_enclosure)
{
    fbe_u8_t subencl = 0;
    test_fbe_eses_subencl_mapping_t * subencl_mapping_p = NULL;
    fbe_edal_status_t   edalStatus;
   
    fbe_eses_enclosure_set_elem_group(eses_enclosure, test_eses_elem_group);
    fbe_eses_enclosure_init_config_info(eses_enclosure);

    //Set up the data from the config page.
    fbe_eses_enclosure_set_number_of_actual_elem_groups(eses_enclosure, NUM_ACTUAL_ELEM_GROUPS);
    fbe_copy_memory(test_eses_elem_group, eses_elem_group_table, NUM_ACTUAL_ELEM_GROUPS * sizeof(fbe_eses_elem_group_t));    

    //Initialize the subencl mapping. 
    for(subencl = 0; subencl < MAX_SUBENCL_NUM; subencl ++)
    {
        subencl_mapping_p = &(test_fbe_eses_subencl_mapping_table[subencl]);

        edalStatus = fbe_base_enclosure_edal_setU8((fbe_base_enclosure_t *)eses_enclosure,
                                                  FBE_ENCL_COMP_SUB_ENCL_ID,
                                                  subencl_mapping_p->comp_type, // Component type
                                                  subencl_mapping_p->comp_index, // Component index
                                                  subencl);
		
        edalStatus = fbe_base_enclosure_edal_setU8((fbe_base_enclosure_t *)eses_enclosure,
                                                  FBE_ENCL_COMP_SIDE_ID,
                                                  subencl_mapping_p->comp_type, // Component type
                                                  subencl_mapping_p->comp_index, 
                                                  subencl_mapping_p->side_id); // side id
    }

    return;
}

/***************************************************************
 *  test_fbe_sas_viper_enclosure_ps_extract_status()
 ****************************************************************
 *  MUT tests for Function fbe_sas_viper_enclosure_ps_extract_status
 *  which parses the power supply status. 
 *   
 * @param   
 *                        
 *
 * @return 
 *
 * HISTORY:
 *  8/22/2008 - Created. DP
 *
 ****************************************************************/

void test_fbe_sas_viper_enclosure_ps_extract_status(void)
{
    fbe_sas_viper_enclosure_t viperEnclosure , *viperEnclPtr ;
    fbe_enclosure_status_t encl_status;
    fbe_edal_status_t   edalStatus;
    fbe_u8_t group_id = 0;
    fbe_u8_t num_possible_elems = 0;
    fbe_u8_t elem_type = SES_ELEM_TYPE_INVALID;
    fbe_u16_t group_byte_offset = 0;
    fbe_u8_t first_elem_index = 0;
    fbe_u8_t stat_pg_ptr[1024];
    fbe_eses_elem_group_t *elem_group_orig = NULL;
    fbe_eses_elem_group_t *elem_group = NULL;
    ses_stat_elem_ps_struct *stat_ptr = NULL;    
    fbe_u16_t i = 0;
    fbe_bool_t  valueBool;
    fbe_u8_t     valueU8; 

    mut_printf(MUT_LOG_MEDIUM, "%s : Testing %s Start ",__FILE__, __FUNCTION__);

    /* Initialize Viper Enclosure */
    memset(&viperEnclosure, 0, sizeof(fbe_sas_viper_enclosure_t));
    viperEnclPtr = &viperEnclosure;
     
    fbe_sas_viper_init_component_block(viperEnclPtr, test_encl_comp_data);
    
    // call the FBE_ASSERT_AT_COMPILE_TIME macro
    TEST_FBE_ASSERT_AT_COMPILE_TIME ;

    test_fbe_eses_setup_test_environ((fbe_eses_enclosure_t *)viperEnclPtr);

    /* Get the elem_group so that we will know the configuration while 
     * processing the status page. 
     */
    elem_group = fbe_eses_enclosure_get_elem_group_ptr((fbe_eses_enclosure_t *)(fbe_eses_enclosure_t *)viperEnclPtr);

    for(group_id = 0; group_id < NUM_ACTUAL_ELEM_GROUPS; group_id++ )
    {
        group_byte_offset = fbe_eses_elem_group_get_group_byte_offset(elem_group, group_id);

        if(group_byte_offset == 0)
        {
            // We have processed all the groups. Let's get out of the loop.
            break; 
        }

        if(elem_group[group_id].elem_type == SES_ELEM_TYPE_PS)
        {
            elem_type = fbe_eses_elem_group_get_elem_type(elem_group, group_id);

            // Check whether the element type is valid or not. 
            if(elem_type == SES_ELEM_TYPE_INVALID)
            {
                return;
            }

            num_possible_elems = fbe_eses_elem_group_get_num_possible_elems(elem_group, group_id);
            
            first_elem_index = fbe_eses_elem_group_get_first_elem_index(elem_group, group_id);
            stat_ptr = (ses_stat_elem_ps_struct *)(fbe_eses_get_ctrl_stat_elem_p((fbe_u8_t *)(fbe_eses_ctrl_stat_elem_t *)((fbe_u8_t *)stat_pg_ptr + group_byte_offset), 0 + 1));

            edalStatus = fbe_base_enclosure_edal_setU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_ELEM_INDEX,
                                                    FBE_ENCL_POWER_SUPPLY,
                                                    0,
                                                    (first_elem_index+ 0));

            /* loop through all possible elem_stat_code (valid '0-7' and invalid '8') with ac_fail = FALSE */
            for ((stat_ptr->cmn_stat.elem_stat_code) = 0; stat_ptr->cmn_stat.elem_stat_code < 8 ; stat_ptr->cmn_stat.elem_stat_code++) 
            {
                /* for stat_ptr->ac_fail = FALSE*/
                stat_ptr->ac_fail = FALSE; 

                /* Actual call of function */
                encl_status = fbe_eses_enclosure_ps_extract_status((fbe_eses_enclosure_t *)viperEnclPtr,
                                                group_id,
                                                (fbe_eses_ctrl_stat_elem_t *)((fbe_u8_t *)stat_pg_ptr + group_byte_offset));

                if(ENCL_STAT_OK(encl_status))
                {
                    encl_status = FBE_ENCLOSURE_STATUS_OK;
                }
                
                MUT_ASSERT_TRUE(encl_status == FBE_ENCLOSURE_STATUS_OK);
                
                switch(stat_ptr->cmn_stat.elem_stat_code)
                {
                    case SES_STAT_CODE_OK:
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_AC_FAIL,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                         
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_INSERTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_POWERED_OFF,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_FAULTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_SUPPORTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);     

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);
                        
                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueU8);
                        
                        if(EDAL_STAT_OK(edalStatus))
                        {
                            edalStatus = FBE_EDAL_STATUS_OK;
                        }

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr->cmn_stat.elem_stat_code);

                    break;

                    case SES_STAT_CODE_CRITICAL:
                    case SES_STAT_CODE_NONCRITICAL:
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_AC_FAIL,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                         
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_INSERTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_POWERED_OFF,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_FAULTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_SUPPORTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);
                        
                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueU8);
                        
                        if(EDAL_STAT_OK(edalStatus))
                        {
                            edalStatus = FBE_EDAL_STATUS_OK;
                        }
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr->cmn_stat.elem_stat_code); 
                    break;
            
                    case SES_STAT_CODE_UNRECOV:
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_AC_FAIL,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                         
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);
                        
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_INSERTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_POWERED_OFF,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_FAULTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_SUPPORTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);
                        
                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueU8);

                        if(EDAL_STAT_OK(edalStatus))
                        {
                            edalStatus = FBE_EDAL_STATUS_OK;
                        }
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr->cmn_stat.elem_stat_code); 
                    break;

                    case SES_STAT_CODE_NOT_INSTALLED:
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_AC_FAIL,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                         
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_INSERTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_POWERED_OFF,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_FAULTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_SUPPORTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);        

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);
                        
                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueU8);
                        
                        if(EDAL_STAT_OK(edalStatus))
                        {
                            edalStatus = FBE_EDAL_STATUS_OK;
                        }
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr->cmn_stat.elem_stat_code); 
                    break;

                    case SES_STAT_CODE_UNAVAILABLE:
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_AC_FAIL,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                         
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);
                      
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_INSERTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_POWERED_OFF,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_FAULTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_SUPPORTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);     

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);
                        
                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueU8);
                        
                        if(EDAL_STAT_OK(edalStatus))
                        {
                            edalStatus = FBE_EDAL_STATUS_OK;
                        }
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_INT_EQUAL(valueU8,stat_ptr->cmn_stat.elem_stat_code); 
                    break;

                    case SES_STAT_CODE_UNKNOWN:
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_INSERTED,
                                                                    FBE_ENCL_POWER_SUPPLY, 
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_POWERED_OFF,
                                                                    FBE_ENCL_POWER_SUPPLY, 
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_FAULTED,
                                                                    FBE_ENCL_POWER_SUPPLY, 
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_SUPPORTED,
                                                                    FBE_ENCL_POWER_SUPPLY, 
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY, 
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);
                    break;

                    case SES_STAT_CODE_UNSUPP: 
                        // for Invalid element status code, we need to check for 
                        // FBE_ENCL_COMP_STATUS_VALID attribute only
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY, 
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);
                    break;
                       
                    default:
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_AC_FAIL,
                                                                    FBE_ENCL_POWER_SUPPLY, 
                                                                    0,
                                                                    &valueBool);
                         
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);
                        
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_INSERTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_POWERED_OFF,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_FAULTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_SUPPORTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);
                        
                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueU8);
                        
                        if(EDAL_STAT_OK(edalStatus))
                        {
                            edalStatus = FBE_EDAL_STATUS_OK;
                        }
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr->cmn_stat.elem_stat_code);
                    break;
                }
            }

            /* loop through all possible elem_stat_code (valid '0-7' and invalid '8') with ac_fail = TRUE */
            for ((stat_ptr->cmn_stat.elem_stat_code) = 0; (stat_ptr->cmn_stat.elem_stat_code) < 8 ; (stat_ptr->cmn_stat.elem_stat_code)++) 
            {
                /* for stat_ptr->ac_fail = TRUE */
                stat_ptr->ac_fail = TRUE; 

                /* Actual call of function */
                encl_status = fbe_eses_enclosure_ps_extract_status((fbe_eses_enclosure_t *)viperEnclPtr,
                                                group_id,
                                                (fbe_eses_ctrl_stat_elem_t *)((fbe_u8_t *)stat_pg_ptr + group_byte_offset));

                if(ENCL_STAT_OK(encl_status))
                {
                    encl_status = FBE_ENCLOSURE_STATUS_OK;
                }

                MUT_ASSERT_TRUE(encl_status == FBE_ENCLOSURE_STATUS_OK);

                switch(stat_ptr->cmn_stat.elem_stat_code)
                {

                    case SES_STAT_CODE_OK:
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_AC_FAIL,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);
                      
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_INSERTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_POWERED_OFF,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_FAULTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_SUPPORTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueU8);

                        if(EDAL_STAT_OK(edalStatus))
                        {
                            edalStatus = FBE_EDAL_STATUS_OK;
                        }
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr->cmn_stat.elem_stat_code);
                    
                    break;

                    case SES_STAT_CODE_CRITICAL:
                    case SES_STAT_CODE_NONCRITICAL:
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_AC_FAIL,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);
                        
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_INSERTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_POWERED_OFF,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_FAULTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_SUPPORTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);     

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueU8);

                        if(EDAL_STAT_OK(edalStatus))
                        {
                            edalStatus = FBE_EDAL_STATUS_OK;
                        }
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr->cmn_stat.elem_stat_code); 
                    break;

                    case SES_STAT_CODE_UNRECOV:
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_AC_FAIL,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);
                        
                      
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_INSERTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_POWERED_OFF,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_FAULTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_SUPPORTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueU8);

                        if(EDAL_STAT_OK(edalStatus))
                        {
                            edalStatus = FBE_EDAL_STATUS_OK;
                        }
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr->cmn_stat.elem_stat_code); 
                    break;

                    case SES_STAT_CODE_NOT_INSTALLED:
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_AC_FAIL,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);
                      
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_INSERTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_POWERED_OFF,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_FAULTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_SUPPORTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueU8);

                        if(EDAL_STAT_OK(edalStatus))
                        {
                            edalStatus = FBE_EDAL_STATUS_OK;
                        }
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr->cmn_stat.elem_stat_code); 
                    break;

                    case SES_STAT_CODE_UNAVAILABLE:
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_AC_FAIL,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);
                      
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_INSERTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_POWERED_OFF,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_FAULTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_SUPPORTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);     

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueU8);

                        if(EDAL_STAT_OK(edalStatus))
                        {
                            edalStatus = FBE_EDAL_STATUS_OK;
                        }
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr->cmn_stat.elem_stat_code); 
                    break;

                    case SES_STAT_CODE_UNKNOWN:
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_AC_FAIL,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);
                      
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_INSERTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_POWERED_OFF,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_FAULTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_SUPPORTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);
                        
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);
                    break;

                    case SES_STAT_CODE_UNSUPP: 
                        // for Invalid element status code, we need to check for 
                        // FBE_ENCL_COMP_STATUS_VALID attribute only
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);
                    break;
                       
                    default:
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_AC_FAIL,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);
                      
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_INSERTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_POWERED_OFF,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_FAULTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == TRUE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_PS_SUPPORTED,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueBool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(valueBool == FALSE);

                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                                    FBE_ENCL_POWER_SUPPLY,
                                                                    0,
                                                                    &valueU8);

                        if(EDAL_STAT_OK(edalStatus))
                        {
                            edalStatus = FBE_EDAL_STATUS_OK;
                        }
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr->cmn_stat.elem_stat_code);
                    break;
                }//end of switch(stat_ptr->cmn_stat.elem_stat_code)
            }//end of for ((stat_ptr->cmn_stat.elem_stat_code) 
        }//found element type other than SES_ELEM_TYPE_PS. So, come out of loop
    }// For .. Loop
    
    /* restore enclosure configuration */
    fbe_eses_enclosure_set_elem_group((fbe_eses_enclosure_t *)viperEnclPtr, elem_group_orig);
   
    mut_printf(MUT_LOG_MEDIUM, "%s : Testing %s End ",__FILE__, __FUNCTION__);
    return;
}

/******************************************
 * end of test_fbe_sas_viper_enclosure_ps_extract_status()
 ******************************************/

 /****************************************************************
 *  test_fbe_sas_viper_enclosure_connector_extract_status()
 ****************************************************************
 *  MUT tests for Function test_fbe_sas_viper_enclosure_connector_extract_status
 *  which parses the connectors status. 
 *   
 * @param   
 *                        
 *
 * @return 
 *
 * HISTORY:
 *  8/22/2008 - Created. DP
 *
 ****************************************************************/
void test_fbe_sas_viper_enclosure_connector_extract_status(void)
{
    fbe_sas_viper_enclosure_t viperEnclosure ,*viperEnclPtr ;
    fbe_enclosure_status_t encl_status;
    fbe_edal_status_t   edalStatus;
    fbe_u8_t group_id = 0;
    fbe_u8_t num_possible_elems = 0;
    fbe_u8_t elem_type = SES_ELEM_TYPE_INVALID;
    fbe_u16_t group_byte_offset = 0;
    fbe_u8_t first_elem_index = 0;
    fbe_u8_t elem_index = 0;
    fbe_u8_t conn_elem_index = 0;
    fbe_u8_t i = 0;
    fbe_u8_t stat_pg_ptr[1024];
    fbe_eses_elem_group_t *elem_group_orig = NULL;
    fbe_eses_elem_group_t *elem_group = NULL;
    ses_stat_elem_sas_conn_struct *stat_ptr_conn = NULL;
    fbe_u8_t connector_index = 0;
    fbe_bool_t valuebool;
    fbe_u8_t   valueU8;
    fbe_bool_t prevInserted;
    fbe_bool_t currInserted;

    mut_printf(MUT_LOG_MEDIUM, "%s : Testing %s Start ",__FILE__, __FUNCTION__);

    /*
    * Initialize Viper Enclosure
    */
  
    memset(&viperEnclosure, 0, sizeof(fbe_sas_viper_enclosure_t));
    viperEnclPtr = &viperEnclosure;

    fbe_sas_viper_init_component_block(viperEnclPtr, test_encl_comp_data);

    // call the FBE_ASSERT_AT_COMPILE_TIME macro 
   TEST_FBE_ASSERT_AT_COMPILE_TIME ;
    
    test_fbe_eses_setup_test_environ((fbe_eses_enclosure_t *)viperEnclPtr);  

    // set the life cycle set condition routine for enclosure test.
    fbe_base_enclosure_set_lifecycle_set_cond_routine((fbe_base_enclosure_t *)viperEnclPtr, 
                            (fbe_base_enclosure_lifecycle_set_cond_function_t)test_fbe_lifecycle_set_state);

    elem_group = fbe_eses_enclosure_get_elem_group_ptr((fbe_eses_enclosure_t *)viperEnclPtr);    

    for(group_id = 0; group_id < NUM_ACTUAL_ELEM_GROUPS; group_id ++ )
    {
        group_byte_offset = fbe_eses_elem_group_get_group_byte_offset(elem_group, group_id);

        if(group_byte_offset == 0)
        {
            // We have processed all the groups. Let's get out of the loop.
            break; 
        }

        elem_type = fbe_eses_elem_group_get_elem_type(elem_group, group_id);

        // Check whether the element type is valid or not. 
        if(elem_type == SES_ELEM_TYPE_INVALID)
        {
            return;
        }

        if(elem_type == SES_ELEM_TYPE_SAS_CONN)
        {
            num_possible_elems = fbe_eses_elem_group_get_num_possible_elems(elem_group, group_id);

            first_elem_index = fbe_eses_elem_group_get_first_elem_index(elem_group, group_id);

            for(i = 0; i< FBE_SAS_VIPER_ENCLOSURE_NUMBER_OF_CONNECTORS; i++)
            {
                edalStatus = fbe_base_enclosure_edal_setU8((fbe_base_enclosure_t *)viperEnclPtr,
                                     FBE_ENCL_COMP_ELEM_INDEX,  // Attribute
                                     FBE_ENCL_CONNECTOR,    // Component type
                                     i,  //Index of the component 
                                     (first_elem_index + i)); // The value to be set to
                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
            }

            for (i = 0; 
                 i < fbe_eses_elem_group_get_num_possible_elems(elem_group, group_id);
                 i ++)
            {
                stat_ptr_conn = (ses_stat_elem_sas_conn_struct *)(fbe_eses_get_ctrl_stat_elem_p((fbe_u8_t *)(fbe_eses_ctrl_stat_elem_t *)((fbe_u8_t *)stat_pg_ptr + group_byte_offset), i + 1));

                /*loop through all possible elem_stat_code (valid '1-3 and 5-7')*/
                for ((stat_ptr_conn->cmn_stat.elem_stat_code) = 1; (stat_ptr_conn->cmn_stat.elem_stat_code) < 8 ; (stat_ptr_conn->cmn_stat.elem_stat_code)++) 
                {
                    stat_ptr_conn->conn_physical_link = FBE_ESES_ENTIRE_CONNECTOR_PHYSICAL_LINK;

                    /*
                     * This element represents the connector as whole. 
                     * The status needs to be processed.
                     */
                    // Get the element index.
                    elem_index = fbe_eses_elem_group_get_first_elem_index(elem_group, group_id) + i;

                    if(fbe_eses_enclosure_elem_index_to_component_index((fbe_eses_enclosure_t *)viperEnclPtr,FBE_ENCL_CONNECTOR, elem_index,
                              &connector_index) == FBE_ENCLOSURE_STATUS_OK)
                    {
                        // get the element index for this connector. 
                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                          FBE_ENCL_COMP_ELEM_INDEX,
                                          FBE_ENCL_CONNECTOR,
                                          connector_index,
                                          &conn_elem_index);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                            
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                            FBE_ENCL_COMP_INSERTED,
                                                            FBE_ENCL_CONNECTOR,
                                                            connector_index,
                                                            &valuebool);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        prevInserted = valuebool;
                    }

                    /* Actual call of function */
                    encl_status = fbe_eses_enclosure_connector_extract_status((fbe_eses_enclosure_t *)viperEnclPtr,
                                              group_id,
                                              (fbe_eses_ctrl_stat_elem_t *)((fbe_u8_t *)stat_pg_ptr + group_byte_offset));

                    if(ENCL_STAT_OK(encl_status))
                    {
                        encl_status = FBE_ENCLOSURE_STATUS_OK;
                    }

                    /* we may see FBE_ENCLOSURE_STATUS_LIFECYCLE_FAILED as we can't really set conditions */
                    MUT_ASSERT_TRUE((encl_status == FBE_ENCLOSURE_STATUS_OK)||
                                    (encl_status == FBE_ENCLOSURE_STATUS_LIFECYCLE_FAILED));
                    if(stat_ptr_conn->cmn_stat.elem_stat_code!= 4)
                    {
                        if(stat_ptr_conn->conn_physical_link == FBE_ESES_ENTIRE_CONNECTOR_PHYSICAL_LINK)
                        {

                            switch(stat_ptr_conn->cmn_stat.elem_stat_code)
                            {
                                case SES_STAT_CODE_OK:
                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_CONNECTOR_DISABLED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == FALSE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_CONNECTOR_DEGRADED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == FALSE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valueU8);

                                    if(EDAL_STAT_OK(edalStatus))
                                    {
                                        edalStatus = FBE_EDAL_STATUS_OK;
                                    }
                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_INT_EQUAL(valueU8,stat_ptr_conn->cmn_stat.elem_stat_code);   

                                break;

                                case SES_STAT_CODE_CRITICAL:

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_CONNECTOR_DISABLED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_CONNECTOR_DEGRADED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == FALSE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valueU8);

                                    if(EDAL_STAT_OK(edalStatus))
                                    {
                                        edalStatus = FBE_EDAL_STATUS_OK;
                                    }
                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr_conn->cmn_stat.elem_stat_code);  
                    
                                break;

                                case SES_STAT_CODE_NOT_INSTALLED:

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == FALSE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_CONNECTOR_DISABLED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_CONNECTOR_DEGRADED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == FALSE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valueU8);

                                    if(EDAL_STAT_OK(edalStatus))
                                    {
                                        edalStatus = FBE_EDAL_STATUS_OK;
                                    }
                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr_conn->cmn_stat.elem_stat_code);          
                                break;

                                case SES_STAT_CODE_NONCRITICAL:

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_CONNECTOR_DISABLED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == FALSE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_CONNECTOR_DEGRADED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valueU8);

                                    if(EDAL_STAT_OK(edalStatus))
                                    {
                                        edalStatus = FBE_EDAL_STATUS_OK;
                                    }
                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr_conn->cmn_stat.elem_stat_code);  
                                break;

                                case SES_STAT_CODE_UNAVAILABLE:

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_CONNECTOR_DISABLED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == FALSE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_CONNECTOR_DEGRADED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == FALSE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valueU8);

                                    if(EDAL_STAT_OK(edalStatus))
                                    {
                                        edalStatus = FBE_EDAL_STATUS_OK;
                                    }
                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr_conn->cmn_stat.elem_stat_code);  
                                break;    
            
                                // comment out this case, as status is set to invalid for this status code.
                                // When status is invalid, we do not check any attributes other than 
                                // FBE_ENCL_COMP_STATUS_VALID
                                case SES_STAT_CODE_UNKNOWN: 
                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);
                                    currInserted = valuebool;

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_CONNECTOR_DISABLED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_CONNECTOR_DEGRADED,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);

                                    if((!prevInserted)&&(currInserted))
                                    {
                                            MUT_ASSERT_TRUE(valuebool == FALSE);
                                    }
                                    else
                                    {
                                            MUT_ASSERT_TRUE(valuebool == TRUE);
                                    }    
                                    

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valueU8);

                                    if(EDAL_STAT_OK(edalStatus))
                                    {
                                        edalStatus = FBE_EDAL_STATUS_OK;
                                    }
                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_INT_EQUAL(valueU8, stat_ptr_conn->cmn_stat.elem_stat_code);  
                                break;

                                case SES_STAT_CODE_UNSUPP:
                                case SES_STAT_CODE_UNRECOV:
                                default:                        
                                    // for Invalid element status code, we need to check for 
                                    // FBE_ENCL_COMP_STATUS_VALID attribute only
                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_CONNECTOR,
                                                                connector_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == FALSE);
                                break;
                            }
                        }// End of - if(stat_ptr->conn_physical_link == FBE_ESES_ENTIRE_CONNECTOR_PHYSICAL_LINK)
                    }
                }
            }
        }
    }

    /* restore enclosure configuration */
    fbe_eses_enclosure_set_elem_group((fbe_eses_enclosure_t *)viperEnclPtr, elem_group_orig);

    fbe_base_enclosure_set_lifecycle_set_cond_routine((fbe_base_enclosure_t *)viperEnclPtr, 
                            (fbe_base_enclosure_lifecycle_set_cond_function_t)fbe_lifecycle_set_cond);

    
    mut_printf(MUT_LOG_MEDIUM, "%s : Testing %s End ",__FILE__, __FUNCTION__);
    return;
}
/*******************************************************
 * end of test_fbe_sas_viper_enclosure_connector_extract_status()
 *******************************************************/

/***************************************************************
 *  test_fbe_sas_viper_enclosure_array_dev_slot_extract_status()
 ****************************************************************
 *  MUT test for Function fbe_sas_viper_enclosure_array_dev_slot_extract_status
 *  which parses the array device slot status to fill in the drive info. 
 *
 * @param
 *
 *
 * @return 
 *
 * HISTORY:
 *  8/22/2008 - Created. DP
 *
 ****************************************************************/
void test_fbe_sas_viper_enclosure_array_dev_slot_extract_status(void)
{
    fbe_sas_viper_enclosure_t viperEnclosure,*viperEnclPtr;
    fbe_edal_status_t   edalStatus;
    fbe_enclosure_status_t   encl_status;
    fbe_u8_t group_id = 0;
    fbe_u8_t num_possible_elems = 0;
    fbe_u8_t elem_type = SES_ELEM_TYPE_INVALID;
    fbe_u8_t elem = 0;
    fbe_u8_t elem_index = 0;
    fbe_u8_t phyIndex = 0;
    fbe_u8_t slot_index = 0;
    fbe_u16_t group_byte_offset = 0;
    fbe_u8_t stat_pg_ptr[1024];
    fbe_eses_elem_group_t *elem_group_orig = NULL;
    fbe_eses_elem_group_t *elem_group = NULL;
    ses_stat_elem_array_dev_slot_struct * stat_dev_slot_ptr = NULL;
    void * specific_component_data_ptr = NULL;
    fbe_bool_t valuebool;
    fbe_u8_t    valueU8;    

    mut_printf(MUT_LOG_MEDIUM, "%s : Testing %s Start ",__FILE__, __FUNCTION__);

    /* Initialize Viper Enclosure */
    memset(&viperEnclosure, 0, sizeof(fbe_sas_viper_enclosure_t));
    viperEnclPtr = &viperEnclosure;

    fbe_sas_viper_init_component_block(viperEnclPtr, test_encl_comp_data);

    // call the FBE_ASSERT_AT_COMPILE_TIME macro    
   TEST_FBE_ASSERT_AT_COMPILE_TIME ;
  
    test_fbe_eses_setup_test_environ((fbe_eses_enclosure_t *)viperEnclPtr);    
    
    /* Get the elem_group so that we will know the configuration while 
     * processing the status page. 
     */
    elem_group = fbe_eses_enclosure_get_elem_group_ptr((fbe_eses_enclosure_t *)viperEnclPtr);

    for(group_id = 0; group_id < NUM_ACTUAL_ELEM_GROUPS; group_id ++ )
    {
        group_byte_offset = fbe_eses_elem_group_get_group_byte_offset(elem_group, group_id);

        if(group_byte_offset == 0)
        {
            // We have processed all the groups. Let's get out of the loop.
            break; 
        }

        elem_type = fbe_eses_elem_group_get_elem_type(elem_group, group_id);

        if(elem_type == SES_ELEM_TYPE_ARRAY_DEV_SLOT)
        {
            num_possible_elems = fbe_eses_elem_group_get_num_possible_elems(elem_group, group_id);

            /* set drive element and map it with phy id */
            encl_status = fbe_eses_enclosure_handle_unsupported_additional_status_page((fbe_eses_enclosure_t *)viperEnclPtr);

            /* if SES_SUBENCL_ID of connector, drive slots and expander phy is not eaqual to SES_SUBENCL_ID_PRIMARY then
             * function will return FBE_STATUS_GENERIC_FAILURE. So, to make sure that element index for all set properly
             * we are checking status here returned from function. It can be considered as negative test*/
            MUT_ASSERT_TRUE(encl_status == FBE_ENCLOSURE_STATUS_UNSUPPORTED_PAGE_HANDLED);            

            for (elem = 0; 
                     elem < fbe_eses_elem_group_get_num_possible_elems(elem_group, group_id);
                     elem ++)
            {

                stat_dev_slot_ptr = (ses_stat_elem_array_dev_slot_struct *)(fbe_eses_get_ctrl_stat_elem_p(((fbe_u8_t *)stat_pg_ptr + group_byte_offset),(elem + 1)));

                /*loop through all possible elem_stat_code (valid '1-2','4-5' and invalid '6') */
                /* Below test is for valid elem_stat_codes*/
                for ((stat_dev_slot_ptr->cmn_stat.elem_stat_code) = 1; stat_dev_slot_ptr->cmn_stat.elem_stat_code < 6 ; stat_dev_slot_ptr->cmn_stat.elem_stat_code++) 
                {

                    if(stat_dev_slot_ptr->cmn_stat.elem_stat_code == 3)
                    {
                        continue;
                    }

                    /* Actual call of function */
                    encl_status = fbe_eses_enclosure_array_dev_slot_extract_status((fbe_eses_enclosure_t *)viperEnclPtr,
                                              group_id,
                                              (fbe_eses_ctrl_stat_elem_t *)((fbe_u8_t *)stat_pg_ptr + group_byte_offset));                                          

                    if(ENCL_STAT_OK(encl_status))
                    {
                        encl_status = FBE_ENCLOSURE_STATUS_OK;
                    }

                    MUT_ASSERT_TRUE(encl_status == FBE_ENCLOSURE_STATUS_OK);

                    elem_index = fbe_eses_elem_group_get_first_elem_index(elem_group, group_id) + elem;

                    // Get the drive slot number through the element index. 
                    if(fbe_eses_enclosure_elem_index_to_component_index((fbe_eses_enclosure_t *)viperEnclPtr,
                                                      FBE_ENCL_DRIVE_SLOT,elem_index, &slot_index) == FBE_ENCLOSURE_STATUS_OK)
                    {
                        /*Check for phy index */
                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                              FBE_ENCL_DRIVE_PHY_INDEX,
                                              FBE_ENCL_DRIVE_SLOT,
                                              slot_index,
                                              &phyIndex);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(phyIndex == (fbe_sas_viper_enclosure_drive_slot_to_phy_id11[slot_index]-1));

                        switch(stat_dev_slot_ptr->cmn_stat.elem_stat_code)
                        {
                            case SES_STAT_CODE_OK:
                            case SES_STAT_CODE_CRITICAL:
                            case SES_STAT_CODE_UNAVAILABLE:
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_INSERTED,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool==TRUE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_FAULTED,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool==FALSE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool==TRUE);

                                edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valueU8);

                                if(EDAL_STAT_OK(edalStatus))
                                {
                                    edalStatus = FBE_EDAL_STATUS_OK;
                                }
                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_INT_EQUAL(valueU8,stat_dev_slot_ptr->cmn_stat.elem_stat_code);       
                            break;
                            case SES_STAT_CODE_UNRECOV:
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_INSERTED,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool==TRUE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_FAULTED,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool==TRUE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool==TRUE);

                                edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valueU8);

                                if(EDAL_STAT_OK(edalStatus))
                                {
                                    edalStatus = FBE_EDAL_STATUS_OK;
                                }
                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_INT_EQUAL(valueU8,stat_dev_slot_ptr->cmn_stat.elem_stat_code);
                            break;

                            case SES_STAT_CODE_NOT_INSTALLED:                     
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_INSERTED,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool==FALSE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_FAULTED,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool==FALSE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool==TRUE);

                                edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valueU8);

                                if(EDAL_STAT_OK(edalStatus))
                                {
                                    edalStatus = FBE_EDAL_STATUS_OK;
                                }
                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_INT_EQUAL(valueU8,stat_dev_slot_ptr->cmn_stat.elem_stat_code);
                            break;

                            case SES_STAT_CODE_UNSUPP:
                            case SES_STAT_CODE_NONCRITICAL:
                            case SES_STAT_CODE_UNKNOWN:
                                // for Invalid element status code, we need to check for 
                                // FBE_ENCL_COMP_STATUS_VALID attribute only
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool==FALSE);

                            break;

                            default:                     
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_INSERTED,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool==FALSE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_FAULTED,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool==TRUE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_STATUS_VALID,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool==FALSE);

                                edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_COMP_ADDL_STATUS,
                                                    FBE_ENCL_DRIVE_SLOT,
                                                    slot_index,
                                                    &valueU8);

                                if(EDAL_STAT_OK(edalStatus))
                                {
                                    edalStatus = FBE_EDAL_STATUS_OK;
                                }
                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_INT_EQUAL(valueU8,stat_dev_slot_ptr->cmn_stat.elem_stat_code);                       
                            break;
                        }
                    }
                }
            }
        }//found element type other than SES_ELEM_TYPE_ARRAY_DEV_SLOT So, come out of loop
    }

    /* restore enclosure configuration */
    fbe_eses_enclosure_set_elem_group((fbe_eses_enclosure_t *)viperEnclPtr, elem_group_orig);

    mut_printf(MUT_LOG_MEDIUM, "%s : Testing %s End ",__FILE__, __FUNCTION__);
    return;
}
/***************************************************************
 * end test_fbe_sas_viper_enclosure_array_dev_slot_extract_status()
 ***************************************************************/

/***************************************************************
 *  test_fbe_sas_viper_enclosure_exp_phy_extract_status()
 ****************************************************************
 *  MUT test for Function test_fbe_sas_viper_enclosure_exp_phy_extract_status
 *  which parses parses the expander phy status to fill in the phy info. 
 *   
 * @param   
 *                        
 *
 * @return 
 *
 * HISTORY:
 *  8/22/2008 - Created. DP
 *
 ****************************************************************/
void test_fbe_sas_viper_enclosure_exp_phy_extract_status(void)
{
    fbe_sas_viper_enclosure_t  viperEnclosure,*viperEnclPtr;
    fbe_edal_status_t   edalStatus;
    fbe_enclosure_status_t   encl_status;
    fbe_u8_t group_id = 0;
    fbe_u8_t num_possible_elems = 0;
    fbe_u8_t elem_type = SES_ELEM_TYPE_INVALID;
    fbe_u8_t elem = 0;
    fbe_u8_t elem_index = 0;
    fbe_u8_t phy_index = 0;
    fbe_u8_t slot_index = 0;
    fbe_u8_t first_elem_index = 0;
    fbe_u8_t expander_elem_index;
    fbe_u8_t phy_id;
    fbe_bool_t linkReady;
    fbe_bool_t phyReady;
    fbe_bool_t spinupEnabled;
    fbe_u16_t group_byte_offset = 0;
    fbe_u8_t i = 0;  
    fbe_u8_t stat_pg_ptr[1024];
    fbe_eses_elem_group_t *elem_group_orig = NULL;
    fbe_eses_elem_group_t *elem_group = NULL;
    ses_stat_elem_exp_phy_struct * stat_exp_ptr = NULL;
    void * specific_component_data_ptr = NULL;
    fbe_bool_t valuebool;
    fbe_u8_t   valueU8;


   mut_printf(MUT_LOG_MEDIUM, "%s : Testing %s Start ",__FILE__, __FUNCTION__);

   /* Initialize Viper Enclosure */
    memset(&viperEnclosure, 0, sizeof(fbe_sas_viper_enclosure_t));
    viperEnclPtr = &viperEnclosure;

    /*init component blocks*/
    fbe_sas_viper_init_component_block(viperEnclPtr, test_encl_comp_data);

    // call the FBE_ASSERT_AT_COMPILE_TIME macro 
   TEST_FBE_ASSERT_AT_COMPILE_TIME ;

    test_fbe_eses_setup_test_environ((fbe_eses_enclosure_t *)viperEnclPtr);

    /* Get the elem_group so that we will know the configuration while 
     * processing the status page. 
     */
    elem_group = fbe_eses_enclosure_get_elem_group_ptr((fbe_eses_enclosure_t *)viperEnclPtr);
    
    for(group_id = 0; group_id < NUM_ACTUAL_ELEM_GROUPS; group_id ++ )
    {
        group_byte_offset = fbe_eses_elem_group_get_group_byte_offset(elem_group, group_id);

        if(group_byte_offset == 0)
        {
            // We have processed all the groups. Let's get out of the loop.
            break; 
        }

        elem_type = fbe_eses_elem_group_get_elem_type(elem_group, group_id);

        if(elem_type == SES_ELEM_TYPE_EXP_PHY)
        {
            first_elem_index = fbe_eses_elem_group_get_first_elem_index(elem_group, group_id);

            encl_status = fbe_eses_enclosure_handle_unsupported_additional_status_page((fbe_eses_enclosure_t *)viperEnclPtr);

            MUT_ASSERT_TRUE(encl_status == FBE_ENCLOSURE_STATUS_UNSUPPORTED_PAGE_HANDLED);

            // Hardcode the expander element index and phy id for phy info.   
            for(i = 0; i< FBE_SAS_VIPER_ENCLOSURE_NUMBER_OF_EXPANDER_PHYS; i++)
            {

                stat_exp_ptr = (ses_stat_elem_exp_phy_struct *)(fbe_eses_get_ctrl_stat_elem_p((fbe_u8_t *)stat_pg_ptr + group_byte_offset,(i + 1)));

                edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                        FBE_ENCL_EXP_PHY_EXPANDER_ELEM_INDEX,  // Attribute
                                        FBE_ENCL_EXPANDER_PHY,    // Component type
                                        i,
                                        &expander_elem_index); // The value to be set to

                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                stat_exp_ptr->exp_index = expander_elem_index;

                edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                        FBE_ENCL_EXP_PHY_ID,  // Attribute
                                        FBE_ENCL_EXPANDER_PHY,    // Component type
                                        i,
                                        &phy_id); // The value to be set to
                                        
                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                MUT_ASSERT_TRUE(phy_id == (fbe_sas_viper_enclosure_phy_index_to_phy_id11[i]));
                stat_exp_ptr->phy_id = phy_id;

                /*common for all elements*/
                stat_exp_ptr->link_rdy = FALSE;
                stat_exp_ptr->phy_rdy = FALSE;
                stat_exp_ptr->spinup_enabled = FALSE;
            }

            for (elem = 0; 
                     elem < fbe_eses_elem_group_get_num_possible_elems(elem_group, group_id);
                     elem ++)
            {

                stat_exp_ptr = (ses_stat_elem_exp_phy_struct *)(fbe_eses_get_ctrl_stat_elem_p((fbe_u8_t *)stat_pg_ptr + group_byte_offset,(elem + 1)));

                /*loop through all possible elem_stat_code (valid '1-3','4-5' and invalid '6') */
                for ((stat_exp_ptr->cmn_stat.elem_stat_code) = 1; stat_exp_ptr->cmn_stat.elem_stat_code < 8 ; stat_exp_ptr->cmn_stat.elem_stat_code++) 
                {

                    /* Actual call of function */
                    encl_status = fbe_eses_enclosure_exp_phy_extract_status((fbe_eses_enclosure_t *)viperEnclPtr,
                                              group_id,
                                              (fbe_eses_ctrl_stat_elem_t *)((fbe_u8_t *)stat_pg_ptr + group_byte_offset));

                    if(ENCL_STAT_OK(encl_status))
                    {
                        encl_status = FBE_ENCLOSURE_STATUS_OK;
                    }

                    MUT_ASSERT_TRUE(encl_status == FBE_ENCLOSURE_STATUS_OK);

                    elem_index = fbe_eses_elem_group_get_first_elem_index(elem_group, group_id) + elem;

                    // Get the drive slot number through the element index. 
                    if(fbe_eses_enclosure_exp_elem_index_phy_id_to_phy_index((fbe_eses_enclosure_t *)viperEnclPtr, 
                                                      stat_exp_ptr->exp_index, stat_exp_ptr->phy_id, &phy_index) == FBE_ENCLOSURE_STATUS_OK)
                    {
                        // Set the element index for this phy. 
                        edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                  FBE_ENCL_COMP_ELEM_INDEX,
                                                  FBE_ENCL_EXPANDER_PHY,
                                                  phy_index,
                                                  &elem_index);
                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);

                        if(stat_exp_ptr->cmn_stat.elem_stat_code != 6)
                        {

                            // Set if the phy is enabled for this phy. 
                            switch(stat_exp_ptr->cmn_stat.elem_stat_code)
                            {

                                case SES_STAT_CODE_OK:
                                case SES_STAT_CODE_NONCRITICAL:
                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);  
 
                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_EXP_PHY_DISABLED,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == FALSE);

                                    if(fbe_eses_enclosure_phy_index_to_drive_slot_index((fbe_eses_enclosure_t *)viperEnclPtr,
                                                         phy_index, &slot_index) == FBE_STATUS_OK)
                                    {
                                        // This phy is attached to a drive slot. Set the drive bypassed to TRUE.
                                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                            FBE_ENCL_DRIVE_BYPASSED,
                                                            FBE_ENCL_DRIVE_SLOT,
                                                            slot_index,
                                                            &valuebool);

                                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                        MUT_ASSERT_TRUE(valuebool == FALSE);
                                    }

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valueU8);

                                    if(EDAL_STAT_OK(edalStatus))
                                    {
                                        edalStatus = FBE_EDAL_STATUS_OK;
                                    }
                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_INT_EQUAL(valueU8,stat_exp_ptr->cmn_stat.elem_stat_code);                
                                break;

                                case SES_STAT_CODE_CRITICAL:                    
                                case SES_STAT_CODE_UNRECOV:                    
                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);  
 
                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_EXP_PHY_DISABLED,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    if(fbe_eses_enclosure_phy_index_to_drive_slot_index((fbe_eses_enclosure_t *)viperEnclPtr,
                                                         phy_index, &slot_index) == FBE_STATUS_OK)
                                    {
                                        // This phy is attached to a drive slot. Set the drive bypassed to TRUE.
                                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                            FBE_ENCL_DRIVE_BYPASSED,
                                                            FBE_ENCL_DRIVE_SLOT,
                                                            slot_index,
                                                            &valuebool);

                                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                        MUT_ASSERT_TRUE(valuebool == TRUE);
                                    }

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valueU8);

                                    if(EDAL_STAT_OK(edalStatus))
                                    {
                                        edalStatus = FBE_EDAL_STATUS_OK;
                                    }
                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_INT_EQUAL(valueU8, stat_exp_ptr->cmn_stat.elem_stat_code);
                                break;

                                case SES_STAT_CODE_NOT_INSTALLED:
                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == FALSE);  
 
                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_EXP_PHY_DISABLED,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    if(fbe_eses_enclosure_phy_index_to_drive_slot_index((fbe_eses_enclosure_t *)viperEnclPtr,
                                                         phy_index, &slot_index) == FBE_STATUS_OK)
                                    {
                                        // This phy is attached to a drive slot. Set the drive bypassed to TRUE.
                                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                            FBE_ENCL_DRIVE_BYPASSED,
                                                            FBE_ENCL_DRIVE_SLOT,
                                                            slot_index,
                                                            &valuebool);

                                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                        MUT_ASSERT_TRUE(valuebool == TRUE);
                                    }

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valueU8);

                                    if(EDAL_STAT_OK(edalStatus))
                                    {
                                        edalStatus = FBE_EDAL_STATUS_OK;
                                    }
                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_INT_EQUAL(valueU8,stat_exp_ptr->cmn_stat.elem_stat_code);
                                break;

                                case SES_STAT_CODE_UNAVAILABLE:
                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);  
 
                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_EXP_PHY_DISABLED,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    if(fbe_eses_enclosure_phy_index_to_drive_slot_index((fbe_eses_enclosure_t *)viperEnclPtr,
                                                         phy_index, &slot_index) == FBE_STATUS_OK)
                                    {
                                        // This phy is attached to a drive slot. Set the drive bypassed to TRUE.
                                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                            FBE_ENCL_DRIVE_BYPASSED,
                                                            FBE_ENCL_DRIVE_SLOT,
                                                            slot_index,
                                                            &valuebool);

                                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                        MUT_ASSERT_TRUE(valuebool == TRUE);
                                    }

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valueU8);

                                    if(EDAL_STAT_OK(edalStatus))
                                    {
                                        edalStatus = FBE_EDAL_STATUS_OK;
                                    }
                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_INT_EQUAL(valueU8,stat_exp_ptr->cmn_stat.elem_stat_code);
                                break;

                                case SES_STAT_CODE_UNSUPP: 
                                case SES_STAT_CODE_UNKNOWN:
                                    // for Invalid element status code, we need to check for 
                                    // FBE_ENCL_COMP_STATUS_VALID attribute only
                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == FALSE);
                                break;
                                default:
                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == FALSE);  

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_EXP_PHY_DISABLED,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == TRUE);

                                    if(fbe_eses_enclosure_phy_index_to_drive_slot_index((fbe_eses_enclosure_t *)viperEnclPtr,
                                                         phy_index, &slot_index) == FBE_STATUS_OK)
                                    {
                                        // This phy is attached to a drive slot. Set the drive bypassed to TRUE.
                                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                            FBE_ENCL_DRIVE_BYPASSED,
                                                            FBE_ENCL_DRIVE_SLOT,
                                                            slot_index,
                                                            &valuebool);

                                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                        MUT_ASSERT_TRUE(valuebool == TRUE);
                                    }

                                    edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valuebool);

                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_TRUE(valuebool == FALSE);

                                    edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_EXPANDER_PHY,
                                                                phy_index,
                                                                &valueU8);

                                    if(EDAL_STAT_OK(edalStatus))
                                    {
                                        edalStatus = FBE_EDAL_STATUS_OK;
                                    }
                                    MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                    MUT_ASSERT_INT_EQUAL(valueU8,stat_exp_ptr->cmn_stat.elem_stat_code);
                                break;
                            }
                        }
                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                    FBE_ENCL_EXP_PHY_LINK_READY,
                                                    FBE_ENCL_EXPANDER_PHY,
                                                    phy_index,
                                                    &linkReady);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(linkReady == stat_exp_ptr->link_rdy);

                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                        FBE_ENCL_EXP_PHY_READY,
                                                        FBE_ENCL_EXPANDER_PHY,
                                                        phy_index,
                                                        &phyReady);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(phyReady == stat_exp_ptr->phy_rdy);


                        edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                        FBE_ENCL_EXP_PHY_SPINUP_ENABLED,
                                                        FBE_ENCL_EXPANDER_PHY,
                                                        phy_index,
                                                        &spinupEnabled);

                        MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                        MUT_ASSERT_TRUE(spinupEnabled == stat_exp_ptr->spinup_enabled);
                    }
                }
            }
        }//found element type other than SES_ELEM_TYPE_SAS_EXP So, come out of loop
    }

    /* restore enclosure configuration */
    fbe_eses_enclosure_set_elem_group((fbe_eses_enclosure_t *)viperEnclPtr, elem_group_orig);
  
    mut_printf(MUT_LOG_MEDIUM, "%s : Testing %s End ",__FILE__, __FUNCTION__);
    return;
}
/***************************************************************
 * end test_fbe_sas_viper_enclosure_exp_phy_extract_status()
 ***************************************************************/
/***************************************************************
 *  test_fbe_sas_viper_enclosure_cooling_extract_status()
 ****************************************************************
 *  MUT test for Function test_fbe_sas_viper_enclosure_cooling_extract_status
 *  which parses the cooling components status.
 *
 * @param
 *
 *
 * @return 
 *
 * HISTORY:
 *  10/09/2008 - Created. DP
 *
 ****************************************************************/
void test_fbe_sas_viper_enclosure_cooling_extract_status(void)
{
    fbe_sas_viper_enclosure_t  viperEnclosure,*viperEnclPtr;
    fbe_edal_status_t   edalStatus;
    fbe_enclosure_status_t   encl_status;
    fbe_u8_t group_id = 0;
    fbe_u8_t num_possible_elems = 0;
    fbe_u8_t elem_type = SES_ELEM_TYPE_INVALID;
    fbe_u8_t elem = 0;
    fbe_u8_t elem_index = 0;    
    fbe_u8_t cooling_index;
    fbe_u8_t coolElemIndex = 0;
    fbe_u8_t i = 0;
    fbe_u16_t group_byte_offset = 0;
    fbe_u8_t stat_pg_ptr[1024];
    fbe_eses_elem_group_t *elem_group_orig = NULL;
    fbe_eses_elem_group_t *elem_group = NULL;    
    ses_stat_elem_cooling_struct * stat_cooling_ptr = NULL;
    fbe_bool_t valuebool;
    fbe_u8_t    valueU8;

    mut_printf(MUT_LOG_MEDIUM, "%s : Testing %s Start ",__FILE__, __FUNCTION__);

    /* Initialize Viper Enclosure */
    memset(&viperEnclosure, 0, sizeof(fbe_sas_viper_enclosure_t));
    viperEnclPtr = &viperEnclosure;
    
    /*init component blocks*/
    fbe_sas_viper_init_component_block(viperEnclPtr, test_encl_comp_data);

    // call the FBE_ASSERT_AT_COMPILE_TIME macro    
    TEST_FBE_ASSERT_AT_COMPILE_TIME ;
    
    test_fbe_eses_setup_test_environ((fbe_eses_enclosure_t *)viperEnclPtr);

    /* Get the elem_group so that we will know the configuration while 
     * processing the status page. 
     */
    elem_group = fbe_eses_enclosure_get_elem_group_ptr((fbe_eses_enclosure_t *)viperEnclPtr);
    
    for(group_id = 0; group_id < NUM_ACTUAL_ELEM_GROUPS; group_id ++ )
    {
        group_byte_offset = fbe_eses_elem_group_get_group_byte_offset(elem_group, group_id);
    
        if(group_byte_offset == 0)
        {
            // We have processed all the groups. Let's get out of the loop.
            break; 
        }

        elem_type = fbe_eses_elem_group_get_elem_type(elem_group, group_id);
     
        if(elem_type == SES_ELEM_TYPE_COOLING)
        {
            // Element 0 is for overall cooling element.
            for (elem = 0; 
                     elem <= fbe_eses_elem_group_get_num_possible_elems(elem_group, group_id);
                     elem ++)
            {
                stat_cooling_ptr = (ses_stat_elem_cooling_struct *)(fbe_eses_get_ctrl_stat_elem_p((fbe_u8_t *)stat_pg_ptr + group_byte_offset, elem));

                /*loop through all possible elem_stat_code (valid '1-3','5-6' and invalid '4') */
                for ((stat_cooling_ptr->cmn_stat.elem_stat_code) = 1; stat_cooling_ptr->cmn_stat.elem_stat_code < 7 ; stat_cooling_ptr->cmn_stat.elem_stat_code++) 
                {

                    /* Actual call of function */
                    encl_status = fbe_eses_enclosure_cooling_extract_status((fbe_eses_enclosure_t *)viperEnclPtr,
                                              group_id,
                                              (fbe_eses_ctrl_stat_elem_t *)((fbe_u8_t *)stat_pg_ptr + group_byte_offset));


                    if(ENCL_STAT_OK(encl_status))
                    {
                        encl_status = FBE_ENCLOSURE_STATUS_OK;
                    }
                    MUT_ASSERT_TRUE(encl_status == FBE_ENCLOSURE_STATUS_OK);


                    /* Get the component index for this element. */
                    encl_status = fbe_eses_enclosure_get_comp_index((fbe_eses_enclosure_t *)viperEnclPtr,
                                                        group_id,
                                                        elem,
                                                        &cooling_index);

                    MUT_ASSERT_TRUE(encl_status == FBE_ENCLOSURE_STATUS_OK);

                    //case 4 is not handled yet in original function 
                    if(stat_cooling_ptr->cmn_stat.elem_stat_code != 4)
                    {
                        switch(stat_cooling_ptr->cmn_stat.elem_stat_code)
                        {

                            case SES_STAT_CODE_OK:
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);                                    

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_FAULTED,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool ==FALSE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_POWERED_OFF,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool ==FALSE);             

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);

                                edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valueU8);

                                if(EDAL_STAT_OK(edalStatus))
                                {
                                    edalStatus = FBE_EDAL_STATUS_OK;
                                }
                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_INT_EQUAL(valueU8, stat_cooling_ptr->cmn_stat.elem_stat_code);               
                            
                            break;     

                            case SES_STAT_CODE_CRITICAL:
                            case SES_STAT_CODE_NONCRITICAL:
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);                                    

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_FAULTED,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool ==TRUE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_POWERED_OFF,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool ==FALSE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);

                                edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valueU8);

                                if(EDAL_STAT_OK(edalStatus))
                                {
                                    edalStatus = FBE_EDAL_STATUS_OK;
                                }
                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_INT_EQUAL(valueU8, stat_cooling_ptr->cmn_stat.elem_stat_code);
                            break;

                            case SES_STAT_CODE_NOT_INSTALLED:
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == FALSE);                                    

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_FAULTED,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool ==FALSE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_POWERED_OFF,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool ==TRUE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);

                                edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valueU8);

                                if(EDAL_STAT_OK(edalStatus))
                                {
                                    edalStatus = FBE_EDAL_STATUS_OK;
                                }
                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_INT_EQUAL(valueU8, stat_cooling_ptr->cmn_stat.elem_stat_code);
                            break;
            
                            case SES_STAT_CODE_UNKNOWN:
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_INSERTED,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);                                    

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_FAULTED,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_POWERED_OFF,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool ==TRUE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);

                                edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_ADDL_STATUS,
                                                                FBE_ENCL_COOLING_COMPONENT, 
                                                                cooling_index,
                                                                &valueU8);

                                if(EDAL_STAT_OK(edalStatus))
                                {
                                    edalStatus = FBE_EDAL_STATUS_OK;
                                }

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_INT_EQUAL(valueU8, stat_cooling_ptr->cmn_stat.elem_stat_code);               
                            break;
            
                            case SES_STAT_CODE_UNSUPP:
                            case SES_STAT_CODE_UNRECOV:
                            case SES_STAT_CODE_UNAVAILABLE:
                            default:
                                // for Invalid element status code, we need to check for 
                                // FBE_ENCL_COMP_STATUS_VALID attribute only
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                                                FBE_ENCL_COMP_STATUS_VALID,
                                                                FBE_ENCL_COOLING_COMPONENT,
                                                                cooling_index,
                                                                &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == FALSE);
                            break;
                        }//End of switch()
                    }//End of if(stat_cooling_ptr->cmn_stat.elem_stat_code != 4)
                }//End of for loop for element stat code
            }//Come out of loop as we reach max no. of elements
        }//found element type other than SES_ELEM_TYPE_COOLING So, come out of loop
    }//Come out of loop as we reach max no. of group id.

    /* restore enclosure configuration */
    fbe_eses_enclosure_set_elem_group((fbe_eses_enclosure_t *)viperEnclPtr, elem_group_orig);

    mut_printf(MUT_LOG_MEDIUM, "%s : Testing %s End ",__FILE__, __FUNCTION__);
    return;
}
/***************************************************************
 * end test_fbe_sas_viper_enclosure_cooling_extract_status()
 ***************************************************************/

/***************************************************************
 *  test_fbe_sas_viper_enclosure_temp_sensor_extract_status()
 ****************************************************************
 *  MUT test for Function test_fbe_sas_viper_enclosure_temp_sensor_extract_status
 *  which parses the temp sensor components status.
 *
 * @param
 *
 *
 * @return 
 *
 * HISTORY:
 *  10/09/2008 - Created. DP
 *
 ****************************************************************/
void test_fbe_sas_viper_enclosure_temp_sensor_extract_status(void)
{
    fbe_sas_viper_enclosure_t  viperEnclosure,*viperEnclPtr;
    fbe_edal_status_t   edalStatus;
    fbe_enclosure_status_t   encl_status;
    fbe_u8_t group_id = 0;
    fbe_u8_t num_possible_elems = 0;
    fbe_u8_t elem_type = SES_ELEM_TYPE_INVALID;
    fbe_u8_t elem = 0;
    fbe_u8_t elem_index = 0;
    fbe_u8_t temp_sensor_index;  // = 0;
    fbe_u8_t i = 0;
    fbe_u16_t group_byte_offset = 0;
    fbe_bool_t ts_ot_warning = FALSE;
    fbe_bool_t ts_ot_failure = FALSE;
    fbe_u8_t stat_pg_ptr[1024];
    fbe_eses_elem_group_t *elem_group_orig = NULL;
    fbe_eses_elem_group_t *elem_group = NULL;
    ses_stat_elem_temp_sensor_struct    *stat_temp_sens_ptr = NULL;
    ses_stat_elem_temp_sensor_struct    *stat_temp_sens_overall_ptr = NULL;
    fbe_bool_t valuebool;
    fbe_u8_t    valueU8;    

    mut_printf(MUT_LOG_MEDIUM, "%s : Testing %s Start ",__FILE__, __FUNCTION__);

    /* Initialize Viper Enclosure */
    memset(&viperEnclosure, 0, sizeof(fbe_sas_viper_enclosure_t));
    viperEnclPtr = &viperEnclosure;
    
    /*init component blocks*/
    fbe_sas_viper_init_component_block(viperEnclPtr, test_encl_comp_data);

    // call the FBE_ASSERT_AT_COMPILE_TIME macro 
    TEST_FBE_ASSERT_AT_COMPILE_TIME ;

    test_fbe_eses_setup_test_environ((fbe_eses_enclosure_t *)viperEnclPtr);

    /* Get the elem_group so that we will know the configuration while 
     * processing the status page. 
     */
    elem_group = fbe_eses_enclosure_get_elem_group_ptr((fbe_eses_enclosure_t *)viperEnclPtr);

    for(group_id = 0; group_id < NUM_ACTUAL_ELEM_GROUPS; group_id ++ )
    {
        group_byte_offset = fbe_eses_elem_group_get_group_byte_offset(elem_group, group_id);

        if(group_byte_offset == 0)
        {
            // We have processed all the groups. Let's get out of the loop.
            break; 
        }

        elem_type = fbe_eses_elem_group_get_elem_type(elem_group, group_id);

        if(elem_type == SES_ELEM_TYPE_TEMP_SENSOR)
        {
            /* Element 0 is for overall cooling element. 
             * We take it out for now because the hack put in 
             * function fbe_eses_enclosure_temp_sensor_extract_status
             * for the overall cooling elementwhile waiting for the terminator support.
             */
            for (elem = 1; 
                     elem <= fbe_eses_elem_group_get_num_possible_elems(elem_group, group_id);
                     elem ++)
            {
                stat_temp_sens_ptr = (ses_stat_elem_temp_sensor_struct *)(fbe_eses_get_ctrl_stat_elem_p((fbe_u8_t *)stat_pg_ptr + group_byte_offset, elem));

                /*loop through all possible elem_stat_code (valid '1-3','4-5' and invalid '6') */
                for ((stat_temp_sens_ptr->cmn_stat.elem_stat_code) = 1; stat_temp_sens_ptr->cmn_stat.elem_stat_code < 7 ; stat_temp_sens_ptr->cmn_stat.elem_stat_code++) 
                {
                    stat_temp_sens_overall_ptr = (ses_stat_elem_temp_sensor_struct *)(fbe_eses_get_ctrl_stat_elem_p((fbe_u8_t *)stat_pg_ptr + group_byte_offset ,0));
                    stat_temp_sens_overall_ptr->cmn_stat.elem_stat_code = stat_temp_sens_ptr->cmn_stat.elem_stat_code;

                    /* Actual call of function */
                    encl_status = fbe_eses_enclosure_temp_sensor_extract_status((fbe_eses_enclosure_t *)viperEnclPtr,
                                              group_id,
                                              (fbe_eses_ctrl_stat_elem_t *)((fbe_u8_t *)stat_pg_ptr + group_byte_offset));

                    if(ENCL_STAT_OK(encl_status))
                    {
                        encl_status = FBE_ENCLOSURE_STATUS_OK;
                    }
                    MUT_ASSERT_TRUE(encl_status == FBE_ENCLOSURE_STATUS_OK);

                    /* Get the component index for this element. */
                    encl_status = fbe_eses_enclosure_get_comp_index((fbe_eses_enclosure_t *)viperEnclPtr,
                                                        group_id,
                                                        elem,
                                                        &temp_sensor_index);

                    MUT_ASSERT_TRUE(encl_status == FBE_ENCLOSURE_STATUS_OK);

                    if(stat_temp_sens_ptr->cmn_stat.elem_stat_code != 4)
                    {
                        switch(stat_temp_sens_ptr->cmn_stat.elem_stat_code)
                        {
                            case SES_STAT_CODE_OK:
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_INSERTED,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_POWERED_OFF,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == FALSE);
                                
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_FAULTED,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == FALSE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_STATUS_VALID,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);

                                edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_ADDL_STATUS,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valueU8);

                                if(EDAL_STAT_OK(edalStatus))
                                {
                                    edalStatus = FBE_EDAL_STATUS_OK;
                                }
                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_INT_EQUAL(valueU8, stat_temp_sens_ptr->cmn_stat.elem_stat_code);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_TEMP_SENSOR_OT_WARNING,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &ts_ot_warning);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(ts_ot_warning == FALSE);
                                
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_TEMP_SENSOR_OT_FAILURE,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &ts_ot_failure);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(ts_ot_failure == FALSE);
                            break;

                            case SES_STAT_CODE_CRITICAL:
                            case SES_STAT_CODE_NONCRITICAL:
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_INSERTED,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_POWERED_OFF,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == FALSE);
                                
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_FAULTED,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == FALSE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_STATUS_VALID,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);

                                edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_ADDL_STATUS,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valueU8);

                                if(EDAL_STAT_OK(edalStatus))
                                {
                                    edalStatus = FBE_EDAL_STATUS_OK;
                                }
                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_INT_EQUAL(valueU8, stat_temp_sens_ptr->cmn_stat.elem_stat_code);             
                                        

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_TEMP_SENSOR_OT_WARNING,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &ts_ot_warning);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);

                                if(stat_temp_sens_ptr->cmn_stat.elem_stat_code == 2)
                                {
                                    MUT_ASSERT_TRUE(ts_ot_warning == FALSE);
                                }
                                else if(stat_temp_sens_ptr->cmn_stat.elem_stat_code == 3)
                                {
                                    MUT_ASSERT_TRUE(ts_ot_warning == TRUE);
                                }
                                else
                                {
                                    MUT_ASSERT_TRUE(ts_ot_warning == FALSE);
                                }

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_TEMP_SENSOR_OT_FAILURE,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &ts_ot_failure);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);

                                if(stat_temp_sens_ptr->cmn_stat.elem_stat_code == 2)
                                {
                                    MUT_ASSERT_TRUE(ts_ot_failure == TRUE);
                                }
                                else if(stat_temp_sens_ptr->cmn_stat.elem_stat_code == 3)
                                {
                                    MUT_ASSERT_TRUE(ts_ot_failure == FALSE);
                                }
                                else
                                {
                                    MUT_ASSERT_TRUE(ts_ot_failure == FALSE);
                                }
                            break;

                            case SES_STAT_CODE_NOT_INSTALLED:
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_INSERTED,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == FALSE);
                    

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_POWERED_OFF,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);
                                
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_FAULTED,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_STATUS_VALID,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);

                                edalStatus = fbe_base_enclosure_edal_getU8((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_ADDL_STATUS,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valueU8);

                                if(EDAL_STAT_OK(edalStatus))
                                {
                                    edalStatus = FBE_EDAL_STATUS_OK;
                                }
                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_INT_EQUAL(valueU8, stat_temp_sens_ptr->cmn_stat.elem_stat_code);

                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_TEMP_SENSOR_OT_WARNING,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &ts_ot_warning);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(ts_ot_warning == FALSE);
                                
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_TEMP_SENSOR_OT_FAILURE,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &ts_ot_failure);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(ts_ot_failure == FALSE);
                            break;
                            case SES_STAT_CODE_UNSUPP:
                            case SES_STAT_CODE_UNRECOV:
                            case SES_STAT_CODE_UNKNOWN:
                            case SES_STAT_CODE_UNAVAILABLE:
                            default:
                                // for Invalid element status code, we need to check for 
                                // FBE_ENCL_COMP_STATUS_VALID attribute only
                                edalStatus = fbe_base_enclosure_edal_getBool((fbe_base_enclosure_t *)viperEnclPtr,
                                            FBE_ENCL_COMP_STATUS_VALID,
                                            FBE_ENCL_TEMP_SENSOR,
                                            temp_sensor_index,
                                            &valuebool);

                                MUT_ASSERT_TRUE(edalStatus == FBE_EDAL_STATUS_OK);
                                MUT_ASSERT_TRUE(valuebool == TRUE);
                            break;
                        }
                    }
                }
            }
        }//found element type other than SES_ELEM_TYPE_TEMP_SENSOR So, come out of loop
    }

    /* restore enclosure configuration */
    fbe_eses_enclosure_set_elem_group((fbe_eses_enclosure_t *)viperEnclPtr, elem_group_orig);

    mut_printf(MUT_LOG_MEDIUM, "%s : Testing %s End ",__FILE__, __FUNCTION__);
    return;
}

/***************************************************************
 * end test_fbe_sas_viper_enclosure_temp_sensor_extract_status()
 ***************************************************************/

/***************************************************************
 *  test_fbe_eses_enclosure_handle_scsi_command_response()
 ****************************************************************
 *  MUT test for Function test_fbe_eses_enclosure_handle_scsi_command_response
 *  which checks the following status and handle the error status of the SCSI command.
 *       (1) the IO request status
 *       (2) the SCSI command status 
 *           It can only be called when the packet status is OK.
 *  The Function also tests the function fbe_eses_enclosure_get_scsi_cc_code() by varying the  
 *   Sense values.
 * @param
 *  None
 *
 * @return 
 *  None
 *
 * HISTORY:
 *  10/12/2008 - Created. UDY
 *
 ****************************************************************/
void test_fbe_eses_enclosure_handle_scsi_cmd_response(void)
{
    int i = 0;
    fbe_eses_ctrl_opcode_t          page_opcode;
    fbe_packet_t                    *packet = NULL;
    fbe_payload_ex_t                   *payload = NULL;
    fbe_eses_enclosure_t            *esesEnclPtr = NULL;
    fbe_u8_t                        *sense_buffer_p = NULL;
    fbe_status_t                    status = FBE_STATUS_OK;
    fbe_sas_viper_enclosure_t       viperEnclosure, *viperEnclPtr;
    fbe_payload_cdb_operation_t     *payload_cdb_operation = NULL;
    fbe_scsi_error_code_t           scsi_error_code = FBE_SCSI_CC_NOERR;
    fbe_enclosure_status_t          encl_status = FBE_ENCLOSURE_STATUS_OK;    

    /* Initialize the Physical Package */
    physical_package_init();

    /*Initialize Eses Enclosure*/
    memset(&viperEnclosure, 0, sizeof(fbe_sas_viper_enclosure_t));
    viperEnclPtr = &viperEnclosure;
    
    /*init component blocks*/
    fbe_sas_viper_init_component_block(viperEnclPtr, test_encl_comp_data);
    esesEnclPtr = &viperEnclPtr->eses_enclosure;   
   
    test_fbe_eses_setup_test_environ((fbe_eses_enclosure_t *)viperEnclPtr);

    // set the life cycle set condition routine for enclosure test.
    fbe_base_enclosure_set_lifecycle_set_cond_routine((fbe_base_enclosure_t *)viperEnclPtr, 
                            (fbe_base_enclosure_lifecycle_set_cond_function_t)test_fbe_lifecycle_set_state);

    /* We have to initialize and assign the status of packet before we continue */
    packet = fbe_transport_allocate_packet();

    if(packet == NULL) 
    {
        return;
    }

    fbe_transport_initialize_packet(packet);
    payload = fbe_transport_get_payload_ex(packet);
    payload_cdb_operation = fbe_payload_ex_allocate_cdb_operation(payload);

    if(payload_cdb_operation == NULL) 
    {
        fbe_transport_release_packet(packet);
        return;
    }

    status = fbe_payload_ex_increment_cdb_operation_level(payload);

    if(status != FBE_STATUS_OK)
    {
        fbe_payload_ex_release_cdb_operation(payload, payload_cdb_operation);
        fbe_transport_release_packet(packet);
        return;
    }

    for(i= MIN_INDEX; i<ARRAY_INDEX; i++)
    {                    
       page_opcode = scsi_hardcoded[i].opcode;

       fbe_payload_cdb_set_scsi_status(payload_cdb_operation, scsi_hardcoded[i].scsi_status );
       fbe_payload_cdb_set_request_status(payload_cdb_operation, scsi_hardcoded[i].cdb_request_status);
       fbe_payload_cdb_operation_get_sense_buffer(payload_cdb_operation,& sense_buffer_p);

       sense_buffer_p[FBE_SCSI_SENSE_DATA_RESPONSE_CODE_OFFSET] = scsi_hardcoded[i].sense_info_buffer_test1;
       sense_buffer_p[FBE_SCSI_SENSE_DATA_SENSE_KEY_OFFSET]  = scsi_hardcoded[i].sense_info_buffer_test2;
       sense_buffer_p[FBE_SCSI_SENSE_DATA_ASC_OFFSET] = scsi_hardcoded[i].sense_info_buffer_test3;
       sense_buffer_p[FBE_SCSI_SENSE_DATA_ASCQ_OFFSET] = scsi_hardcoded[i].sense_info_buffer_test4;

       encl_status = fbe_eses_enclosure_handle_scsi_cmd_response(esesEnclPtr, packet, page_opcode, &scsi_error_code);
       MUT_ASSERT_TRUE(encl_status == scsi_hardcoded[i].enclosure_return_status);
    } 

    fbe_base_enclosure_set_lifecycle_set_cond_routine((fbe_base_enclosure_t *)viperEnclPtr, 
                            (fbe_base_enclosure_lifecycle_set_cond_function_t)fbe_lifecycle_set_cond);

    /* release cdb operation and complete the packet */
    fbe_payload_ex_release_cdb_operation(payload, payload_cdb_operation);
    fbe_transport_release_packet(packet);
}   

/***************************************************************
 * end test_fbe_eses_enclosure_handle_scsi_cmd_response()
 ***************************************************************/


/***************************************************************
 * fbe_sas_viper_init_component_block()
 ****************************************************************
 *  The following function is hardcoded for testing for connectors
 *  before the terminator  provides the config page.
 *  It will be removed after the config and additional page are parsed.
 *   
 * @param   
 *                        
 *
 * @return 
 *
 * HISTORY:
 *  8/22/2008 - Created. DP
 *
 ****************************************************************/
fbe_enclosure_component_block_t * fbe_sas_viper_init_component_block(fbe_sas_viper_enclosure_t * viperEnclPtr, fbe_u8_t *buffer)
{
   fbe_enclosure_component_block_t *sas_viper_component_block = NULL;
   
   sas_viper_component_block = fbe_sas_viper_init_component_block_with_block_size(viperEnclPtr, 
                                                   buffer,
                                                   MAX_ENCL_DATA_BLOCK,
                                                   FBE_MEMORY_CHUNK_SIZE);

 
    return (sas_viper_component_block);
}

/***************************************************************
 * fbe_sas_viper_init_component_block_with_block_size()
 ****************************************************************
 * @brief
 *  This function initializes the headers for all the sas viper EDAL blocks.
 *   
 * @param   
 *   viperEnclPtr - pointer to the sas viper enclosure
 *   buffer - pointer to the first EDAL block.
 *   edal_block_count - The number of EDAL blocks for sas viper enclosure.
 *   memory_chunk_size - the memory chunk size. 
 * 
 * @return 
 *
 * HISTORY:
 *  29-Mar-2010 PHE - Moved from fbe_sas_viper_init_component_block.
 *
 ****************************************************************/
fbe_enclosure_component_block_t * 
fbe_sas_viper_init_component_block_with_block_size(fbe_sas_viper_enclosure_t * viperEnclPtr, 
                                                   fbe_u8_t *buffer,
                                                   fbe_u32_t edal_block_count,
                                                   fbe_u32_t memory_chunk_size)
{
   fbe_status_t status;
   fbe_enclosure_component_block_t *sas_viper_component_block, *prev_block =NULL;
   fbe_u32_t index;
     
   for (index = 0; index < edal_block_count; index ++)
   {
       sas_viper_component_block =
           (fbe_enclosure_component_block_t *)(buffer + memory_chunk_size * index);
       sas_viper_component_block->enclosureBlockCanary = EDAL_BLOCK_CANARY_VALUE;
       sas_viper_component_block->enclosureType = FBE_ENCL_SAS_VIPER;
       sas_viper_component_block->numberComponentTypes = 0;
       sas_viper_component_block->maxNumberComponentTypes = FBE_SAS_VIPER_ENCLOSURE_MAX_COMPONENT_TYPE;
       sas_viper_component_block->blockSize = memory_chunk_size;
       sas_viper_component_block->availableDataSpace  = 
           sas_viper_component_block->blockSize - 
           (sizeof(fbe_enclosure_component_t) * sas_viper_component_block->maxNumberComponentTypes) -
           (sizeof(fbe_enclosure_component_block_t));
       sas_viper_component_block->pNextBlock = NULL;
       if (prev_block!=NULL)
       {
           prev_block->pNextBlock = sas_viper_component_block;
       }
       prev_block = sas_viper_component_block;
    }
    sas_viper_component_block = (fbe_enclosure_component_block_t *)(buffer);


    fbe_base_enclosure_set_component_block_ptr((fbe_base_enclosure_t *)viperEnclPtr, 
                                                sas_viper_component_block);

    fbe_sas_viper_enclosure_init_eses_parameters(viperEnclPtr);

    //initialize component_block data for sas viper enclosure
    status = fbe_sas_viper_format_encl_data(sas_viper_component_block);
    MUT_ASSERT_INT_EQUAL(status,  FBE_STATUS_OK);

    return (sas_viper_component_block);
}


/*!*************************************************************************
 * @fn fbe_status_t test_fbe_lifecycle_set_state(
 *                                       fbe_lifecycle_const_t * p_class_const,
 *                                       struct fbe_base_object_s * p_object,
 *                                       fbe_lifecycle_state_t new_state              
 ***************************************************************************
 * @brief
 *       This function is a STUB for fbe_lifecycle_set_state() which always
 *       returns FBE_STATUS_OK. 
 *
 * @param  p_class_const - A pointer to the lifecycle class constant data of the object.
 * @param  p_object - A pointer to the object.
 * @param  new_state - The new state.
 *
 * @return  fbe_status_t.
 *       FBE_STATUS_OK - always.
 *
 * NOTES
 *
 * HISTORY
 *   22-Apr-2009 Nayana Chaudhari - Created.
 *
 ***************************************************************************/
fbe_status_t test_fbe_lifecycle_set_state(fbe_lifecycle_const_t * p_class_const,
                                     struct fbe_base_object_s * p_object,
                                     fbe_lifecycle_state_t new_state)
{
    /* This function does not do anything since it is only called by test code in a context where we have not setup the spinlock.*/
	
    // Always return FBE_STATUS_OK because currently we don't care about the interaction with framework.
    return FBE_STATUS_OK;
} 

/******************************************
 * end fbe_set_components_elem_group_test()
 ******************************************/