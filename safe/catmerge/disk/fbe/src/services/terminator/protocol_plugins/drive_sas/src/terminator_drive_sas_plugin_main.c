/***************************************************************************
 *  terminator_drive_sas_plugin_main.c
 ***************************************************************************
 *
 *  Description
 *      APIs to emulate the sas protocol
 *
 *
 *  History:
 *      09/11/08    guov    Created/moved from sim\fbe_terminator_sas_drive_io_api.c
 *
 ***************************************************************************/

#include "fbe/fbe_types.h"
#include "fbe/fbe_winddk.h"
#include "fbe/fbe_physical_drive.h"
#include "terminator_sas_io_api.h"
#include "terminator_sas_io_neit.h"
#include "fbe_terminator_file_api.h"
#include "EmcPAL_Memory.h"
#include "terminator_drive.h"
#include "fbe_terminator_common.h"
#include "terminator_drive_sas_write_buffer_timer.h"
#include "terminator_port.h"
#include "fbe/fbe_file.h"
#include "terminator_simulated_disk.h"

/**********************************/
/*        local variables         */
/**********************************/
/*! @todo Remove the following variable and associated code once the PVD
 *        executes `deferred' WRITE SAMEs (currently it issues the WRITE
 *        SAME immediately upon reception which results in he request being
 *        too large).
 */
fbe_trace_level_t   terminator_sas_drive_write_same_too_large_trace_level = FBE_TRACE_LEVEL_WARNING;

static fbe_bool_t terminator_drive_data_compression_enabled = FBE_TRUE;

#if 0
static fbe_u8_t temp_key [32] =
{
    0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
    0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
};

#endif

terminator_sas_drive_inq_data_t default_drive_inquiry_table [] = {
    {FBE_SAS_DRIVE_CHEETA_15K,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x53, 0x45, 0x41, 0x47, 0x41, 0x54, 0x45, 0x20,  //......0.SEAGATE
      0x53, 0x54, 0x54, 0x31, 0x34, 0x36, 0x38, 0x35, 0x20, 0x43, 0x4c, 0x41, 0x52, 0x31, 0x00, 0x00,  //STT14685 CLAR1..
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //000   ..........
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //................
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x53, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Seagate All
      0x72  //r
     },
    },
     /* This is a mythical drive, a 512 bytes per block SAS drive */
    {FBE_SAS_DRIVE_UNICORN_512,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x53, 0x45, 0x41, 0x47, 0x41, 0x54, 0x45, 0x20,  //......0.SEAGATE
      0x53, 0x54, 0x54, 0x31, 0x34, 0x36, 0x38, 0x35, 0x20, 0x43, 0x4c, 0x41, 0x52, 0x31, 0x34, 0x36,  //STT14685 CLAR1..
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //000   ..........
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //................
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x53, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Seagate All
      0x72  //r
     }
    },
     /* This is a mythical drive, a 4096 bytes per block SAS drive */
    {FBE_SAS_DRIVE_UNICORN_4096,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x53, 0x45, 0x41, 0x47, 0x41, 0x54, 0x45, 0x20,  //......0.SEAGATE
      0x53, 0x54, 0x54, 0x31, 0x34, 0x36, 0x38, 0x35, 0x20, 0x43, 0x4c, 0x41, 0x52, 0x31, 0x00, 0x00,  //STT14685 CLAR1..
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //000   ..........
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //................
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x53, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Seagate All
      0x72  //r
     }
    },
     /* This is a mythical drive, a 4160 bytes per block SAS drive */
    {FBE_SAS_DRIVE_UNICORN_4160,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x53, 0x45, 0x41, 0x47, 0x41, 0x54, 0x45, 0x20,  //......0.SEAGATE
      0x53, 0x54, 0x54, 0x31, 0x34, 0x36, 0x38, 0x35, 0x20, 0x43, 0x4c, 0x41, 0x52, 0x31, 0x00, 0x00,  //STT14685 CLAR1..
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //000   ..........
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //................
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x53, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Seagate All
      0x72  //r
     }
    },
    {FBE_SAS_DRIVE_SIM_520,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x53, 0x45, 0x41, 0x47, 0x41, 0x54, 0x45, 0x20,  //......0.SEAGATE
#ifdef C4_INTEGRATED
      0x53, 0x54, 0x33, 0x32, 0x30, 0x30, 0x30, 0x34, 0x43, 0x4c, 0x41, 0x52, 0x31, 0x30, 0x30, 0x00,  //ST320004CLAR100
#else
      0x53, 0x54, 0x30, 0x56, 0x4d, 0x53, 0x49, 0x4d, 0x43, 0x4c, 0x41, 0x52, 0x33, 0x30, 0x30, 0x30,  //ST0VMSIMCLAR3000
#endif /* C4_INTEGRATED - C4HW */
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x30, 0x30, 0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x50, 0x57,  //000  005012345PW
      0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //R...............
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x53, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Seagate All
      0x72  //r
     },
    },    
    {FBE_SAS_DRIVE_SIM_520_FLASH_HE,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x48, 0x49, 0x54, 0x41, 0x43, 0x48, 0x49, 0x00,  //......0.HITACHI
      0x53, 0x54, 0x31, 0x56, 0x4d, 0x53, 0x49, 0x4d, 0x43, 0x4c, 0x41, 0x52, 0x33, 0x30, 0x30, 0x30,  //ST1VMSIMCLAR3000
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x30, 0x30, 0x35, 0x30, 0x32, 0x33, 0x34, 0x35, 0x36, 0x45, 0x46,  //000  005023456EF
      0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //D...............
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x48, 0x69, 0x74, 0x61, 0x63, 0x68, 0x69, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Hitachi All   
      0x72  //r
     },
    },
    {FBE_SAS_DRIVE_SIM_520_FLASH_UNMAP,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x48, 0x49, 0x54, 0x41, 0x43, 0x48, 0x49, 0x00,  //......0.HITACHI
      0x53, 0x54, 0x31, 0x56, 0x4d, 0x53, 0x49, 0x4d, 0x43, 0x4c, 0x41, 0x52, 0x33, 0x30, 0x30, 0x30,  //ST1VMSIMCLAR3000
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x30, 0x30, 0x35, 0x30, 0x32, 0x33, 0x34, 0x35, 0x36, 0x4d, 0x20,  //000  005023456M 
      0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ...............
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x53, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Seagate All
      0x72  //r
     },
    },
    {FBE_SAS_DRIVE_SIM_4160_FLASH_UNMAP,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x48, 0x49, 0x54, 0x41, 0x43, 0x48, 0x49, 0x00,  //......0.HITACHI
      0x53, 0x54, 0x31, 0x56, 0x4d, 0x53, 0x49, 0x4d, 0x43, 0x4c, 0x41, 0x52, 0x33, 0x30, 0x30, 0x30,  //ST1VMSIMCLAR3000
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x30, 0x30, 0x35, 0x30, 0x32, 0x33, 0x34, 0x35, 0x36, 0x4d, 0x20,  //000  005023456M 
      0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ...............
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x53, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Seagate All
      0x72  //r
     },
    },
    {FBE_SAS_DRIVE_SIM_520_UNMAP,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x53, 0x45, 0x41, 0x47, 0x41, 0x54, 0x45, 0x20,  //......0.SEAGATE
#ifdef C4_INTEGRATED
      0x53, 0x54, 0x33, 0x32, 0x30, 0x30, 0x30, 0x34, 0x43, 0x4c, 0x41, 0x52, 0x31, 0x30, 0x30, 0x00,  //ST320004CLAR100
#else
      0x53, 0x54, 0x30, 0x56, 0x4d, 0x53, 0x49, 0x4d, 0x43, 0x4c, 0x41, 0x52, 0x33, 0x30, 0x30, 0x30,  //ST0VMSIMCLAR3000
#endif /* C4_INTEGRATED - C4HW */
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x30, 0x30, 0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x50, 0x57,  //000  005012345PW
      0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //R...............
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x53, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Seagate All
      0x72  //r
     },
    }, 
     /* This is a mythical drive, a 4160 bytes per block SAS drive */
    {FBE_SAS_DRIVE_UNICORN_4160_UNMAP,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x53, 0x45, 0x41, 0x47, 0x41, 0x54, 0x45, 0x20,  //......0.SEAGATE
      0x53, 0x54, 0x54, 0x31, 0x34, 0x36, 0x38, 0x35, 0x20, 0x43, 0x4c, 0x41, 0x52, 0x31, 0x00, 0x00,  //STT14685 CLAR1..
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //000   ..........
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //................
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x53, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Seagate All
      0x72  //r
     }
    },
    {FBE_SAS_NL_DRIVE_SIM_520,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x53, 0x45, 0x41, 0x47, 0x41, 0x54, 0x45, 0x20,  //......0.SEAGATE
      0x53, 0x54, 0x32, 0x56, 0x4d, 0x53, 0x49, 0x4d, 0x43, 0x4c, 0x41, 0x52, 0x33, 0x30, 0x30, 0x30,  //ST2VMSIMCLAR3000
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x30, 0x30, 0x35, 0x30, 0x33, 0x34, 0x35, 0x36, 0x37, 0x50, 0x57,  //000  005034567PW
      0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //R...............
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x53, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Seagate All
      0x72  //r
     },
    },
     /* This is a mythical drive, a 512 bytes per block SAS drive */
    {FBE_SAS_DRIVE_SIM_512,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x53, 0x45, 0x41, 0x47, 0x41, 0x54, 0x45, 0x20,  //......0.SEAGATE
      0x53, 0x54, 0x33, 0x56, 0x4d, 0x53, 0x49, 0x4d, 0x43, 0x4c, 0x41, 0x52, 0x33, 0x30, 0x30, 0x30,  //ST3VMSIMCLAR3000
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x30, 0x30, 0x35, 0x30, 0x34, 0x35, 0x36, 0x37, 0x38, 0x50, 0x57,  //000  005045678PW
      0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //R...............
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x53, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Seagate All
      0x72  //r
     },
    },
    {FBE_SAS_DRIVE_COBRA_E_10K,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x48, 0x49, 0x54, 0x41, 0x43, 0x48, 0x49, 0x00,  //......0.HITACHI
      0x48, 0x55, 0x43, 0x31, 0x30, 0x31, 0x32, 0x31, 0x43, 0x4c, 0x41, 0x52, 0x31, 0x32, 0x30, 0x30,  //HUC10121CLAR1200
      0x43, 0x35, 0x42, 0x30, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //C5B03LN1GCPD....
      0x30, 0x30, 0x30, 0x20, 0x00, 0x00, 0x00, 0x00, 0x44, 0x47, 0x31, 0x31, 0x38, 0x30, 0x33, 0x33,  //........DG118033  
      0x30, 0x38, 0x38, 0x20, 0x20, 0x30, 0x30, 0x35, 0x30, 0x35, 0x30, 0x30, 0x38, 0x34, 0x50, 0x57,  //088  005050084PW
      0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //R...............
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x53, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Seagate All
      0x72  //r
     },
    },
    {FBE_SAS_DRIVE_SIM_520_12G,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x53, 0x45, 0x41, 0x47, 0x41, 0x54, 0x45, 0x20,  //......0.SEAGATE
      0x53, 0x54, 0x33, 0x56, 0x4d, 0x53, 0x49, 0x4d, 0x43, 0x4c, 0x41, 0x52, 0x33, 0x30, 0x30, 0x30,  //ST3VMSIMCLAR3000
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x30, 0x30, 0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x50, 0x57,  //000  005012345PW
      0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //R...............
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x53, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Seagate All
      0x72  //r
     },
    },
    {FBE_SAS_DRIVE_SIM_520_FLASH_ME,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x48, 0x49, 0x54, 0x41, 0x43, 0x48, 0x49, 0x00,  //......0.HITACHI
      0x53, 0x54, 0x31, 0x56, 0x4d, 0x53, 0x49, 0x4d, 0x43, 0x4c, 0x41, 0x52, 0x33, 0x30, 0x30, 0x30,  //ST1VMSIMCLAR3000
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x30, 0x30, 0x35, 0x30, 0x32, 0x33, 0x34, 0x35, 0x36, 0x4d, 0x20,  //000  005023456M
      0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ...............
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x48, 0x69, 0x74, 0x61, 0x63, 0x68, 0x69, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Hitachi All   
      0x72  //r
     },
    },
    {FBE_SAS_DRIVE_SIM_520_FLASH_LE,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x48, 0x49, 0x54, 0x41, 0x43, 0x48, 0x49, 0x00,  //......0.HITACHI
      0x53, 0x54, 0x31, 0x56, 0x4d, 0x53, 0x49, 0x4d, 0x43, 0x4c, 0x41, 0x52, 0x33, 0x30, 0x30, 0x30,  //ST1VMSIMCLAR3000
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x30, 0x30, 0x35, 0x30, 0x32, 0x33, 0x34, 0x35, 0x36, 0x4d, 0x20,  //000  005023456M
      0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ...............
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x48, 0x69, 0x74, 0x61, 0x63, 0x68, 0x69, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Hitachi All   
      0x72  //r
      },
    },
    {FBE_SAS_DRIVE_SIM_520_FLASH_RI,
     {0x00, 0x00, 0x05, 0x12, 0x8b, 0x00, 0x30, 0x02, 0x48, 0x49, 0x54, 0x41, 0x43, 0x48, 0x49, 0x00,  //......0.HITACHI
      0x53, 0x54, 0x31, 0x56, 0x4d, 0x53, 0x49, 0x4d, 0x43, 0x4c, 0x41, 0x52, 0x33, 0x30, 0x30, 0x30,  //ST1VMSIMCLAR3000
      0x45, 0x35, 0x30, 0x31, 0x33, 0x4c, 0x4e, 0x31, 0x47, 0x43, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00,  //E5013LN1GCPD....
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,  //........00000000
      0x30, 0x30, 0x30, 0x20, 0x20, 0x30, 0x30, 0x35, 0x30, 0x32, 0x33, 0x34, 0x35, 0x36, 0x4d, 0x20,  //000  005023456M 
      0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ...............
      0x00, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x32,  //.Copyright (c) 2
      0x30, 0x30, 0x37, 0x20, 0x48, 0x69, 0x74, 0x61, 0x63, 0x68, 0x69, 0x20, 0x41, 0x6c, 0x6c, 0x20,  //007 Hitachi All   
      0x72  //r
      },
    },

    /*add stuff only above*/
    {FBE_SAS_DRIVE_LAST, 0}
};

terminator_sas_drive_mode_page_data_t   default_mode_page_table [] = {
    {FBE_SAS_DRIVE_CHEETA_15K,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_UNICORN_512,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_UNICORN_4096,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_UNICORN_4160,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_SIM_520,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_SIM_520_FLASH_HE,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_SIM_520_FLASH_UNMAP,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_SIM_4160_FLASH_UNMAP,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_SIM_520_UNMAP,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_UNICORN_4160_UNMAP,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_NL_DRIVE_SIM_520,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x1C, 0x1F, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_SIM_512,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_COBRA_E_10K, /* This is not from the disk; copy from FBE_SAS_DRIVE_CHEETA_15K. */
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_SIM_520_12G,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_SIM_520_FLASH_ME,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_SIM_520_FLASH_LE,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },
    {FBE_SAS_DRIVE_SIM_520_FLASH_RI,
     {0xaf, 0x00, 0x10, 0x08, 0x10, 0xb5, 0xc7, 0x30, 0x00, 0x00, 0x02, 0x08, 0x81, 0x0a, 0x04, 0x0b,
      0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x82, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x16, 0x34, 0x2c, 0x00, 0x00, 0x00, 0x1c,
      0x00, 0x00, 0x03, 0xcc, 0x02, 0x08, 0x00, 0x01, 0x00, 0xe6, 0x00, 0xaa, 0x40, 0x00, 0x00, 0x00,
      0x84, 0x16, 0x01, 0x22, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x3a, 0xa7, 0x00, 0x00, 0x87, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x0c, 0x00, 0x88, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x0a, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x06, 0x16, 0x00,
      0x4e, 0x20, 0x4e, 0x20, 0x9a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
      0x9c, 0x0a, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x02, 0x00, 0x00}
    },

    /*add stuff only above*/
    {FBE_SAS_DRIVE_LAST, 0}
};

fbe_u8_t  default_mode_page_10[TERMINATOR_SCSI_MODE_PAGE_10_BYTE_SIZE] = 
    {0x00, 0xea, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0xe5, 0x4b, 0x5b, 0x42, 0x00, 0x00, 0x02, 0x08,
     0x01, 0x0a, 0x04, 0x0b, 0xff, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x02, 0x0e, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x03, 0x16, 0xbb, 0xd0,
     0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x04, 0xc4, 0x02, 0x08, 0x00, 0x01, 0x00, 0x9c, 0x00, 0x26,
     0x40, 0x00, 0x00, 0x00, 0x04, 0x16, 0x03, 0xcc, 0xa8, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x22, 0x00, 0x00, 0x07, 0x0a, 0x04, 0x0b,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x08, 0x12, 0x10, 0x00, 0xff, 0xff, 0x00, 0x00,
     0xff, 0xff, 0xff, 0xff, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0a, 0x00, 0x10,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x18, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x19, 0x0e, 0x06, 0x00, 0x23, 0x28, 0x1b, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x1a, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x8c, 0xa0, 0x00, 0x00, 0x17, 0x70,
     0x00, 0x00, 0x46, 0x50, 0x00, 0x00, 0x46, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x0a, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x01, 0x00, 0x16, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

terminator_sas_drive_mode_page_0x19_data_t   default_mode_page_0x19_table [] = {
    {FBE_SAS_DRIVE_CHEETA_15K,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
      }
    },

    {FBE_SAS_DRIVE_UNICORN_512,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },

    {FBE_SAS_DRIVE_UNICORN_4096,
      {
      /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },

    {FBE_SAS_DRIVE_UNICORN_4160,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },

    {FBE_SAS_DRIVE_SIM_520,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },

    {FBE_SAS_DRIVE_SIM_520_FLASH_HE,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_UNMAP,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
    },

    {FBE_SAS_DRIVE_SIM_4160_FLASH_UNMAP,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
    },

    {FBE_SAS_DRIVE_SIM_520_UNMAP,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
    },

    {FBE_SAS_DRIVE_UNICORN_4160_UNMAP,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
    },
    {FBE_SAS_NL_DRIVE_SIM_520,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },

    {FBE_SAS_DRIVE_SIM_512,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },

    {FBE_SAS_DRIVE_COBRA_E_10K, /* This is not from the disk; copy from FBE_SAS_DRIVE_CHEETA_15K. */
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
      }
    },
    {FBE_SAS_DRIVE_SIM_520_12G,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xBB, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xBB, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },

    {FBE_SAS_DRIVE_SIM_520_FLASH_ME,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_LE,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_RI,
      {
       /* Mode parameter header */
       0x6B, 0x00, 0x10, 0x00,

       /* Preamble for Phy Control And Discover mode page */
       0x59, 0x01, 0x00, 0x64, 0x00, 0x06, 0x00, 0x02,

       /* SAS PHY mode descriptor for port 0 */
       0x00, 0x00, /*PHY*/ 0x00, 0x00, 0x00, 0x00, /*Negotiated Link Rate*/ 0x00, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3D,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

       /* SAS PHY mode descriptor for port 1 */
       0x00, 0x01, /*PHY*/ 0x00, 0x00, 0x10, 0x19, /*Negotiated Link Rate*/ 0x0E, 0x00,
       0x50, 0x00, 0xC5, 0x00, 0x05, 0xC0, 0xF3, 0x3E,
       0x50, 0x00, 0x62, 0xB0, 0x00, 0x00, 0x05, 0x24,
       0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x88, /*Minimum link rates*/ 0xAA, /*Maximum link rates*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
    },

    /*add stuff only above*/
    {FBE_SAS_DRIVE_LAST, 0}
};

fbe_u8_t default_receive_diag_page82 [TERMINATOR_SCSI_DIAG_0x82_SIZE] = {
    0x82, 0x00, 0x00, 0x9e, 0x53, 0x45, 0x41, 0x47, 0x41, 0x54, 0x45, 0x20, 0x30, 0x30, 0x30, 0x38,
    0x00, 0x01,                                     /* page82 head */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x08, /* feature descriptor */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, /* param descriptors */
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
    0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04,
    0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
    0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06,
    0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
    0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08,
    0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
    0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a,
    0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
    0x00, 0x07, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04,
    0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
    0x00, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a
};


terminator_sas_drive_mode_page_0x04_data_t default_mode_page_0x04_table [] = {
    {FBE_SAS_DRIVE_CHEETA_15K,
      {
        0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
        0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x3a, 0xa7, 0x00, 0x00    /* bytes 24-25: rpm 15015 */
      }
    },

    {FBE_SAS_DRIVE_UNICORN_512,
      {
          0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
          0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x3a, 0xa7, 0x00, 0x00    /* bytes 24-25: rpm 15015 */
      }
    },

    {FBE_SAS_DRIVE_UNICORN_4096,
      {
          0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
          0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x3a, 0xa7, 0x00, 0x00    /* bytes 24-25: rpm 15015 */
      }
    },

    {FBE_SAS_DRIVE_UNICORN_4160,
      {
          0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
          0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x3a, 0xa7, 0x00, 0x00    /* bytes 24-25: rpm 15015 */
      }
    },

    {FBE_SAS_DRIVE_SIM_520,
      {
          0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
          0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x3a, 0xa7, 0x00, 0x00    /* bytes 24-25: rpm 15015 */
      }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_HE,
      {
        0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
        0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00     /* bytes 24-25: rpm 0 */
      }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_UNMAP,
      {
        0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
        0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00     /* bytes 24-25: rpm 0 */
      }
    },

    {FBE_SAS_DRIVE_SIM_4160_FLASH_UNMAP,
      {
        0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
        0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00     /* bytes 24-25: rpm 0 */
      }
    },

    {FBE_SAS_DRIVE_SIM_520_UNMAP,
      {
          0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
          0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x3a, 0xa7, 0x00, 0x00    /* bytes 24-25: rpm 15015 */
      }
    },

    {FBE_SAS_DRIVE_UNICORN_4160_UNMAP,
      {
          0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
          0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x3a, 0xa7, 0x00, 0x00    /* bytes 24-25: rpm 15015 */
      }
    },

    {FBE_SAS_NL_DRIVE_SIM_520,
      {
        0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
        0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x1C, 0x1F, 0x00, 0x00    /* bytes 24-25: rpm 7199 */
      }
    },

    {FBE_SAS_DRIVE_SIM_512,
      {
          0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
          0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x3a, 0xa7, 0x00, 0x00    /* bytes 24-25: rpm 15015 */
      }
    },

    {FBE_SAS_DRIVE_COBRA_E_10K, 
      {
        0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
        0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x27, 0x1A, 0x00, 0x00     /* bytes 24-25: rpm 10010 */
      }
    },
    {FBE_SAS_DRIVE_SIM_520_12G,
      {
          0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
          0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x3a, 0xa7, 0x00, 0x00    /* bytes 24-25: rpm 15015 */
      }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_ME,
      {
        0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
        0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00     /* bytes 24-25: rpm 0 */
      }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_LE,
      {
        0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
        0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00     /* bytes 24-25: rpm 0 */
      }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_RI,
      {
        0x1b, 0x00, 0x10, 0x00, 0x84, 0x16, 0x01, 0x8a,
        0x9a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00     /* bytes 24-25: rpm 0 */
      }
    },

    /*add stuff only above*/
    {FBE_SAS_DRIVE_LAST, 0}

};

terminator_sas_drive_vpd_inquiry_page_0xf3_t default_drive_vpd_inquiry_f3_table[] = {
    /* Example of layout:
        byte 1 = 0xF3;  Page Code 
        byte 3 = 0x40;  Page Length 
        byte 6 = 0x01;  Queue Timers Supported 
        byte 7 = 0x08;  Enhanced Queuing Supported 
    */

    {FBE_SAS_DRIVE_CHEETA_15K, 
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x08,  /* don't care about remaining bytes*/
        }
    },

    {FBE_SAS_DRIVE_UNICORN_512,  
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x08,  
        }
    },

    {FBE_SAS_DRIVE_UNICORN_4096, 
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x08,  
        }
    },

    {FBE_SAS_DRIVE_UNICORN_4160, 
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x08,  
        }
    },

    {FBE_SAS_DRIVE_SIM_520,      
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x08,  
        }
    },

    {FBE_SAS_NL_DRIVE_SIM_520,  
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x08,  
        }
    },

    {FBE_SAS_DRIVE_SIM_512,       
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x08,  
        }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_HE, 
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00,  /* byte 7: EQ disabled*/
        }
    },
    {FBE_SAS_DRIVE_SIM_520_FLASH_UNMAP, 
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00,  /* byte 7: EQ disabled*/
        }
    },

    {FBE_SAS_DRIVE_SIM_4160_FLASH_UNMAP, 
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00,  /* byte 7: EQ disabled*/
        }
    },

    {FBE_SAS_DRIVE_SIM_520_UNMAP,      
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x08,  
        }
    },

    {FBE_SAS_DRIVE_UNICORN_4160_UNMAP, 
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x08,  
        }
    },

    {FBE_SAS_DRIVE_COBRA_E_10K,   
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x08,  
        }
    },
    {FBE_SAS_DRIVE_SIM_520_12G,
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x08,
        }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_ME,
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00, /* byte 7: EQ Disabled */
        }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_LE,
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00, /* byte 7: EQ disabled */
        }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_RI,
        {
            0x00, 0xF3, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00, /* byte 7: EQ disabled */
        }
    },

    /*add stuff only above*/
    {FBE_SAS_DRIVE_LAST, 0}
};

terminator_sas_drive_vpd_inquiry_page_0xb2_t default_drive_vpd_inquiry_b2_table[] = {
    /* Example of layout:
        byte 1 = 0xB2;  Page Code 
        byte 2 & 3 = 0x0004;  Page Length
        byte 4 = 0x00 threshold exponenet
        byte 5 = 0xE0 unmap supported, ws_16 supported, ws_unmap supported
    */

    {FBE_SAS_DRIVE_CHEETA_15K, 
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0x00,   /* don't care about remaining bytes*/
        }
    },

    {FBE_SAS_DRIVE_UNICORN_512,  
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0x00,   
        }
    },

    {FBE_SAS_DRIVE_UNICORN_4096, 
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0x00, 
        }
    },

    {FBE_SAS_DRIVE_UNICORN_4160, 
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0x00,  
        }
    },

    {FBE_SAS_DRIVE_SIM_520,      
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0x00, 
        }
    },

    {FBE_SAS_NL_DRIVE_SIM_520,  
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0x00, 
        }
    },

    {FBE_SAS_DRIVE_SIM_512,       
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0x00,   
        }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_HE, 
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0x00,   
        }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_UNMAP, 
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0xE0,   /* byte 5: unmap, ws16, ws with unmap supported*/
        }
    },

    {FBE_SAS_DRIVE_SIM_4160_FLASH_UNMAP, 
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0xE0,   /* byte 5: unmap, ws16, ws with unmap supported*/
        }
    },

    {FBE_SAS_DRIVE_SIM_520_UNMAP,      
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0xE0, /* byte 5: unmap, ws16, ws with unmap supported*/
        }
    },

    {FBE_SAS_DRIVE_UNICORN_4160_UNMAP, 
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0xE0, /* byte 5: unmap, ws16, ws with unmap supported*/
        }
    },

    {FBE_SAS_DRIVE_COBRA_E_10K,   
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0x00, 
        }
    },
    {FBE_SAS_DRIVE_SIM_520_12G,
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0x00, 
        }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_ME, 
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0xE0, /* byte 5: unmap, ws16, ws with unmap supported*/
        }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_LE, 
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0xE0, /* byte 5: unmap, ws16, ws with unmap supported*/
        }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_RI, 
        {
            0x00, 0xB2, 0x00, 0x04, 0x00, 0xE0, /* byte 5: unmap, ws16, ws with unmap supported*/
        }
    },

    /*add stuff only above*/
    {FBE_SAS_DRIVE_LAST, 0}
};

terminator_sas_drive_vpd_inquiry_page_0xc0_t default_drive_vpd_inquiry_c0_table[] = {
    /* Example of layout:   This only applies to SSDs
            b_ptr[1] = 0xC0;  -- Page Code 
            b_ptr[3] = 0x20;  -- Page Length 
            b_ptr[6] = 0x36;  -- Servo Code Revision Start
            b_ptr[7] = 0x37;
            b_ptr[8] = 0x38;
            b_ptr[9] = 0x39;  -- Servo Code Revision End 
            b_ptr[12] = 0x4A; -- Servo Code Revision Start
            b_ptr[13] = 0x4F;
            b_ptr[14] = 0x45;
            b_ptr[15] = 0x42;

            b_ptr[16] = 0x4A;
            b_ptr[17] = 0x4F;
            b_ptr[18] = 0x45;
            b_ptr[19] = 0x42; -- Servo Code Revision End
            b_ptr[20] = 0x00; -- writes per day.  high bit means valid, remaining are wpd
    */
    {FBE_SAS_DRIVE_CHEETA_15K, 
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x00, 
        }
    },

    {FBE_SAS_DRIVE_UNICORN_512,  
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x00, 
        }
    },

    {FBE_SAS_DRIVE_UNICORN_4096, 
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x00, 
        }
    },

    {FBE_SAS_DRIVE_UNICORN_4160, 
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x00, 
        }
    },

    {FBE_SAS_DRIVE_SIM_520,      
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x00, 
        }
    },

    {FBE_SAS_NL_DRIVE_SIM_520,  
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x00, 
        }
    },

    {FBE_SAS_DRIVE_SIM_512,       
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x00, 
        }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_HE, 
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x99,  /* byte[20] = 25 wpd*/
        }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_UNMAP, 
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x8A,   /* byte[20] = 10 wpd*/
        }
    },

    {FBE_SAS_DRIVE_SIM_4160_FLASH_UNMAP, 
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x8A,   /* byte[20] = 10 wpd*/
        }
    },

    {FBE_SAS_DRIVE_SIM_520_UNMAP,      
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x00, 
        }
    },

    {FBE_SAS_DRIVE_UNICORN_4160_UNMAP, 
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x00, 
        }
    },

    {FBE_SAS_DRIVE_COBRA_E_10K,   
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x00, 
        }
    },
    {FBE_SAS_DRIVE_SIM_520_12G,
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x00, 
        }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_ME, 
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x8A,   /* byte[20] = 10 wpd*/
        }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_LE, 
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x83,    /* byte[20] = 3 wpd*/
        }
    },

    {FBE_SAS_DRIVE_SIM_520_FLASH_RI, 
        {
            0x00, 0xC0, 0x00, 0x20, 0x00, 0x00, 0x36, 0x37, 
            0x38, 0x39, 0x00, 0x00, 0x4A, 0x4F, 0x45, 0x42, 
            0x4A, 0x4F, 0x45, 0x42, 0x81,    /* byte[20] = 1 wpd*/
        }
    },

    /*add stuff only above*/
    {FBE_SAS_DRIVE_LAST, 0}
};

//fbe_u8_t  default_mode_page_10[TERMINATOR_SCSI_MODE_PAGE_10_BYTE_SIZE] = 
fbe_u8_t default_log_page_31[TERMINATOR_SCSI_LOG_PAGE_31_BYTE_SIZE] =
{
    0x31,0x00,0x00,0x00,
    0x80,0x00,0x00,0x08, 
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30, // current max erase operations 8-15
    0x80,0x01,0x00,0x08,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10, // channel 0 max erase count
    0x80,0x02,0x00,0x08,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01, // channel 0 min erase count
    0x80,0x03,0x00,0x08,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08, // channel 0 average erase count
    0x80,0x11,0x00,0x08,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20, // channel 1 max erase count
    0x80,0x12,0x00,0x08,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01, // channel 1 min erase count
    0x80,0x13,0x00,0x08,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18, // channel 1 average erase count
    0x80,0x21,0x00,0x08,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30, // channel 2 max erase count
    0x80,0x22,0x00,0x08,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01, // channel 2 min erase count
    0x80,0x23,0x00,0x08,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28, // channel 2 average erase count
    0x8F,0xFE,0x00,0x08,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,// power on hours 0x8ffe param len 0x8 val 0x10
    0x8F,0xFF,0x00,0x08,
    0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,// eol pe cycle 0x8fff param len 0x8 val 0x100
    //0x00,0x00,0x90,0x00

};

//static fbe_u8_t two_megabyte_buffer[TERMINATOR_MAX_IO_SIZE];
/*!*******************************************************************
 * @var fbe_sas_drive_max_io_time_ms
 *********************************************************************
 * @brief This is the max io time we have seen in milliseconds.
 *
 *********************************************************************/
static fbe_time_t fbe_sas_drive_max_io_time_ms = 0;

/*!*******************************************************************
 * @def FBE_SAS_DRIVE_MAX_IO_TIME_MS
 *********************************************************************
 * @brief Max time after which we will trace.  This is arbitrary.
 *
 *********************************************************************/
#define FBE_SAS_DRIVE_MAX_IO_TIME_MS 1000

/******************************/
/*     local function         */
/*****************************/
static fbe_status_t sas_drive_set_default_vpd_inquiry_f3(fbe_sas_drive_type_t drive_type, fbe_terminator_drive_default_field_t field, const fbe_u8_t *data, fbe_u32_t size);
static fbe_status_t sas_drive_set_default_vpd_inquiry_b2(fbe_sas_drive_type_t drive_type, fbe_terminator_drive_default_field_t field, const fbe_u8_t *data, fbe_u32_t size);
static fbe_status_t sas_drive_set_default_inquiry(fbe_sas_drive_type_t drive_type, fbe_terminator_drive_default_field_t field, const fbe_u8_t *data, fbe_u32_t size, 
                                                  fbe_u32_t expected_inq_size, fbe_u32_t inquiry_offset);
static fbe_status_t sas_drive_get_default_mode_page_data (fbe_sas_drive_type_t drive_type, terminator_sas_drive_mode_page_data_t **mode_page_data);
static fbe_status_t sas_drive_get_default_mode_page_0x19_data (fbe_sas_drive_type_t drive_type, terminator_sas_drive_mode_page_0x19_data_t **mode_page_0x19_data);
static fbe_status_t sas_drive_set_default_mode_page_data (fbe_sas_drive_type_t drive_type, fbe_u8_t *mode_page_data);
static fbe_status_t sas_drive_get_default_mode_page_0x04_data (fbe_sas_drive_type_t drive_type, terminator_sas_drive_mode_page_0x04_data_t **mode_page_0x04_data);

static fbe_status_t sas_drive_process_xfer(fbe_terminator_io_t * terminator_io,
                                           fbe_terminator_device_ptr_t drive_handle,
                                           sas_drive_xfer_data_t *xfer_data);

static fbe_status_t sas_drive_process_compressed_sg_write(fbe_terminator_io_t * terminator_io,
                                                          fbe_terminator_device_ptr_t drive_handle,
                                                          sas_drive_xfer_data_t *xfer_data);

static fbe_status_t sas_drive_process_memory_xfer(fbe_payload_ex_t *payload_p,
                                                    fbe_terminator_device_ptr_t drive_handle,
                                                    sas_drive_xfer_data_t *xfer_data);

/* Below are the functions that supports payload */
static fbe_status_t sas_drive_process_payload_inquiry (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_read_capacity (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_read_capacity_16 (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_mode_sense_6 (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_mode_select_6 (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_mode_sense_10 (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_mode_select_10 (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_start_stop_unit (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_reserve (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_reserve_10 (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_release (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_release_10 (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_verify (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_reassign_blocks (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_send_diagnostic (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_tur(fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_write_buffer (fbe_terminator_io_t * terminator_io, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_receive_diag (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);
static fbe_status_t sas_drive_process_payload_log_sense (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle);

static fbe_status_t sas_drive_payload_prepare_xfer(fbe_payload_ex_t * payload,
    fbe_terminator_device_ptr_t drive_handle,
    sas_drive_xfer_data_t *xfer_data, fbe_bool_t cdb_flag);

static fbe_status_t sas_drive_payload_prepare_read_6_xfer(fbe_payload_ex_t * payload,
    fbe_terminator_device_ptr_t drive_handle,
    sas_drive_xfer_data_t *xfer_data);
static fbe_status_t sas_drive_payload_prepare_read_10_xfer(fbe_payload_ex_t * payload,
    fbe_terminator_device_ptr_t drive_handle,
    sas_drive_xfer_data_t *xfer_data);
static fbe_status_t sas_drive_payload_prepare_read_16_xfer(fbe_payload_ex_t * payload,
    fbe_terminator_device_ptr_t drive_handle,
    sas_drive_xfer_data_t *xfer_data);
static fbe_status_t sas_drive_payload_prepare_write_6_xfer(fbe_payload_ex_t * payload,
    fbe_terminator_device_ptr_t drive_handle,
    sas_drive_xfer_data_t *xfer_data);
static fbe_status_t sas_drive_payload_prepare_write_10_xfer(fbe_payload_ex_t * payload,
    fbe_terminator_device_ptr_t drive_handle,
    sas_drive_xfer_data_t *xfer_data);
static fbe_status_t sas_drive_payload_prepare_write_16_xfer(fbe_payload_ex_t * payload,
    fbe_terminator_device_ptr_t drive_handle,
    sas_drive_xfer_data_t *xfer_data);
static fbe_status_t sas_drive_payload_write_same(fbe_terminator_io_t * terminator_io, 
                                                 fbe_terminator_device_ptr_t drive_handle,
                                                 fbe_bool_t b_is_zeros);
static void sas_drive_build_sense_data(
    fbe_u8_t *sense_info_buffer,
    fbe_scsi_sense_key_t sense_key,
    fbe_scsi_additional_sense_code_t ASC,
    fbe_scsi_additional_sense_code_qualifier_t ASCQ);

static fbe_bool_t sas_drive_is_zero_pattern_block(fbe_u8_t * data_buffer, fbe_block_size_t block_size);
fbe_status_t terminator_drive_compress_buffer(sas_drive_xfer_data_t * xfer_data, fbe_u8_t * data_buffer, terminator_key_info_t * key_info);
fbe_status_t terminator_drive_decompress_buffer(sas_drive_xfer_data_t * xfer_data, fbe_u8_t * data_buffer, fbe_u32_t data_size, terminator_key_info_t *key_info);


/*!**************************************************************
 * @fn sas_drive_get_default_page_info
 ****************************************************************
 * @brief
 *     Get the default mode page and inquiry page data for a 
 *     specific drive type. This is what a new drive is
 *     initialized with.
 *
 * @param drive_type -    Drive type.
 * @param default_info_p - data passed back
 *
 * @return fbe_status_t
 *
 * @author
 *  12/24/2013  Wayne Garrett - Created.
 *
 ****************************************************************/
fbe_status_t sas_drive_get_default_page_info(fbe_sas_drive_type_t drive_type, fbe_terminator_sas_drive_type_default_info_t *default_info_p)
{
    terminator_sas_drive_inq_data_t * inq_data = NULL;
    terminator_sas_drive_vpd_inquiry_page_0xf3_t * vpd_inq_f3 = NULL;
    terminator_sas_drive_mode_page_data_t * mode_page = NULL;
    terminator_sas_drive_mode_page_0x19_data_t * mode_page_0x19 = NULL;
    terminator_sas_drive_mode_page_0x04_data_t * mode_page_0x04 = NULL;
    terminator_sas_drive_vpd_inquiry_page_0xc0_t * vpd_inq_c0 = NULL;
    terminator_sas_drive_vpd_inquiry_page_0xb2_t * vpd_inq_b2 = NULL;
    fbe_status_t status;

    status = sas_drive_get_default_inq_data(drive_type, &inq_data);  
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: inquiry for drive_type[%d] not found\n", __FUNCTION__, drive_type);
        return status;
    }

    status = sas_drive_get_default_vpd_inq_f3_data(drive_type, &vpd_inq_f3);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: vpd inquiry 0xf3 for drive_type[%d] not found\n", __FUNCTION__, drive_type);
        return status;
    }

    status = sas_drive_get_default_vpd_inq_b2_data(drive_type, &vpd_inq_b2);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: vpd inquiry 0xb2 for drive_type[%d] not found\n", __FUNCTION__, drive_type);
        return status;
    }

    status = sas_drive_get_default_vpd_inq_c0_data(drive_type, &vpd_inq_c0);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: vpd inquiry 0xc0 for drive_type[%d] not found\n", __FUNCTION__, drive_type);
        return status;
    }

    status = sas_drive_get_default_mode_page_data(drive_type, &mode_page);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: mode page for drive_type[%d] not found\n", __FUNCTION__, drive_type);
        return status;
    }

    status = sas_drive_get_default_mode_page_0x19_data(drive_type, &mode_page_0x19);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: mode page 0x19 for drive_type[%d] not found\n", __FUNCTION__, drive_type);
        return status;
    }    

    status = sas_drive_get_default_mode_page_0x04_data(drive_type, &mode_page_0x04);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: mode page 0x04 for drive_type[%d] not found\n", __FUNCTION__, drive_type);
        return status;
    } 
    

    fbe_copy_memory(default_info_p->inquiry, inq_data->drive_inquiry, sizeof(default_info_p->inquiry));
    fbe_copy_memory(default_info_p->vpd_inquiry_f3, vpd_inq_f3->data, sizeof(default_info_p->vpd_inquiry_f3));
    fbe_copy_memory(default_info_p->vpd_inquiry_b2, vpd_inq_b2->data, sizeof(default_info_p->vpd_inquiry_b2));
    fbe_copy_memory(default_info_p->mode_page_for_mode_sense_6, mode_page->drive_mode_page, sizeof(default_info_p->mode_page_for_mode_sense_6));    
    fbe_copy_memory(default_info_p->mode_page_for_mode_sense_10, default_mode_page_10, sizeof(default_info_p->mode_page_for_mode_sense_10));
    fbe_copy_memory(default_info_p->mode_page_0x04, mode_page_0x04->drive_mode_page, sizeof(default_info_p->mode_page_0x04));
    fbe_copy_memory(default_info_p->vpd_inquiry_c0, vpd_inq_c0->data, sizeof(default_info_p->vpd_inquiry_c0));
    fbe_copy_memory(default_info_p->mode_page_0x19, mode_page_0x19->drive_mode_page, sizeof(default_info_p->mode_page_0x19));
    fbe_copy_memory(default_info_p->diag_page_0x82, default_receive_diag_page82, sizeof(default_info_p->diag_page_0x82));
    fbe_copy_memory(default_info_p->log_page_31, default_log_page_31, sizeof(default_info_p->log_page_31));

    return FBE_STATUS_OK;
}

/*!**************************************************************
 * @fn sas_drive_set_default_page_info
 ****************************************************************
 * @brief
 *     Change the drive's default mode page and inquiry page data
 *     for a specific drive type.   This is what a new drive is
 *     initialized with.
 *
 * @param drive_type -    Drive type.
 * @param default_info_p - data passed back
 *
 * @return fbe_status_t
 *
 * @author
 *  12/24/2013  Wayne Garrett - Created.
 *
 ****************************************************************/
fbe_status_t sas_drive_set_default_page_info(fbe_sas_drive_type_t drive_type, const fbe_terminator_sas_drive_type_default_info_t *default_info_p)
{
    terminator_sas_drive_inq_data_t * inq_data = NULL;
    terminator_sas_drive_vpd_inquiry_page_0xf3_t * vpd_inq_f3 = NULL;
    terminator_sas_drive_vpd_inquiry_page_0xb2_t * vpd_inq_b2 = NULL;
    terminator_sas_drive_mode_page_data_t * mode_page = NULL;
    terminator_sas_drive_mode_page_0x19_data_t * mode_page_0x19 = NULL;
    terminator_sas_drive_mode_page_0x04_data_t * mode_page_0x04 = NULL;
    terminator_sas_drive_vpd_inquiry_page_0xc0_t * vpd_inq_c0 = NULL;
    fbe_status_t status;

    status = sas_drive_get_default_inq_data(drive_type, &inq_data);  
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: inquiry for drive_type[%d] not found\n", __FUNCTION__, drive_type);
        return status;
    }

    status = sas_drive_get_default_vpd_inq_f3_data(drive_type, &vpd_inq_f3);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: vpd inquiry 0xf3 for drive_type[%d] not found\n", __FUNCTION__, drive_type);
        return status;
    }

    status = sas_drive_get_default_vpd_inq_b2_data(drive_type, &vpd_inq_b2);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: vpd inquiry 0xb2 for drive_type[%d] not found\n", __FUNCTION__, drive_type);
        return status;
    }

    status = sas_drive_get_default_mode_page_data(drive_type, &mode_page);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: mode page for drive_type[%d] not found\n", __FUNCTION__, drive_type);
        return status;
    }

    status = sas_drive_get_default_vpd_inq_c0_data(drive_type, &vpd_inq_c0);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: vpd inquiry 0xc0 for drive_type[%d] not found\n", __FUNCTION__, drive_type);
        return status;
    }

    status = sas_drive_get_default_mode_page_0x19_data(drive_type, &mode_page_0x19);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: mode page 0x19 for drive_type[%d] not found\n", __FUNCTION__, drive_type);
        return status;
    }    

    status = sas_drive_get_default_mode_page_0x04_data(drive_type, &mode_page_0x04);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: mode page 0x04 for drive_type[%d] not found\n", __FUNCTION__, drive_type);
        return status;
    } 

    fbe_copy_memory(inq_data->drive_inquiry, default_info_p->inquiry, sizeof(default_info_p->inquiry));
    fbe_copy_memory(vpd_inq_f3->data, default_info_p->vpd_inquiry_f3, sizeof(default_info_p->vpd_inquiry_f3));
    fbe_copy_memory(vpd_inq_b2->data, default_info_p->vpd_inquiry_b2, sizeof(default_info_p->vpd_inquiry_b2));
    fbe_copy_memory(mode_page->drive_mode_page, default_info_p->mode_page_for_mode_sense_6, sizeof(default_info_p->mode_page_for_mode_sense_6));
    fbe_copy_memory(default_mode_page_10, default_info_p->mode_page_for_mode_sense_10, sizeof(default_info_p->mode_page_for_mode_sense_10));
    fbe_copy_memory(mode_page_0x04->drive_mode_page, default_info_p->mode_page_0x04, sizeof(default_info_p->mode_page_0x04));
    fbe_copy_memory(vpd_inq_c0->data, default_info_p->vpd_inquiry_c0, sizeof(default_info_p->vpd_inquiry_c0));
    fbe_copy_memory(mode_page_0x19->drive_mode_page, default_info_p->mode_page_0x19, sizeof(default_info_p->mode_page_0x19));
    fbe_copy_memory(default_receive_diag_page82, default_info_p->diag_page_0x82, sizeof(default_info_p->diag_page_0x82));    
    fbe_copy_memory(default_log_page_31, default_info_p->log_page_31, sizeof(default_info_p->log_page_31));

    return FBE_STATUS_OK;
}


/*!**************************************************************
 * @fn sas_drive_get_default_vpd_inq_f3_data
 ****************************************************************
 * @brief
 *     Get ptr to the default Page F3 Inquiry for a 
 *     specific drive type. This is what a new drive is
 *     initialized with.
 *
 * @param drive_type -    Drive type.
 * @param default_info_p - data passed back
 *
 * @return fbe_status_t
 *
 * @author
 *  12/24/2013  Wayne Garrett - Created.
 *
 ****************************************************************/
fbe_status_t sas_drive_get_default_vpd_inq_f3_data (fbe_sas_drive_type_t drive_type, terminator_sas_drive_vpd_inquiry_page_0xf3_t **inq_data)
{
    *inq_data = default_drive_vpd_inquiry_f3_table;

    while ((*inq_data)->drive_type != FBE_SAS_DRIVE_LAST) {
        if ((*inq_data)->drive_type == drive_type) {
            return FBE_STATUS_OK;
        }

        (*inq_data)++;
    }

    /*we did not find anything*/
    return FBE_STATUS_GENERIC_FAILURE;
}

/*!**************************************************************
 * @fn sas_drive_get_default_vpd_inq_b2_data
 ****************************************************************
 * @brief
 *     Get ptr to the default Page B2 Inquiry for a 
 *     specific drive type. This is what a new drive is
 *     initialized with.
 *
 * @param drive_type -    Drive type.
 * @param default_info_p - data passed back
 *
 * @return fbe_status_t
 *
 * @author
 *  05/07/2015  Deanna Heng - Created.
 *
 ****************************************************************/
fbe_status_t sas_drive_get_default_vpd_inq_b2_data (fbe_sas_drive_type_t drive_type, terminator_sas_drive_vpd_inquiry_page_0xb2_t **inq_data)
{
    *inq_data = default_drive_vpd_inquiry_b2_table;

    while ((*inq_data)->drive_type != FBE_SAS_DRIVE_LAST) {
        if ((*inq_data)->drive_type == drive_type) {
            return FBE_STATUS_OK;
        }

        (*inq_data)++;
    }

    /*we did not find anything*/
    return FBE_STATUS_GENERIC_FAILURE;
}

/*!**************************************************************
 * @fn sas_drive_get_default_vpd_inq_c0_data
 ****************************************************************
 * @brief
 *     Get ptr to the default Page C0 Inquiry for a 
 *     specific drive type. This is what a new drive is
 *     initialized with.
 *
 * @param drive_type -    Drive type.
 * @param default_info_p - data passed back
 *
 * @return fbe_status_t
 *
 * @author
 *  08/26/2015  Wayne Garrett - Created.
 *
 ****************************************************************/
fbe_status_t sas_drive_get_default_vpd_inq_c0_data (fbe_sas_drive_type_t drive_type, terminator_sas_drive_vpd_inquiry_page_0xc0_t **inq_data)
{
    *inq_data = default_drive_vpd_inquiry_c0_table;

    while ((*inq_data)->drive_type != FBE_SAS_DRIVE_LAST) {
        if ((*inq_data)->drive_type == drive_type) {
            return FBE_STATUS_OK;
        }

        (*inq_data)++;
    }

    /*we did not find anything*/
    return FBE_STATUS_GENERIC_FAILURE;
}

/*!**************************************************************
 * @fn sas_drive_get_default_inq_data
 ****************************************************************
 * @brief
 *     Get ptr to the default Inquiry for a 
 *     specific drive type. This is what a new drive is
 *     initialized with.
 *
 * @param drive_type -    Drive type.
 * @param default_info_p - data passed back
 *
 * @return fbe_status_t
 *
 * @author
 *  12/24/2013  Wayne Garrett - Created.
 *
 ****************************************************************/
fbe_status_t sas_drive_get_default_inq_data (fbe_sas_drive_type_t drive_type, terminator_sas_drive_inq_data_t **inq_data)
{
    *inq_data = default_drive_inquiry_table;

    while ((*inq_data)->drive_type != FBE_SAS_DRIVE_LAST) {
        if ((*inq_data)->drive_type == drive_type) {
            return FBE_STATUS_OK;
        }

        (*inq_data)++;
    }

    /*we did not find anything*/
    return FBE_STATUS_GENERIC_FAILURE;
}


/*!**************************************************************
 * @fn sas_drive_set_default_field
 ****************************************************************
 * @brief
 *     Changes the terminator's underlying global inquiry data
 *     struct, for a specific drive type.  Note, there is a higher level
 *     drive device object which may report back different values.  This
 *     object will intercept the inquiry data and overwrite the results
 *     with its info.   See sas_drive_process_payload_inquiry() for
 *     which values may be overwritten by this device object.
 *
 * @param drive_type -    Drive type.
 * @param field -         Inquiry field to update.
 * @param inq_data -      New inquiry data.
 * @param inq_size -      size of data.
 *
 * @return fbe_status_t
 *
 * @author
 *  10/21/2013  Wayne Garrett - Created.
 *
 ****************************************************************/
fbe_status_t sas_drive_set_default_field (fbe_sas_drive_type_t drive_type, fbe_terminator_drive_default_field_t field, const fbe_u8_t *data, fbe_u32_t size)
{
    fbe_status_t status = FBE_STATUS_GENERIC_FAILURE;       

    fbe_u32_t expected_inq_size = 0;
    fbe_u32_t inquiry_offset = 0;

    switch(field)
    {
        case FBE_DRIVE_INQUIRY_FIELD_VENDOR:
            expected_inq_size = FBE_SCSI_INQUIRY_VENDOR_ID_SIZE;
            inquiry_offset    = FBE_SCSI_INQUIRY_VENDOR_ID_OFFSET;
            status = sas_drive_set_default_inquiry(drive_type, field, data, size, expected_inq_size, inquiry_offset);
            break;
    
        case FBE_DRIVE_INQUIRY_FIELD_PRODUCT_ID:
            expected_inq_size = FBE_SCSI_INQUIRY_PRODUCT_ID_SIZE;
            inquiry_offset    = FBE_SCSI_INQUIRY_PRODUCT_ID_OFFSET;
            status = sas_drive_set_default_inquiry(drive_type, field, data, size, expected_inq_size, inquiry_offset);
            break;
    
        case FBE_DRIVE_INQUIRY_FIELD_SERIAL_NUMBER:
            expected_inq_size = FBE_SCSI_INQUIRY_SERIAL_NUMBER_SIZE;
            inquiry_offset    = FBE_SCSI_INQUIRY_SERIAL_NUMBER_OFFSET;
            status = sas_drive_set_default_inquiry(drive_type, field, data, size, expected_inq_size, inquiry_offset);
            break;
    
        case FBE_DRIVE_INQUIRY_FIELD_PART_NUMBER:
            expected_inq_size = FBE_SCSI_INQUIRY_PART_NUMBER_SIZE;
            inquiry_offset    = FBE_SCSI_INQUIRY_PART_NUMBER_OFFSET;
            status = sas_drive_set_default_inquiry(drive_type, field, data, size, expected_inq_size, inquiry_offset);
            break;
    
        case FBE_DRIVE_INQUIRY_FIELD_TLA:
            expected_inq_size = FBE_SCSI_INQUIRY_TLA_SIZE;
            inquiry_offset    = FBE_SCSI_INQUIRY_TLA_OFFSET;
            status = sas_drive_set_default_inquiry(drive_type, field, data, size, expected_inq_size, inquiry_offset);
            break;
    
        case FBE_DRIVE_INQUIRY_FIELD_REV:
            expected_inq_size = FBE_SCSI_INQUIRY_REVISION_SIZE;
            inquiry_offset    = FBE_SCSI_INQUIRY_REVISION_OFFSET;
            status = sas_drive_set_default_inquiry(drive_type, field, data, size, expected_inq_size, inquiry_offset);
            break;
    
        case FBE_DRIVE_INQUIRY_FIELD_ALL:    /* entire inquiry data buffer*/
            expected_inq_size = FBE_SCSI_INQUIRY_DATA_SIZE;
            inquiry_offset    = 0;
            status = sas_drive_set_default_inquiry(drive_type, field, data, size, expected_inq_size, inquiry_offset);
            break;
    
        case FBE_DRIVE_VPD_INQUIRY_F3_FIELD_ALL:
            status = sas_drive_set_default_vpd_inquiry_f3(drive_type, field, data, size);
            break;
        case FBE_DRIVE_VPD_INQUIRY_B2_FIELD_ALL:
            status = sas_drive_set_default_vpd_inquiry_b2(drive_type, field, data, size);
            break;

        default:
            terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: Invalid field %d\n", 
                             __FUNCTION__, field);
    
            return FBE_STATUS_GENERIC_FAILURE;
    }

    return status;
}

/*!**************************************************************
 * @fn sas_drive_set_default_vpd_inquiry_f3
 ****************************************************************
 * @brief
 *     Changes the terminator's underlying global page F3 VPD Inquiry data
 *     struct, for a specific drive type.  When a new drive is created
 *     it is initalized with this data.
 *
 * @param drive_type -  Drive type.
 * @param field -       Inquiry field to update.
 * @param data -        New inquiry data.
 * @param size -        size of data.
 *
 * @return fbe_status_t
 *
 * @author
 *  12/24/2013  Wayne Garrett - Created.
 *
 ****************************************************************/
static fbe_status_t sas_drive_set_default_vpd_inquiry_f3(fbe_sas_drive_type_t drive_type, fbe_terminator_drive_default_field_t field, const fbe_u8_t *data, fbe_u32_t size)
{
    terminator_sas_drive_vpd_inquiry_page_0xf3_t *dflt_vpd_f3_p = default_drive_vpd_inquiry_f3_table;

    /* find drive type and copy in new inquiry data */
    while (dflt_vpd_f3_p->drive_type != FBE_SAS_DRIVE_LAST){
        if (dflt_vpd_f3_p->drive_type == drive_type){

            if (size != sizeof(dflt_vpd_f3_p->data))
            {
                terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: Invalid field size. field:%d, len %d != %lu\n", 
                                 __FUNCTION__, field, size, (long unsigned int)sizeof(dflt_vpd_f3_p->data));
                return FBE_STATUS_GENERIC_FAILURE;
            }

            fbe_copy_memory(dflt_vpd_f3_p->data, data, size);
            return FBE_STATUS_OK;
        }
        dflt_vpd_f3_p++;
    }

    /*we did not find anything*/
    terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: drive_type %d not found. field:%d len:%d\n", 
                     __FUNCTION__, drive_type, field, size);
    return FBE_STATUS_GENERIC_FAILURE;
}

/*!**************************************************************
 * @fn sas_drive_set_default_vpd_inquiry_b2
 ****************************************************************
 * @brief
 *     Changes the terminator's underlying global page B2 VPD Inquiry data
 *     struct, for a specific drive type.  When a new drive is created
 *     it is initalized with this data.
 *
 * @param drive_type -  Drive type.
 * @param field -       Inquiry field to update.
 * @param data -        New inquiry data.
 * @param size -        size of data.
 *
 * @return fbe_status_t
 *
 * @author
 *  05/07/2015  Deanna Heng - Created.
 *
 ****************************************************************/
static fbe_status_t sas_drive_set_default_vpd_inquiry_b2(fbe_sas_drive_type_t drive_type, fbe_terminator_drive_default_field_t field, const fbe_u8_t *data, fbe_u32_t size)
{
    terminator_sas_drive_vpd_inquiry_page_0xb2_t *dflt_vpd_b2_p = default_drive_vpd_inquiry_b2_table;

    /* find drive type and copy in new inquiry data */
    while (dflt_vpd_b2_p->drive_type != FBE_SAS_DRIVE_LAST){
        if (dflt_vpd_b2_p->drive_type == drive_type){

            if (size != sizeof(dflt_vpd_b2_p->data))
            {
                terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: Invalid field size. field:%d, len %d != %lu\n", 
                                 __FUNCTION__, field, size, (long unsigned int)sizeof(dflt_vpd_b2_p->data));
                return FBE_STATUS_GENERIC_FAILURE;
            }

            fbe_copy_memory(dflt_vpd_b2_p->data, data, size);
            return FBE_STATUS_OK;
        }
        dflt_vpd_b2_p++;
    }

    /*we did not find anything*/
    terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: drive_type %d not found. field:%d len:%d\n", 
                     __FUNCTION__, drive_type, field, size);
    return FBE_STATUS_GENERIC_FAILURE;
}

/*!**************************************************************
 * @fn sas_drive_set_default_inquiry
 ****************************************************************
 * @brief
 *     Changes the terminator's underlying global page F3 VPD Inquiry data
 *     struct, for a specific drive type.  When a new drive is created
 *     it is initalized with this data.
 *
 * @param drive_type -  Drive type.
 * @param field -       Inquiry field to update.
 * @param data -        New inquiry data.
 * @param size -        size of data..
 *
 * @return fbe_status_t
 *
 * @author
 *  12/24/2013  Wayne Garrett - Created.
 *
 ****************************************************************/
static fbe_status_t sas_drive_set_default_inquiry(fbe_sas_drive_type_t drive_type, fbe_terminator_drive_default_field_t field, const fbe_u8_t *data, fbe_u32_t size, 
                                                  fbe_u32_t expected_inq_size, fbe_u32_t inquiry_offset)
{
    terminator_sas_drive_inq_data_t *dflt_inq_p = default_drive_inquiry_table;

    /* validate size */
    if (size != expected_inq_size){
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: Invalid field size. field:%d, len %d != %d\n", 
                         __FUNCTION__, field, size, expected_inq_size);
        return FBE_STATUS_GENERIC_FAILURE;
    }

    /* find drive type and copy in new inquiry data */
    while (dflt_inq_p->drive_type != FBE_SAS_DRIVE_LAST){
        if (dflt_inq_p->drive_type == drive_type){
            fbe_copy_memory(dflt_inq_p->drive_inquiry+inquiry_offset, data, size);
            return FBE_STATUS_OK;
        }
        dflt_inq_p++;
    }

    /*we did not find anything*/
    terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: drive_type %d not found. field:%d len:%d\n", 
                     __FUNCTION__, drive_type, field, size);
    return FBE_STATUS_GENERIC_FAILURE;

}

static fbe_status_t sas_drive_get_default_mode_page_data (fbe_sas_drive_type_t drive_type, terminator_sas_drive_mode_page_data_t **mode_page_data)
{
    *mode_page_data = default_mode_page_table;

    while ((*mode_page_data)->drive_type != FBE_SAS_DRIVE_LAST) {
        if ((*mode_page_data)->drive_type == drive_type) {
            return FBE_STATUS_OK;
        }
        (*mode_page_data)++;
    }

    /*we did not find anything*/
    return FBE_STATUS_GENERIC_FAILURE;
}
static fbe_status_t sas_drive_get_default_mode_page_0x19_data (fbe_sas_drive_type_t drive_type, terminator_sas_drive_mode_page_0x19_data_t **mode_page_0x19_data)
{
    *mode_page_0x19_data = default_mode_page_0x19_table;

    while ((*mode_page_0x19_data)->drive_type != FBE_SAS_DRIVE_LAST) {
        if ((*mode_page_0x19_data)->drive_type == drive_type) {
            return FBE_STATUS_OK;
        }
        (*mode_page_0x19_data)++;
    }

    /*we did not find anything*/
    return FBE_STATUS_GENERIC_FAILURE;
}
static fbe_status_t sas_drive_set_default_mode_page_data (fbe_sas_drive_type_t drive_type, fbe_u8_t *mode_page_data)
{
    terminator_sas_drive_mode_page_data_t *old_mode_page = default_mode_page_table;

    while (old_mode_page->drive_type != FBE_SAS_DRIVE_LAST) {
        if (old_mode_page->drive_type == drive_type) {
            fbe_copy_memory (&old_mode_page->drive_mode_page, mode_page_data, TERMINATOR_SCSI_MODE_PAGE_SIZE);
            return FBE_STATUS_OK;
        }
        old_mode_page ++;
    }

    /*we did not find anything*/
    return FBE_STATUS_GENERIC_FAILURE;
}
static fbe_status_t sas_drive_get_default_mode_page_0x04_data (fbe_sas_drive_type_t drive_type, terminator_sas_drive_mode_page_0x04_data_t **mode_page_0x04_data)
{
    *mode_page_0x04_data = default_mode_page_0x04_table;

    while ((*mode_page_0x04_data)->drive_type != FBE_SAS_DRIVE_LAST) {
        if ((*mode_page_0x04_data)->drive_type == drive_type) {
            return FBE_STATUS_OK;
        }
        (*mode_page_0x04_data)++;
    }

    /*we did not find anything*/
    return FBE_STATUS_GENERIC_FAILURE;
}


/* Begin fbe_terminator_sas_drive_payload */
/*!**************************************************************
 * fbe_sas_drive_is_zero_transfer()
 ****************************************************************
 * @brief
 *  Check if the entire SG list is zeroed blocks.
 *
 * @param xfer_data - Contains the sg list and block count.             
 *
 * @return FBE_TRUE if the sg list is zeroed sectors.
 *                  The sector is all zeros except for ts/crc, which
 *                  are 0x7FFF5EED 
 *         FBE_FALSE if the sg list contains at least one non-zeroed
 *                   sector.
 *
 * @author
 *  6/26/2012 - Created. Rob Foley
 *
 ****************************************************************/

fbe_bool_t fbe_sas_drive_is_zero_transfer(fbe_terminator_io_t * terminator_io,
                                          sas_drive_xfer_data_t *xfer_data)
{
    fbe_sg_element_t *sg_p;
    fbe_block_count_t blocks = xfer_data->blocks;
    fbe_u32_t sg_bytes;
    fbe_u32_t sg_offset = 0;
    fbe_payload_ex_t * payload_p = terminator_io->payload;
    fbe_key_handle_t encryption_handle;

    fbe_payload_ex_get_key_handle(payload_p, &encryption_handle);

    sg_p = xfer_data->pre_sg_p;

    while(sg_p && (blocks > 0) && sg_p->count) {
        sg_bytes = sg_p->count;
        blocks -= (sg_bytes / xfer_data->block_size);
        sg_offset = 0;
        while (sg_bytes > 0) {
            if (!sas_drive_is_zero_pattern_block((sg_p->address + sg_offset), ZERO_PATTERN_SIZE)) {
                return FBE_FALSE;
            }
            /* CBE WRITE SAME */
            /* If xfer_data->sg_p is NULL - there is no user data in the transfer.
                Which meand that we do not have to check the entier SGL
            */
            if(xfer_data->sg_p == NULL){
                /* The first block already has zero pattern and there are no user data */
                return FBE_TRUE;
            }
            sg_offset += ZERO_PATTERN_SIZE;
            sg_bytes -= ZERO_PATTERN_SIZE;
        }
        sg_p++;
    }

    sg_p = xfer_data->sg_p;

    while(sg_p && (blocks > 0) && sg_p->count) {
        sg_bytes = sg_p->count;
        blocks -= (sg_bytes / xfer_data->block_size);
        sg_offset = 0;
        while (sg_bytes > 0) {
            if (!sas_drive_is_zero_pattern_block((sg_p->address + sg_offset), ZERO_PATTERN_SIZE)) {
                return FBE_FALSE;
            }
            sg_offset += ZERO_PATTERN_SIZE;
            sg_bytes -= ZERO_PATTERN_SIZE;
        }
        sg_p++;
    }

    sg_p = xfer_data->post_sg_p;

    while(sg_p && (blocks > 0) && sg_p->count) {
        sg_bytes = sg_p->count;
        blocks -= (sg_bytes / xfer_data->block_size);
        sg_offset = 0;
        while (sg_bytes > 0) {
            if (!sas_drive_is_zero_pattern_block((sg_p->address + sg_offset), ZERO_PATTERN_SIZE)) {
                return FBE_FALSE;
            }
            sg_offset += ZERO_PATTERN_SIZE;
            sg_bytes -= ZERO_PATTERN_SIZE;
        }
        sg_p++;
    }

    return FBE_TRUE;
}
/******************************************
 * end fbe_sas_drive_is_zero_transfer()
 ******************************************/
/*********************************************************************
 *              fbe_terminator_sas_drive_payload ()
 * should be changed to terminator_drive_sas_protocol_entry ()
 *********************************************************************
 *
 *  Description: send an io to a SAS drive
 *
 *  Inputs: io block and drive handle
 *
 *  Return Value: success or failure
 *
 *  History:
 *    09/11/08: guov    created
 *
 *********************************************************************/
fbe_status_t fbe_terminator_sas_drive_payload(fbe_terminator_io_t * terminator_io, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_status_t status;
    fbe_payload_cdb_operation_t * payload_cdb_operation = NULL;
    fbe_u8_t * cdb_opcode;
    sas_drive_xfer_data_t xfer_data;
    fbe_payload_ex_t *payload = terminator_io->payload;
    fbe_time_t start_time = fbe_get_time();
    fbe_time_t elapsed_ms;
    fbe_bool_t b_io_op = FBE_FALSE;
    fbe_key_handle_t encryption_handle;

    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    /* make sure we have the right operation */
    if (payload_cdb_operation == NULL) {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: Error ! Operation must be payload_cdb_operation \n", __FUNCTION__);
        return FBE_STATUS_GENERIC_FAILURE;
    }

    status = fbe_payload_cdb_operation_get_cdb(payload_cdb_operation, &cdb_opcode);
    if (status != FBE_STATUS_OK) {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! fbe_payload_cdb_operation_get_cdb failed\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }

    fbe_payload_cdb_set_scsi_status(payload_cdb_operation, FBE_PAYLOAD_CDB_SCSI_STATUS_GOOD);

    if (fbe_terminator_sas_payload_insert_error(payload_cdb_operation, drive_handle) != FBE_STATUS_OK) {
        return FBE_STATUS_GENERIC_FAILURE;
    }

    fbe_payload_ex_get_key_handle(payload, &encryption_handle);
    if(encryption_handle != FBE_INVALID_KEY_HANDLE){
        terminator_key_info_t *key_info = NULL;
        key_info = (terminator_key_info_t *)(fbe_ptrhld_t)encryption_handle;
        fbe_copy_memory(&terminator_io->keys[0], &key_info->keys[0], sizeof(fbe_u8_t) * FBE_ENCRYPTION_KEY_SIZE);
        terminator_io->b_key_valid = FBE_TRUE;
    }
    else {
        terminator_io->b_key_valid = FBE_FALSE;
    }
    /*check if we got a supported cdb*/
    switch(*cdb_opcode)
    {
    case FBE_SCSI_INQUIRY:
        status = sas_drive_process_payload_inquiry(payload, drive_handle);
        break;
    case FBE_SCSI_READ_CAPACITY:
        status = sas_drive_process_payload_read_capacity (payload, drive_handle);
        break;
    case FBE_SCSI_READ_CAPACITY_16:
        status = sas_drive_process_payload_read_capacity_16 (payload, drive_handle);
        break;
    case FBE_SCSI_MODE_SELECT_6:
        status = sas_drive_process_payload_mode_select_6 (payload, drive_handle);
        break;
    case FBE_SCSI_MODE_SENSE_6:
        status = sas_drive_process_payload_mode_sense_6 (payload, drive_handle);
        break;
    case FBE_SCSI_MODE_SELECT_10:
        status = sas_drive_process_payload_mode_select_10 (payload, drive_handle);
        break;
    case FBE_SCSI_MODE_SENSE_10:
        status = sas_drive_process_payload_mode_sense_10 (payload, drive_handle);
        break;
    case FBE_SCSI_START_STOP_UNIT:
        status = sas_drive_process_payload_start_stop_unit (payload, drive_handle);
        break;
    case FBE_SCSI_TEST_UNIT_READY:
        status = sas_drive_process_payload_tur(payload, drive_handle);
        break;
    case FBE_SCSI_READ_6:        
        if ( (status =sas_drive_payload_prepare_read_6_xfer(payload, 
                                                            drive_handle, 
                                                            &xfer_data)) == FBE_STATUS_OK )
        {
            /* Issue the transfer.*/
            status = sas_drive_process_xfer(terminator_io, drive_handle, &xfer_data);
        }
        b_io_op = FBE_TRUE;
        break;
    case FBE_SCSI_READ_10:        
        if ( (status = sas_drive_payload_prepare_read_10_xfer(payload, 
                                                              drive_handle, 
                                                              &xfer_data)) == FBE_STATUS_OK )
        {
            /* Issue the transfer.*/
            status = sas_drive_process_xfer(terminator_io, drive_handle, &xfer_data);
        }
        b_io_op = FBE_TRUE;
        break;
    case FBE_SCSI_READ_12:
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s: Unsupported opcode: 0x%x\n", 
                         __FUNCTION__, *cdb_opcode);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    case FBE_SCSI_READ_16:       
        if ( (status = sas_drive_payload_prepare_read_16_xfer(payload, 
                                                              drive_handle, 
                                                              &xfer_data)) == FBE_STATUS_OK )
        {
            /* Issue the transfer.*/
            status = sas_drive_process_xfer(terminator_io, drive_handle, &xfer_data);
        }
        b_io_op = FBE_TRUE;
        break;
    case FBE_SCSI_WRITE_6:
        if ( (status = sas_drive_payload_prepare_write_6_xfer(payload, 
                                                              drive_handle, 
                                                              &xfer_data)) == FBE_STATUS_OK )
        {
            /* Issue the transfer.*/
            status = sas_drive_process_xfer(terminator_io, drive_handle, &xfer_data);
        }
        b_io_op = FBE_TRUE;
        break;
    case FBE_SCSI_WRITE_10:
    case FBE_SCSI_WRITE_VERIFY: /* Ten Byte. */
        /* Calculate the lba and blocks */
        if ( (status = sas_drive_payload_prepare_write_10_xfer(payload, 
                                                               drive_handle, 
                                                               &xfer_data)) == FBE_STATUS_OK )
        {
            if (xfer_data.payload_sg_desc_p->repeat_count > 1)
            {
                /* The sg is compressed. Issue the transfer.  */
                status = sas_drive_payload_write_same(terminator_io, drive_handle, FBE_FALSE);
            }
            else if (fbe_sas_drive_is_zero_transfer(terminator_io, &xfer_data))
            {
                /* The sg is compressed. Issue the transfer.  */
                status = sas_drive_payload_write_same(terminator_io, drive_handle, FBE_TRUE);
            }
            else
            {
                /* The sg is not compressed. Issue the transfer.*/
                status = sas_drive_process_xfer(terminator_io, drive_handle, &xfer_data);
            }
        }
        b_io_op = FBE_TRUE;
        break;
    case FBE_SCSI_WRITE_16:
    case FBE_SCSI_WRITE_VERIFY_16:
        /* Calculate the lba and blocks */
        if ( (status = sas_drive_payload_prepare_write_16_xfer(payload, 
                                                               drive_handle, 
                                                               &xfer_data)) == FBE_STATUS_OK )
        {
            if (xfer_data.payload_sg_desc_p->repeat_count > 1)
            {
                /* The sg is compressed. Issue the transfer.  */
                status = sas_drive_payload_write_same(terminator_io, drive_handle, FBE_FALSE);
            }
            else if (fbe_sas_drive_is_zero_transfer(terminator_io, &xfer_data))
            {
                /* The sg is compressed. Issue the transfer.  */
                status = sas_drive_payload_write_same(terminator_io, drive_handle, FBE_TRUE);
            }
            else
            {
                /* The sg is not compressed. Issue the transfer.*/
                status = sas_drive_process_xfer(terminator_io, drive_handle, &xfer_data);
            }
        }
        b_io_op = FBE_TRUE;
        break;
   case FBE_SCSI_WRITE_SAME: /* Ten Byte. */
        status = sas_drive_payload_write_same(terminator_io, drive_handle, FBE_FALSE);
        break;
    case FBE_SCSI_WRITE_SAME_16:
        status = sas_drive_payload_write_same(terminator_io, drive_handle, FBE_FALSE);
        break;
    case FBE_SCSI_UNMAP:
        status = sas_drive_payload_write_same(terminator_io, drive_handle, FBE_TRUE);
        break;
    case FBE_SCSI_RESERVE:
        status = sas_drive_process_payload_reserve (payload, drive_handle);
        break;
    case FBE_SCSI_RESERVE_10:
        status = sas_drive_process_payload_reserve_10 (payload, drive_handle);
        break;
    case FBE_SCSI_RELEASE:
        status = sas_drive_process_payload_release (payload, drive_handle);
        break;
    case FBE_SCSI_RELEASE_10:
        status = sas_drive_process_payload_release_10 (payload, drive_handle);
        break;
    case FBE_SCSI_VERIFY:
    case FBE_SCSI_VERIFY_16:
        status = sas_drive_process_payload_verify (payload, drive_handle);
        break;
    case FBE_SCSI_REASSIGN_BLOCKS:
        status = sas_drive_process_payload_reassign_blocks (payload, drive_handle);
        break;
    case FBE_SCSI_SEND_DIAGNOSTIC:
        status = sas_drive_process_payload_send_diagnostic (payload, drive_handle);
        break;
    case FBE_SCSI_WRITE_BUFFER:
        status = sas_drive_process_payload_write_buffer (terminator_io, drive_handle);
        break;
    case FBE_SCSI_RECEIVE_DIAGNOSTIC:
        status = sas_drive_process_payload_receive_diag (payload, drive_handle);
        break;
    case FBE_SCSI_LOG_SENSE:
        status = sas_drive_process_payload_log_sense(payload, drive_handle);
        break;
    /* Commands currently not required by or not
       applicable to drive simulation
    case FBE_SCSI_WRITE_BUFFER:
    case FBE_SCSI_EXTENDED_SEEK:
    case FBE_SCSI_SEEK:
    case FBE_SCSI_RCV_DIAGNOSTIC:
     */
    default:
        /*! @todo Currently we assume any unknown opcode is a pass-thru request 
         *        that does not need to be serviced.
         */
        terminator_trace(FBE_TRACE_LEVEL_INFO, FBE_TRACE_MESSAGE_ID_INFO,
                         "%s: Ignoring pass-thru opcode: 0x%x cdb length: %d\n", 
                         __FUNCTION__, *cdb_opcode, payload_cdb_operation->cdb_length);
        break;
    }
    elapsed_ms = fbe_get_elapsed_milliseconds(start_time);

    if (elapsed_ms > FBE_SAS_DRIVE_MAX_IO_TIME_MS)
    {
        if (b_io_op)
        {
            /*Split trace to two lines*/
            terminator_trace(FBE_TRACE_LEVEL_WARNING, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                             "%s: elapsed ms %lld for hndl: %p>\n", 
                             __FUNCTION__, (long long)elapsed_ms, drive_handle);
            terminator_trace(FBE_TRACE_LEVEL_WARNING, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                             "%s:op: 0x%x lba: 0x%llx bl: 0x%llx<\n", 
                             __FUNCTION__, *cdb_opcode,
                 (unsigned long long)xfer_data.lba,
                 (unsigned long long)xfer_data.blocks);
        }
        else
        {
            terminator_trace(FBE_TRACE_LEVEL_WARNING, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                             "%s: elapsed ms %lld for hndl: %p opcode: 0x%x\n", 
                             __FUNCTION__, (long long)elapsed_ms, drive_handle,
                 *cdb_opcode);
        }
    }
    fbe_sas_drive_max_io_time_ms = FBE_MAX(fbe_sas_drive_max_io_time_ms, elapsed_ms);
    return status;
}

static fbe_status_t
sas_drive_process_payload_inquiry (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_status_t                        status = FBE_STATUS_GENERIC_FAILURE;
    fbe_u8_t                            *b_ptr = NULL;
    fbe_sg_element_t                    *sg_list;    
    fbe_sas_drive_type_t                drive_type;
    fbe_u8_t                            *drive_serial_number;
    fbe_payload_cdb_operation_t         *payload_cdb_operation = NULL;
    terminator_sas_drive_state_t        drive_state;
    fbe_u8_t                            drive_product_id[TERMINATOR_SCSI_INQUIRY_PRODUCT_ID_SIZE];
    fbe_u8_t                            *inquiry_p = NULL;
    fbe_u8_t                            *vpd_inquiry_f3_p = NULL;
    fbe_u8_t                            *vpd_inquiry_b2_p = NULL;
    fbe_u32_t                           vpd_size = 0;
    fbe_u8_t                            *vpd_inquiry_c0_p = NULL;
    fbe_terminator_sas_drive_info_t drive_info = {0};

    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    if (payload_cdb_operation == NULL)
    {
        terminator_trace(FBE_TRACE_LEVEL_WARNING,
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s: fbe_payload_ex_get_cdb_operation() failed.\n",
                         __FUNCTION__);

        return FBE_STATUS_GENERIC_FAILURE;
    }

    terminator_get_sas_drive_info(drive_handle, &drive_info);

    /* get the drive type thru the handle */
    status = terminator_drive_get_type(drive_handle, &drive_type);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_WARNING,
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s: terminator_drive_get_type() failed.\n",
                         __FUNCTION__);

        return status;
    }

    /* get the drive serial number thru the handle */
    status = terminator_drive_get_serial_number(drive_handle, &drive_serial_number);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_WARNING,
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s: terminator_drive_get_serial_number() failed.\n",
                         __FUNCTION__);

        return status;
    }

    status = terminator_drive_get_state(drive_handle, &drive_state);
    if (status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_WARNING,
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s: terminator_drive_get_state() failed.\n",
                         __FUNCTION__);

        return status;
    }

    if (drive_state == TERMINATOR_SAS_DRIVE_SELECT_TIMEOUT)
    {
        terminator_trace(FBE_TRACE_LEVEL_WARNING,
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s: drive_state is TERMINATOR_SAS_DRIVE_SELECT_TIMEOUT\n",
                         __FUNCTION__);

        terminator_trace(FBE_TRACE_LEVEL_WARNING,
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s: set request status to FBE_PORT_REQUEST_STATUS_SELECTION_TIMEOUT\n",
                         __FUNCTION__);

        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SELECTION_TIMEOUT);

        return FBE_STATUS_OK;
    }


    fbe_payload_ex_get_sg_list(payload, &sg_list, NULL);

    b_ptr = (fbe_u8_t *)sg_list->address;
    if (sg_list->count == 0){
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: sg list count is 0, can't do inqury\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    }

    if(payload_cdb_operation->cdb[1] == 1) /* EVPD set */
    {
        /* Get vital product data pages */
     
        /* Support page 0x00 "Supported Pages" */ 
        if(payload_cdb_operation->cdb[2] == 0x00)
        {
            fbe_zero_memory(b_ptr, TERMINATOR_SCSI_INQUIRY_DATA_SIZE);
            b_ptr[1] = 0x00; /* Page Code */
            b_ptr[3] = 0x04; /* Page Length */
            b_ptr[4] = 0x00; /* Page 0x00 Supported */
            b_ptr[5] = 0xC0; /* Page 0xC0 Supported */            
            b_ptr[6] = 0xF3; /* Page 0xF3 Supported */
            b_ptr[7] = 0xB2; /* Page 0xB2 Supported */
            fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
            return FBE_STATUS_OK;
        }
        /* Support page 0xC0 "Servo Code Revision" */ 
        if(payload_cdb_operation->cdb[2] == 0xC0)
        {
            default_drive_vpd_inquiry_c0_table;

            vpd_inquiry_c0_p = sas_drive_get_vpd_inquiry_c0((terminator_drive_t*)drive_handle, &vpd_size);

            if (vpd_inquiry_c0_p == NULL || vpd_size > sg_list->count || vpd_size == 0) {
                terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                                 "%s:Error !! VPD Inquiry page:0x%x not found or invalid\n", __FUNCTION__, payload_cdb_operation->cdb[2]);
                fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
                return FBE_STATUS_GENERIC_FAILURE;
            }

            fbe_zero_memory(b_ptr, sg_list->count);
            fbe_copy_memory(b_ptr, vpd_inquiry_c0_p, vpd_size);
            fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);       
            return FBE_STATUS_OK;
        }
        /* Support page 0xF3 */         
        if(payload_cdb_operation->cdb[2] == 0xF3)
        {            
            vpd_inquiry_f3_p = sas_drive_get_vpd_inquiry_f3((terminator_drive_t*)drive_handle, &vpd_size);

            if (vpd_inquiry_f3_p == NULL || vpd_size > sg_list->count || vpd_size == 0) {
                terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                                 "%s:Error !! VPD Inquiry page:0x%x not found or invalid\n", __FUNCTION__, payload_cdb_operation->cdb[2]);
                fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
                return FBE_STATUS_GENERIC_FAILURE;
            }

            fbe_zero_memory(b_ptr, sg_list->count);
            fbe_copy_memory(b_ptr, vpd_inquiry_f3_p, vpd_size);

            fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
            return FBE_STATUS_OK;
        }

        /* Support page 0xB2 */          
        if(payload_cdb_operation->cdb[2] == 0xB2)
        {            
            vpd_inquiry_b2_p = sas_drive_get_vpd_inquiry_b2((terminator_drive_t*)drive_handle, &vpd_size);

            if (vpd_inquiry_b2_p == NULL || vpd_size > sg_list->count || vpd_size == 0) {
                terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                                 "%s:Error !! VPD Inquiry page:0x%x not found or invalid\n", __FUNCTION__, payload_cdb_operation->cdb[2]);
                fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
                return FBE_STATUS_GENERIC_FAILURE;
            }

            fbe_zero_memory(b_ptr, sg_list->count);
            fbe_copy_memory(b_ptr, vpd_inquiry_b2_p, vpd_size);

            fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
            return FBE_STATUS_OK;
        }

        return FBE_STATUS_GENERIC_FAILURE;
    }

        
    /* place the full inquiry data in the buffer 
    */
    inquiry_p = sas_drive_get_inquiry((terminator_drive_t*)drive_handle);
    if (inquiry_p == NULL)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s:Error !! Inquiry page not found\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    }
    fbe_copy_memory (b_ptr, inquiry_p, TERMINATOR_SCSI_INQUIRY_DATA_SIZE);


    /*Place the Serial Number of disks in the buffer*/
    fbe_copy_memory (b_ptr + TERMINATOR_SCSI_INQUIRY_SERIAL_NUMBER_OFFSET, drive_serial_number, TERMINATOR_SCSI_INQUIRY_SERIAL_NUMBER_SIZE);

    /* AR489693: If product_id is valid, place it in buffer, or else use the hardcoded product_id */
    memset(drive_product_id, 0, sizeof(drive_product_id));
    status = terminator_get_drive_product_id(drive_handle, drive_product_id);
    if (FBE_STATUS_OK == status)
    {
        if (FBE_STATUS_OK == terminator_verify_drive_product_id(drive_handle, drive_product_id))
        {
            fbe_copy_memory(b_ptr + FBE_SCSI_INQUIRY_PRODUCT_ID_OFFSET, drive_product_id, FBE_SCSI_INQUIRY_PRODUCT_ID_SIZE);
        }
        else
        {
            fbe_u8_t invalid_product_id[FBE_SCSI_INQUIRY_PRODUCT_ID_SIZE+1] = {0};
            fbe_copy_memory(invalid_product_id, drive_product_id, FBE_SCSI_INQUIRY_PRODUCT_ID_SIZE);
            terminator_trace(FBE_TRACE_LEVEL_WARNING, FBE_TRACE_MESSAGE_ID_INFO, "terminator: %s: %d_%d_%d Ignore unknown drive product_id:%s\n", 
                             __FUNCTION__, drive_info.backend_number, drive_info.encl_number, drive_info.slot_number, invalid_product_id);
        }
    }

    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);

    return status;
}

static fbe_status_t
sas_drive_process_payload_read_capacity (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_status_t status = FBE_STATUS_GENERIC_FAILURE;
    fbe_u8_t                                    *b_ptr = NULL;
    fbe_sg_element_t                            *sg_list;
    fbe_payload_cdb_operation_t         *payload_cdb_operation = NULL;
    terminator_drive_t * drive = (terminator_drive_t *)drive_handle;
    fbe_lba_t last_valid_lba;
    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);


    fbe_payload_ex_get_sg_list(payload, &sg_list, NULL);

    b_ptr = (fbe_u8_t *)sg_list->address;
    if (sg_list->count != FBE_SCSI_READ_CAPACITY_DATA_SIZE){
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: sg list count is %d, can't do read capacity.\n", __FUNCTION__ , sg_list->count);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    }

    /* Drives return capacity as last addressable LBA, where LBAs start a 0.  Convert capacity to last LBA */
    last_valid_lba = drive->capacity - 1;

    if((last_valid_lba) > 0xffffffff){	
        /* capacity */
        b_ptr[0] = 0xFF;
        b_ptr[1] = 0xFF;
        b_ptr[2] = 0xFF;
        b_ptr[3] = 0xFF;
    } else {
        /* Fill buffer with correct read capacity data */
        b_ptr[0] = (fbe_u8_t)(((last_valid_lba) >> 24) & 0xFF);
        b_ptr[1] = (fbe_u8_t)(((last_valid_lba) >> 16) & 0xFF);
        b_ptr[2] = (fbe_u8_t)(((last_valid_lba) >> 8) & 0xFF);
        b_ptr[3] = (fbe_u8_t)((last_valid_lba) & 0xFF);
    }

    /* block size */
    b_ptr[4] = (fbe_u8_t)((drive->block_size >> 24) & 0xFF);
    b_ptr[5] = (fbe_u8_t)((drive->block_size >> 16) & 0xFF);
    b_ptr[6] = (fbe_u8_t)((drive->block_size >> 8) & 0xFF);
    b_ptr[7] = (fbe_u8_t)(drive->block_size & 0xFF);

    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);

    return status;
}
static fbe_status_t
sas_drive_process_payload_read_capacity_16 (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_status_t status = FBE_STATUS_GENERIC_FAILURE;
    fbe_u8_t                                    *b_ptr = NULL;
    fbe_sg_element_t                            *sg_list;
    //terminator_sas_drive_read_capacity_data_16_t   *rcap_data = NULL;
    //fbe_sas_drive_type_t                        drive_type;
    fbe_payload_cdb_operation_t         *payload_cdb_operation = NULL;
    terminator_drive_t * drive = (terminator_drive_t *)drive_handle;
    fbe_lba_t last_valid_lba;

    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
#if 0
    /* get the drive type thru the handle */
    status = terminator_drive_get_type(drive_handle, &drive_type);

    /*get the correct read_capacity data for this drive type*/
    status = sas_drive_get_read_capacity_data_16 (drive_type, drive, &rcap_data);
    if (status != FBE_STATUS_OK) {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! Illegal drive type passed in: %d\n", __FUNCTION__, drive_type);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }
#endif

    fbe_payload_ex_get_sg_list(payload, &sg_list, NULL);

    b_ptr = (fbe_u8_t *)sg_list->address;
    if (sg_list->count != FBE_SCSI_READ_CAPACITY_DATA_SIZE_16){
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: sg list count is %d, can't do read capacity.\n", __FUNCTION__ , sg_list->count);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    }

    /* Drives return capacity as last addressable LBA, where LBAs start a 0.  Convert capacity to last LBA */
    last_valid_lba = drive->capacity - 1;

    /* Fill buffer with correct read capacity data */
    /* capacity */
    b_ptr[0] = (fbe_u8_t)((last_valid_lba >> 56) & 0xFF);
    b_ptr[1] = (fbe_u8_t)((last_valid_lba >> 48) & 0xFF);
    b_ptr[2] = (fbe_u8_t)((last_valid_lba >> 40) & 0xFF);
    b_ptr[3] = (fbe_u8_t)((last_valid_lba >> 32) & 0xFF);
    b_ptr[4] = (fbe_u8_t)((last_valid_lba >> 24) & 0xFF);
    b_ptr[5] = (fbe_u8_t)((last_valid_lba >> 16) & 0xFF);
    b_ptr[6] = (fbe_u8_t)((last_valid_lba >> 8) & 0xFF);
    b_ptr[7] = (fbe_u8_t)(last_valid_lba & 0xFF);
    /* block size */
    b_ptr[8] = (fbe_u8_t)((drive->block_size >> 24) & 0xFF);
    b_ptr[9] = (fbe_u8_t)((drive->block_size >> 16) & 0xFF);
    b_ptr[10] = (fbe_u8_t)((drive->block_size >> 8) & 0xFF);
    b_ptr[11] = (fbe_u8_t)(drive->block_size & 0xFF);

#if 0
    /* place the full read capacity data in the buffer */
    fbe_copy_memory (b_ptr, rcap_data->drive_read_capacity, FBE_SCSI_READ_CAPACITY_DATA_SIZE_16);
#endif

    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);

    return status;
}

static fbe_status_t
sas_drive_process_payload_mode_sense_6 (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_status_t                        status = FBE_STATUS_GENERIC_FAILURE;
    fbe_u8_t                            *b_ptr = NULL;
    fbe_sg_element_t                    *sg_list;
    fbe_sas_drive_type_t                drive_type;
    terminator_sas_drive_mode_page_data_t       *mode_page_data = NULL;
    terminator_sas_drive_mode_page_0x19_data_t  *mode_page_0x19_data = NULL;
    terminator_sas_drive_mode_page_0x04_data_t  *mode_page_0x04_data = NULL;
    fbe_payload_cdb_operation_t         *payload_cdb_operation = NULL;

    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    
    /* get the drive type thru the handle */
    status = terminator_drive_get_type(drive_handle, &drive_type);

    if ((payload_cdb_operation->cdb[2] == 0x19) && (payload_cdb_operation->cdb[3] == 0x01))
    {
        /* Mode sense the long form of the SAS mode page 0x19 */  
        /* CDB is 6 bytes:
         * cdb[0] = 0x1A  SCSI Command - mode sense 6
         * cdb[1] = 0x08  Don't include block descriptor
         * cdb[2] = 0x19  Mode Page
         * cdb[3] = 0x01  Subpage
         * cdb[4] = 0xFF  Allocation Length
         * cdb[5] = 0x00
         */

        /*get the correct mode page 0x19 data for this drive type*/
        status = sas_drive_get_default_mode_page_0x19_data (drive_type, &mode_page_0x19_data);
        if (status != FBE_STATUS_OK) {
            terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! Illegal drive type for mode page 0x19: %d\n", __FUNCTION__, drive_type);
            fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
            return status;
        }

        fbe_payload_ex_get_sg_list(payload, &sg_list, NULL);

        b_ptr = (fbe_u8_t *)sg_list->address;
        if (sg_list->count == 0){
            terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: sg list count is 0, can't do mode page 0x19\n", __FUNCTION__);
            fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
            return FBE_STATUS_GENERIC_FAILURE;
        }

        /* place the full mode page data in the buffer */
        fbe_copy_memory (b_ptr, mode_page_0x19_data->drive_mode_page, TERMINATOR_SCSI_MODE_PAGE_0x19_SIZE);
    }
    else if ((payload_cdb_operation->cdb[2] == 0x04) && (payload_cdb_operation->cdb[3] == 0x0))
    {
        status = sas_drive_get_default_mode_page_0x04_data(drive_type, &mode_page_0x04_data);
        if (status != FBE_STATUS_OK) {
            terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! Illegal drive type for mode page 0x04: %d\n", __FUNCTION__, drive_type);
            fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
            return status;
        }

        fbe_payload_ex_get_sg_list(payload, &sg_list, NULL);

        b_ptr = (fbe_u8_t *)sg_list->address;
        if ((sg_list->count < TERMINATOR_SCSI_MODE_PAGE_0x04_SIZE)){
            terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: sg list count is %d, can't do mode page 0x04\n", __FUNCTION__, sg_list->count);
            fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
            return FBE_STATUS_GENERIC_FAILURE;
        }

	    /* place the full mode page data in the buffer */
        fbe_copy_memory (b_ptr, mode_page_0x04_data->drive_mode_page, TERMINATOR_SCSI_MODE_PAGE_0x04_SIZE);
    }
    else
    {
        /* Mode sense all mode pages and the block descriptor at one time*/
        /* CDB is 6 bytes:
         * cdb[0] = 0x1A  SCSI Command - mode sense 6
         * cdb[1] = 0x00  Return block descriptor
         * cdb[2] = 0xBF or 0xFF  Return ALL default pages or ALL saved pages
         * cdb[3] = 0x00  Subpage
         * cdb[4] = 0xFF  Allocation Length
         * cdb[5] = 0x00
         */

        /*get the correct mode page data for this drive type*/
        status = sas_drive_get_default_mode_page_data (drive_type, &mode_page_data);
        if (status != FBE_STATUS_OK) {
            terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! Illegal drive type passed in: %d\n", __FUNCTION__, drive_type);
            fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
            return status;
        }

        fbe_payload_ex_get_sg_list(payload, &sg_list, NULL);

        b_ptr = (fbe_u8_t *)sg_list->address;
        if (sg_list->count == 0){
            terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: sg list count is 0, can't do inqury\n", __FUNCTION__);
            fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
            return FBE_STATUS_GENERIC_FAILURE;
        }

        /* place the full mode page data in the buffer */
        fbe_copy_memory (b_ptr, mode_page_data->drive_mode_page, TERMINATOR_SCSI_MODE_PAGE_SIZE);
    }   
    
    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);

    return status;
}

static fbe_status_t
sas_drive_process_payload_mode_select_6 (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_status_t                        status = FBE_STATUS_GENERIC_FAILURE;
    fbe_sg_element_t                    *sg_list;
    fbe_sas_drive_type_t                drive_type;
    fbe_u8_t                            *mode_page_data = NULL;
    fbe_payload_cdb_operation_t         *payload_cdb_operation = NULL;

    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);

    /* get the drive type thru the handle */
    status = terminator_drive_get_type(drive_handle, &drive_type);

    /* get the sg_list from the payload */
    fbe_payload_ex_get_sg_list(payload, &sg_list, NULL);

    mode_page_data = (fbe_u8_t *)sg_list->address;
    if (sg_list->count == 0){
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: sg list count is 0, can't do inqury\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    }

    /*set the correct mode page data for this drive type*/
    status = sas_drive_set_default_mode_page_data (drive_type, mode_page_data);
    if (status != FBE_STATUS_OK) {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! Illegal drive type passed in: %d\n", __FUNCTION__, drive_type);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }
    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
    return status;
}

static fbe_status_t
sas_drive_process_payload_mode_sense_10 (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_status_t                        status = FBE_STATUS_GENERIC_FAILURE;
    fbe_u8_t                            *b_ptr = NULL;
    fbe_sg_element_t                    *sg_list;
    fbe_u8_t                            *mode_page_data = NULL;
    fbe_u32_t                           mode_page_data_size;
    fbe_payload_cdb_operation_t         *payload_cdb_operation = NULL;

    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    
    fbe_payload_ex_get_sg_list(payload, &sg_list, NULL);

    b_ptr = (fbe_u8_t *)sg_list->address;
    if (sg_list->count == 0){
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: sg list count is 0, can't do mode sense\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    }

    /* place the full mode page data in the buffer */
    mode_page_data = sas_drive_get_mode_page((terminator_drive_t*)drive_handle, &mode_page_data_size);
    if (mode_page_data == NULL)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s:Error !! Mode Page not found\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    }

    fbe_copy_memory (b_ptr, mode_page_data, mode_page_data_size);
    fbe_payload_cdb_set_transferred_count(payload_cdb_operation, mode_page_data_size);    

    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN);  /* underrun is expected since PDO always provides a larger buffer than needed.*/

    return status;
}

static fbe_status_t
sas_drive_process_payload_mode_select_10 (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_status_t                        status = FBE_STATUS_GENERIC_FAILURE;
    fbe_sg_element_t                    *sg_list;
    fbe_u8_t                            *b_ptr = NULL;
    fbe_u8_t                            *mode_page_data = NULL;
    fbe_u32_t                           mode_page_data_size;
    fbe_payload_cdb_operation_t         *payload_cdb_operation = NULL;

    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);

    /* get the sg_list from the payload */
    fbe_payload_ex_get_sg_list(payload, &sg_list, NULL);

    b_ptr = (fbe_u8_t *)sg_list->address;
    if (sg_list->count == 0){
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: sg list count is 0\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    }

    mode_page_data = sas_drive_get_mode_page((terminator_drive_t*)drive_handle, &mode_page_data_size);
    if (mode_page_data == NULL || sg_list->count < mode_page_data_size)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s:Error !! Mode Page not found or invalid\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    }

    /*set the correct mode page data for this drive type except mode parameter header*/
    fbe_copy_memory(mode_page_data+8, b_ptr+8, mode_page_data_size-8);
    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
    return status;
}


static fbe_status_t
sas_drive_process_payload_start_stop_unit (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_payload_cdb_operation_t * payload_cdb_operation = NULL;
    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
    return FBE_STATUS_OK;
}

static fbe_status_t
sas_drive_process_payload_tur(fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_status_t                        status = FBE_STATUS_GENERIC_FAILURE;
    fbe_payload_cdb_operation_t         *payload_cdb_operation = NULL;

    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    status = fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
    return status;
}

static fbe_status_t
sas_drive_process_payload_reserve (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_payload_cdb_operation_t * payload_cdb_operation = NULL;
    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
    return FBE_STATUS_OK;
}

static fbe_status_t
sas_drive_process_payload_reserve_10 (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_payload_cdb_operation_t * payload_cdb_operation = NULL;
    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
    return FBE_STATUS_OK;
}

static fbe_status_t
sas_drive_process_payload_release (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_payload_cdb_operation_t * payload_cdb_operation = NULL;
    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
    return FBE_STATUS_OK;
}

static fbe_status_t
sas_drive_process_payload_release_10 (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_payload_cdb_operation_t * payload_cdb_operation = NULL;
    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
    return FBE_STATUS_OK;
}

static fbe_status_t
sas_drive_process_payload_verify (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_payload_cdb_operation_t * payload_cdb_operation_p = NULL;    
    terminator_drive_t * drive = (terminator_drive_t *)drive_handle;
    fbe_lba_t lba;
    fbe_block_count_t blocks;
    
    payload_cdb_operation_p = fbe_payload_ex_get_cdb_operation(payload);
    /* make sure we have the right operation */
    if (payload_cdb_operation_p == NULL) {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: Error ! Operation must be payload_cdb_operation \n", __FUNCTION__);
        return FBE_STATUS_GENERIC_FAILURE;
    }


    lba = fbe_get_cdb_lba(payload_cdb_operation_p);
    blocks = fbe_get_cdb_blocks(payload_cdb_operation_p);

    /* Check if xfer has valid LBA range, should not exceed the drive capacity */
    if (lba + blocks > drive_get_capacity(drive)) {
        fbe_u8_t *sense_buffer_p = NULL;
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s drive %d_%d_%d attempt to seek past end of disk (0x%llx).\n",
                         __FUNCTION__, drive->backend_number, drive->encl_number, drive->slot_number,
                         (unsigned long long)drive_get_capacity(drive));
        terminator_drive_increment_error_count(drive);
        /* If the seek fails return the same error a drive would to indicate
         * that something was wrong with the cdb (it was beyond the capacity).
         */
        fbe_payload_cdb_set_scsi_status(payload_cdb_operation_p, FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION);
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_ERROR);
        fbe_payload_cdb_operation_get_sense_buffer(payload_cdb_operation_p, &sense_buffer_p);
        sas_drive_build_sense_data(sense_buffer_p,
                                   FBE_SCSI_SENSE_KEY_ILLEGAL_REQUEST,
                                   FBE_SCSI_ASC_INVALID_FIELD_IN_CDB,
                                   FBE_SCSI_ASCQ_NO_ADDITIONAL_SENSE_INFO);

        return FBE_STATUS_GENERIC_FAILURE;
    }

    fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_SUCCESS);
    return FBE_STATUS_OK;
}

static fbe_status_t
sas_drive_process_payload_reassign_blocks (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_payload_cdb_operation_t * payload_cdb_operation = NULL;
    fbe_key_handle_t encryption_handle;

    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    /* Make sure we dont have a valid handle.  */
    fbe_payload_ex_get_key_handle(payload, &encryption_handle);
    if(encryption_handle != FBE_INVALID_KEY_HANDLE)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s:Key Handle not invalid %llx\n", __FUNCTION__, (unsigned long long)encryption_handle);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    }
    
    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
    return FBE_STATUS_OK;
}

static fbe_status_t
sas_drive_process_payload_send_diagnostic (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_payload_cdb_operation_t * payload_cdb_operation = NULL;
    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
    return FBE_STATUS_OK;
}
static fbe_status_t
sas_drive_payload_prepare_xfer(fbe_payload_ex_t * payload,
    fbe_terminator_device_ptr_t drive_handle,
    sas_drive_xfer_data_t *xfer_data, fbe_bool_t cdb_flag)
{
    fbe_status_t                        status = FBE_STATUS_GENERIC_FAILURE;
    fbe_u32_t                           port_number;
    fbe_u32_t                           enclosure_number;
    fbe_u32_t                           slot_number;
    fbe_payload_cdb_operation_t       * payload_cdb_operation = NULL;
    fbe_sas_drive_type_t drive_type;
    //terminator_sas_drive_read_capacity_data_t *rcap_data;
    //terminator_sas_drive_read_capacity_data_16_t *rcap_data_16;
    terminator_drive_t * drive = (terminator_drive_t *)drive_handle;
    //fbe_block_size_t block_size;
#if 0
    int count = 0;
#endif

    /* Get cdb operation */
    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);

    status = terminator_get_port_index(drive_handle, &port_number);
    if (status != FBE_STATUS_OK) {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! can not get port number thru drive handle\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }
    status = terminator_get_drive_enclosure_number(drive_handle, &enclosure_number);
    if (status != FBE_STATUS_OK) {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! can not get enclosure_number thru drive handle\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }
    status = terminator_get_drive_slot_number(drive_handle, &slot_number);
    if (status != FBE_STATUS_OK) {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! can not get slot_number thru drive handle\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }
    xfer_data->drive_name[0] = 0;
#if 0
    /* This has a big performance impact */

    count = _snprintf(xfer_data->drive_name, sizeof(xfer_data->drive_name), TERMINATOR_DISK_NAME_FORMAT_STRING, port_number, enclosure_number, slot_number);
    if (( count < 0 ) || (sizeof(xfer_data->drive_name) == count )) {
         
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    }
#endif

    terminator_drive_get_type( drive_handle, &drive_type);

#if 0
    if (cdb_flag == FBE_TRUE) {
        sas_drive_get_read_capacity_data_16 (drive_type, drive, &rcap_data_16);

        block_size = 0;
        block_size |= rcap_data_16->drive_read_capacity[8] << 8;
        block_size |= rcap_data_16->drive_read_capacity[9] << 8;
        block_size |= rcap_data_16->drive_read_capacity[10] << 8;
        block_size |= rcap_data_16->drive_read_capacity[11];
    }
    else {
         sas_drive_get_read_capacity_data (drive_type, drive, &rcap_data);
            drive
         block_size = 0;
         block_size |= rcap_data->drive_read_capacity[6] << 8;
         block_size |= rcap_data->drive_read_capacity[7];
    }
#endif

    xfer_data->block_size = drive->block_size; /*payload_cdb_operation->block_size*/
    /* FIXME!!! what's the sg_p in payload???*/
    //xfer_data->sg_desc_p = &payload_cdb_operation->payload_sg_descriptor;
    fbe_payload_ex_get_sg_list(payload, &xfer_data->sg_p, NULL);
    fbe_payload_ex_get_pre_sg_list(payload, &xfer_data->pre_sg_p);
    fbe_payload_ex_get_post_sg_list(payload, &xfer_data->post_sg_p);

    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
    return status;
}

/* this funtion needs some clean up */
static fbe_status_t
sas_drive_payload_prepare_read_6_xfer(fbe_payload_ex_t * payload,
    fbe_terminator_device_ptr_t drive_handle,
    sas_drive_xfer_data_t *xfer_data)
{
    fbe_payload_cdb_operation_t       * payload_cdb_operation = NULL;

    /* Get cdb operation */
    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);

    /* Calculate the lba and blocks. */
    xfer_data->lba = fbe_get_six_byte_cdb_lba(&payload_cdb_operation->cdb[0]);
    xfer_data->blocks = fbe_get_six_byte_cdb_blocks(&payload_cdb_operation->cdb[0]);
    /* set the direction */
    xfer_data->direction_in = TRUE;
    /* fill in the common data */
    return (sas_drive_payload_prepare_xfer(payload, drive_handle, xfer_data, FBE_FALSE));
}

static fbe_status_t
sas_drive_payload_prepare_read_10_xfer(fbe_payload_ex_t * payload,
    fbe_terminator_device_ptr_t drive_handle,
    sas_drive_xfer_data_t *xfer_data)
{
    fbe_payload_cdb_operation_t       * payload_cdb_operation = NULL;

    /* Get cdb operation */
    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);

    /* Calculate the lba and blocks. */
    xfer_data->lba = fbe_get_ten_byte_cdb_lba(&payload_cdb_operation->cdb[0]);
    xfer_data->blocks = fbe_get_ten_byte_cdb_blocks(&payload_cdb_operation->cdb[0]);
    /* set the direction */
    xfer_data->direction_in = TRUE;
    /* fill in the common data */
    return (sas_drive_payload_prepare_xfer(payload, drive_handle, xfer_data, FBE_FALSE));
}
static fbe_status_t
sas_drive_payload_prepare_read_16_xfer(fbe_payload_ex_t * payload,
    fbe_terminator_device_ptr_t drive_handle,
    sas_drive_xfer_data_t *xfer_data)
{
    fbe_payload_cdb_operation_t       * payload_cdb_operation = NULL;

    /* Get cdb operation */
    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);

    /* Calculate the lba and blocks. */
    xfer_data->lba = fbe_get_sixteen_byte_cdb_lba(&payload_cdb_operation->cdb[0]);
    xfer_data->blocks = fbe_get_sixteen_byte_cdb_blocks(&payload_cdb_operation->cdb[0]);
    /* set the direction */
    xfer_data->direction_in = TRUE;
    /* fill in the common data */
    return (sas_drive_payload_prepare_xfer(payload, drive_handle, xfer_data, FBE_FALSE));
}
static fbe_status_t
sas_drive_payload_prepare_write_6_xfer(fbe_payload_ex_t * payload,
    fbe_terminator_device_ptr_t drive_handle,
    sas_drive_xfer_data_t *xfer_data)
{
    fbe_payload_cdb_operation_t       * payload_cdb_operation = NULL;

    /* Get cdb operation */
    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);

    /* Calculate the lba and blocks. */
    xfer_data->lba = fbe_get_six_byte_cdb_lba(&payload_cdb_operation->cdb[0]);
    xfer_data->blocks = fbe_get_six_byte_cdb_blocks(&payload_cdb_operation->cdb[0]);
    /* set the direction */
    xfer_data->direction_in = FALSE;
    /* fill in the common data */
    return (sas_drive_payload_prepare_xfer(payload, drive_handle, xfer_data, FBE_FALSE));
}

static fbe_status_t
sas_drive_payload_prepare_write_10_xfer(fbe_payload_ex_t * payload,
    fbe_terminator_device_ptr_t drive_handle,
    sas_drive_xfer_data_t *xfer_data)
{
    fbe_payload_cdb_operation_t       * payload_cdb_operation = NULL;

    /* Get cdb operation */
    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);

    /* Calculate the lba and blocks. */
    xfer_data->lba = fbe_get_ten_byte_cdb_lba(&payload_cdb_operation->cdb[0]);
    xfer_data->blocks = fbe_get_ten_byte_cdb_blocks(&payload_cdb_operation->cdb[0]);
    xfer_data->payload_sg_desc_p = &payload_cdb_operation->payload_sg_descriptor;
    /* set the direction */
    xfer_data->direction_in = FALSE;
    /* fill in the common data */
    return (sas_drive_payload_prepare_xfer(payload, drive_handle, xfer_data, FBE_FALSE));
}
static fbe_status_t
sas_drive_payload_prepare_write_16_xfer(fbe_payload_ex_t * payload,
    fbe_terminator_device_ptr_t drive_handle,
    sas_drive_xfer_data_t *xfer_data)
{
    fbe_payload_cdb_operation_t       * payload_cdb_operation = NULL;

    /* Get cdb operation */
    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);

    /* Calculate the lba and blocks. */
    xfer_data->lba = fbe_get_sixteen_byte_cdb_lba(&payload_cdb_operation->cdb[0]);
    xfer_data->blocks = fbe_get_sixteen_byte_cdb_blocks(&payload_cdb_operation->cdb[0]);
    xfer_data->payload_sg_desc_p = &payload_cdb_operation->payload_sg_descriptor;
    /* set the direction */
    xfer_data->direction_in = FALSE;
    /* fill in the common data */
    return (sas_drive_payload_prepare_xfer(payload, drive_handle, xfer_data, FBE_FALSE));
}

static void sas_drive_build_sense_data(
    fbe_u8_t *sense_info_buffer,
    fbe_scsi_sense_key_t sense_key,
    fbe_scsi_additional_sense_code_t ASC,
    fbe_scsi_additional_sense_code_qualifier_t ASCQ)
{
    memset(sense_info_buffer, 0, (FBE_PAYLOAD_CDB_SENSE_INFO_BUFFER_SIZE * sizeof(fbe_u8_t)));
    sense_info_buffer[FBE_SCSI_SENSE_DATA_RESPONSE_CODE_OFFSET] = 0x70;
    sense_info_buffer[FBE_SCSI_SENSE_DATA_SENSE_KEY_OFFSET] = sense_key;
    sense_info_buffer[FBE_SCSI_SENSE_DATA_ADDL_SENSE_LENGTH_OFFSET] = 10;
    sense_info_buffer[FBE_SCSI_SENSE_DATA_ASC_OFFSET] = ASC;
    sense_info_buffer[FBE_SCSI_SENSE_DATA_ASCQ_OFFSET] = ASCQ;

    return;
}


fbe_status_t cdb_mark_payload_abort(fbe_payload_ex_t *payload)
{
    fbe_status_t status;
    fbe_payload_cdb_operation_t * payload_cdb_operation = NULL;

    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    /* make sure we have the right operation */
    if (payload_cdb_operation == NULL) {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: Error ! Operation must be payload_cdb_operation \n", __FUNCTION__);
        return FBE_STATUS_GENERIC_FAILURE;
    }
    status = fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_DEVICE_NOT_LOGGED_IN);
    return status;
}

static fbe_status_t
sas_drive_process_payload_write_buffer (fbe_terminator_io_t * terminator_io, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_payload_ex_t                * payload = terminator_io->payload;
    fbe_payload_cdb_operation_t     * payload_cdb_operation = NULL;
    fbe_status_t                    status;
    fbe_sas_drive_type_t            drive_type;    
    write_buffer_timer_context_t    context;    

    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    status = terminator_drive_get_type(drive_handle, &drive_type);
    
    terminator_io->device_ptr = (void*)drive_handle;
    context.terminator_io = terminator_io;        

    status = terminator_sas_drive_write_buffer_set_timer(2000, context);
    if (status != FBE_STATUS_OK) {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! Payload write buffer set timer failed.\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }

    return FBE_STATUS_PENDING;
}

void sas_drive_process_payload_write_buffer_timer_func(write_buffer_timer_context_t *context)
{
    fbe_payload_cdb_operation_t   *payload_cdb_operation = NULL;
    fbe_sg_element_t              *sg_list = NULL;
    fbe_payload_ex_t              *payload = context->terminator_io->payload;
    fbe_terminator_sas_drive_fw_image_t *image = NULL;
    fbe_terminator_device_ptr_t    drive_handle = context->terminator_io->device_ptr;
    terminator_drive_t            *drive_p = (terminator_drive_t*)drive_handle;
    fbe_u8_t *inquiry_p = NULL;
    fbe_u8_t *vpd_inquiry_f3_p = NULL;
    //fbe_u8_t *vpd_inquiry_b2_p = NULL;
    fbe_u32_t vpd_size = 0;
   

    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);    
    fbe_payload_ex_get_sg_list(payload, &sg_list, NULL);

    if (sg_list->count != sizeof(fbe_terminator_sas_drive_fw_image_t))
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! invalid FW image size %d != %lu bytes\n", __FUNCTION__, sg_list->count, (long unsigned int)sizeof(fbe_terminator_sas_drive_fw_image_t));
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        fbe_terminator_miniport_api_complete_io(context->terminator_io->miniport_port_index, context->terminator_io);
        return;
    }

    image = (fbe_terminator_sas_drive_fw_image_t *)sg_list->address; 

    inquiry_p = sas_drive_get_inquiry(drive_p);
    if (inquiry_p == NULL)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! inquiry not found\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        fbe_terminator_miniport_api_complete_io(context->terminator_io->miniport_port_index, context->terminator_io);
        return;
    }

    vpd_inquiry_f3_p = sas_drive_get_vpd_inquiry_f3(drive_p, &vpd_size);
    if (vpd_inquiry_f3_p == NULL || vpd_size != sizeof(image->vpd_inquiry_f3))
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! VPD inquiry not found or invalid\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        fbe_terminator_miniport_api_complete_io(context->terminator_io->miniport_port_index, context->terminator_io);
        return;
    }

    /*vpd_inquiry_b2_p = sas_drive_get_vpd_inquiry_b2(drive_p, &vpd_size);
    if (vpd_inquiry_b2_p == NULL || vpd_size != sizeof(image->vpd_inquiry_f3))
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! VPD inquiry not found or invalid\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        fbe_terminator_miniport_api_complete_io(context->terminator_io->miniport_port_index, context->terminator_io);
        return;
    }*/

    fbe_copy_memory(inquiry_p, image->inquiry, sizeof(image->inquiry));
    fbe_copy_memory(vpd_inquiry_f3_p, image->vpd_inquiry_f3, sizeof(image->vpd_inquiry_f3));
    //fbe_copy_memory(vpd_inquiry_b2_p, image->vpd_inquiry_f3, sizeof(image->vpd_inquiry_b2));

    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);

    fbe_terminator_miniport_api_complete_io(context->terminator_io->miniport_port_index, context->terminator_io);
}

static fbe_status_t
sas_drive_process_payload_receive_diag (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_status_t                        status = FBE_STATUS_GENERIC_FAILURE;
    fbe_u8_t                            *b_ptr = NULL;
    fbe_sg_element_t                    *sg_list;
    fbe_payload_cdb_operation_t         *payload_cdb_operation = NULL;
    terminator_sas_drive_state_t        drive_state;
    fbe_u8_t * cdb;

    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);

    terminator_drive_get_state(drive_handle, &drive_state);
    if(drive_state == TERMINATOR_SAS_DRIVE_SELECT_TIMEOUT){
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SELECTION_TIMEOUT);
        return FBE_STATUS_OK;
    }

    fbe_payload_cdb_operation_get_cdb(payload_cdb_operation, &cdb);
    if(cdb[2] != 0x82){
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s diag page code 0x%x not supported\n", __FUNCTION__, cdb[2]);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    }

    fbe_payload_ex_get_sg_list(payload, &sg_list, NULL);
    b_ptr = (fbe_u8_t *)sg_list->address;
    if (sg_list->count == 0){
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: sg list count is 0, can't do inqury\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    }

    /* place the full diag page in the buffer */
    fbe_copy_memory (b_ptr, default_receive_diag_page82, sizeof(default_receive_diag_page82));
    fbe_payload_cdb_set_transferred_count(payload_cdb_operation, sizeof(default_receive_diag_page82));
    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);

    return status;
}

/* end fbe_terminator_sas_drive_payload*/


fbe_status_t
sas_drive_process_xfer_read_completion(void * context)
{
//    fbe_payload_cdb_operation_t * payload_cdb_operation_p = NULL;
    fbe_u64_t device_byte;
    fbe_u32_t bytes_left_to_xfer;
    fbe_sg_element_t *current_sg_p;
    fbe_payload_sg_index_t sg_list_index;
    //terminator_drive_t * drive = (terminator_drive_t *)drive_handle;
    fbe_u32_t sg_bytes_to_xfer;
    fbe_u32_t bytes_received;
    fbe_u8_t * data_buffer = NULL;
    fbe_u8_t * data_buffer_pointer = NULL;
    fbe_u8_t * sg_addr = NULL;

    fbe_terminator_io_t * terminator_io;
    fbe_payload_ex_t *payload_p;
    //fbe_terminator_device_ptr_t drive_handle;
    sas_drive_xfer_data_t *xfer_data;
    fbe_key_handle_t encryption_handle;
    terminator_key_info_t * key_info = NULL;
    fbe_bool_t is_compressed = FBE_FALSE;

    terminator_io = (fbe_terminator_io_t *)context;
    payload_p = (fbe_payload_ex_t *)terminator_io->payload;
    xfer_data = (sas_drive_xfer_data_t *)terminator_io->xfer_data;
    data_buffer = (fbe_u8_t *)terminator_io->memory_ptr;
    data_buffer_pointer = data_buffer;

    device_byte = (fbe_u32_t) (xfer_data->lba * xfer_data->block_size);
    bytes_left_to_xfer = (fbe_u32_t) (xfer_data->blocks * xfer_data->block_size);
    sg_list_index = FBE_PAYLOAD_SG_INDEX_INVALID;

    /* Check if we want to decrypt the data. If so decrypt it */
    fbe_payload_ex_get_key_handle(payload_p, &encryption_handle);
    if(encryption_handle != FBE_INVALID_KEY_HANDLE)
    {
        /* We may want to do better job of translating handle to key info, but it is good enough for now */
        key_info = (terminator_key_info_t *)(fbe_ptrhld_t)encryption_handle;
    }

    if ((terminator_simulated_drive_type == TERMINATOR_SIMULATED_DRIVE_TYPE_LOCAL_MEMORY) ||
        (terminator_simulated_drive_type == TERMINATOR_SIMULATED_DRIVE_TYPE_REMOTE_MEMORY)) {
        if ((terminator_io->return_size < bytes_left_to_xfer) && (terminator_io->return_size != 0) &&
            ((terminator_io->return_size % sizeof(fbe_terminator_compressed_block_t)) == 0)) {
            is_compressed = FBE_TRUE;
        }
    }

    if (is_compressed) {
        if (terminator_drive_decompress_buffer(xfer_data, data_buffer, terminator_io->return_size, key_info) != FBE_STATUS_OK) {
            terminator_trace(FBE_TRACE_LEVEL_CRITICAL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s drive %s decompress failed.\n", __FUNCTION__, xfer_data->drive_name);
            return FBE_STATUS_GENERIC_FAILURE;
        }
    } else {

        if (key_info) {
            /* We need to decrypt the data */
            terminator_simulated_disk_decrypt_data(data_buffer, 
                                   (fbe_u32_t)(xfer_data->blocks * xfer_data->block_size),
                                   key_info->keys,
                                   FBE_ENCRYPTION_KEY_SIZE);
        }

    /* We have three sg lists.  We start with whichever is not empty.
     * If they are all empty the we return error.
     */
    if (xfer_data->pre_sg_p != NULL && fbe_sg_element_count(xfer_data->pre_sg_p) != 0) {
        sg_list_index = FBE_PAYLOAD_SG_INDEX_PRE_SG_LIST;
        current_sg_p = xfer_data->pre_sg_p;
    } else if (xfer_data->sg_p != NULL && fbe_sg_element_count(xfer_data->sg_p) != 0) {
        sg_list_index = FBE_PAYLOAD_SG_INDEX_SG_LIST;
        current_sg_p = xfer_data->sg_p;
    } else if (xfer_data->post_sg_p != NULL && fbe_sg_element_count(xfer_data->post_sg_p) != 0) {
        sg_list_index = FBE_PAYLOAD_SG_INDEX_POST_SG_LIST;
        current_sg_p = xfer_data->post_sg_p;
    } else {
        /* Error, we could not find non-empty sg list. */
        bytes_received = 0;
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s drive %s end of SG list hit unexpectedly.\n", __FUNCTION__, xfer_data->drive_name);
//        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        fbe_terminator_free_memory(terminator_io->memory_ptr);
        terminator_io->memory_ptr = NULL;
        fbe_terminator_free_memory(terminator_io->xfer_data);
        terminator_io->xfer_data = NULL;
        return FBE_STATUS_GENERIC_FAILURE;
    }

    while ( bytes_left_to_xfer > 0 ) {
        /* If we hit the end of the sg list or
            * we find a NULL address, then exit with error.
            */
        if (current_sg_p == NULL || fbe_sg_element_address(current_sg_p) == NULL || fbe_sg_element_count(current_sg_p) == 0 ) {
            /* Error, we could not transfer what we expected. */
            bytes_received = 0;
            terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s drive %s end of SG list hit unexpectedly.\n", __FUNCTION__, xfer_data->drive_name);
//			fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
            fbe_terminator_free_memory(terminator_io->memory_ptr);
            terminator_io->memory_ptr = NULL;
            fbe_terminator_free_memory(terminator_io->xfer_data);
            terminator_io->xfer_data = NULL;
            return FBE_STATUS_GENERIC_FAILURE;
        }

        sg_bytes_to_xfer = fbe_sg_element_count(current_sg_p);

        if (sg_bytes_to_xfer > bytes_left_to_xfer) {
            /* The sg is longer than this transfer,
                * simply transfer the amount specified.
                */
            sg_bytes_to_xfer = bytes_left_to_xfer;
        }

        /* Transfer bytes. */
        sg_addr = fbe_sg_element_address(current_sg_p);

        /* fbe_copy_memory(void * dst, const void * src, fbe_u32_t length) */
        fbe_copy_memory(sg_addr, data_buffer_pointer, sg_bytes_to_xfer);
        data_buffer_pointer += sg_bytes_to_xfer;
        bytes_received = sg_bytes_to_xfer;

        current_sg_p++;
        bytes_left_to_xfer -= sg_bytes_to_xfer;

        /* When we hit the end of one SG list, try to goto the next
            * list. Only goto the next list if we are not already at
            * the end. There are three sg list and we will iterate
            * over each in turn.
            */
        if (bytes_left_to_xfer > 0 && fbe_sg_element_count(current_sg_p) == 0 && sg_list_index < FBE_PAYLOAD_SG_INDEX_POST_SG_LIST) {
            /* Increment to the next sg list. */
            sg_list_index++;

            /* We now are either at the middle sg or the end sg. */
            if (sg_list_index == FBE_PAYLOAD_SG_INDEX_SG_LIST) {
                /* Get the middle sg list ptr. */
                current_sg_p = xfer_data->sg_p;
            } else if (sg_list_index == FBE_PAYLOAD_SG_INDEX_POST_SG_LIST) {
                /* Get the end sg list ptr. */
                current_sg_p = xfer_data->post_sg_p;
            }
        } /* If we hit the end of an sg list. */

    } /* end while bytes left and no error */
    } /* end non-compressed data */

    /* Trace the read completion.
     */
    terminator_drive_trace_read((terminator_drive_t *)terminator_io->device_ptr, terminator_io, FBE_FALSE /* b_start */);

    /* Free any allocated memory now since we have copied the read data into
     * the sgs supplied.
     */
    fbe_terminator_free_memory(terminator_io->memory_ptr);
    terminator_io->memory_ptr = NULL;
    fbe_terminator_free_memory(terminator_io->xfer_data);
    terminator_io->xfer_data = NULL;

    /* Only invoked the completion if the I/O is pending
     */
    if (terminator_io->is_pending)
    {
        fbe_terminator_miniport_api_complete_io(terminator_io->miniport_port_index, terminator_io);
    }

    /* Always success
     */
    return FBE_STATUS_OK;
}
/* end of sas_drive_process_xfer_read_completion() */

static fbe_status_t
sas_drive_process_xfer_read(fbe_terminator_io_t * terminator_io, fbe_terminator_device_ptr_t drive_handle, sas_drive_xfer_data_t *xfer_data)
{
    /* By default we return good status. */
    fbe_status_t        status = FBE_STATUS_OK;
    fbe_payload_cdb_operation_t * payload_cdb_operation_p = NULL;
    fbe_u8_t *sense_buffer = NULL;
    fbe_u32_t device_byte;
    fbe_u32_t bytes_left_to_xfer;
    fbe_sg_element_t *current_sg_p;
    fbe_payload_sg_index_t sg_list_index;
    fbe_u8_t *sense_buffer_p = NULL;
    terminator_drive_t * drive = (terminator_drive_t *)drive_handle;
    //fbe_u32_t sg_bytes_to_xfer;
    //fbe_u32_t bytes_received;
    fbe_u8_t * data_buffer = NULL;
    fbe_u8_t * data_buffer_pointer = NULL;
    fbe_payload_ex_t *payload_p = terminator_io->payload;
    fbe_u32_t transfer_count = 0;

    payload_cdb_operation_p = fbe_payload_ex_get_cdb_operation(payload_p);
    if(payload_cdb_operation_p == NULL)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s fbe_payload_ex_get_cdb_operation failed\n", __FUNCTION__);
        return(FBE_STATUS_GENERIC_FAILURE);
    }

    status = fbe_payload_cdb_operation_get_sense_buffer(payload_cdb_operation_p, &sense_buffer);
    if(status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s fbe_payload_cdb_operation_get_sense_buffer failed\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }

    device_byte = (fbe_u32_t) (xfer_data->lba * xfer_data->block_size);
    bytes_left_to_xfer = (fbe_u32_t) (xfer_data->blocks * xfer_data->block_size);
    sg_list_index = FBE_PAYLOAD_SG_INDEX_INVALID;

    /* Validate request doesn't exceed per-drive transfer size*/
    if (bytes_left_to_xfer > drive_get_maximum_transfer_bytes(drive))
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s bytes_left_to_xfer: 0x%x is greater than maximum: 0x%x\n",
                         __FUNCTION__, bytes_left_to_xfer, drive_get_maximum_transfer_bytes(drive));
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);

        /* It's ok to return an error since the terminator ignores the return status */
        return(FBE_STATUS_GENERIC_FAILURE);
    }

    /* We have three sg lists.  We start with whichever is not empty.
     * If they are all empty the we return error.
     */
    if (xfer_data->pre_sg_p != NULL && fbe_sg_element_count(xfer_data->pre_sg_p) != 0) {
        sg_list_index = FBE_PAYLOAD_SG_INDEX_PRE_SG_LIST;
        current_sg_p = xfer_data->pre_sg_p;
    } else if (xfer_data->sg_p != NULL && fbe_sg_element_count(xfer_data->sg_p) != 0) {
        sg_list_index = FBE_PAYLOAD_SG_INDEX_SG_LIST;
        current_sg_p = xfer_data->sg_p;
    } else if (xfer_data->post_sg_p != NULL && fbe_sg_element_count(xfer_data->post_sg_p) != 0) {
        sg_list_index = FBE_PAYLOAD_SG_INDEX_POST_SG_LIST;
        current_sg_p = xfer_data->post_sg_p;
    }
    else { /* None of the sg lists is any good. */
        status = FBE_STATUS_GENERIC_FAILURE;
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s drive %s end of SG list hit unexpectedly.\n", __FUNCTION__, xfer_data->drive_name);
        terminator_drive_increment_error_count(drive_handle);
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }

    /* Check if xfer has valid LBA */
    if (xfer_data->lba + xfer_data->blocks > drive->capacity)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s drive %s attempt to seek past end of disk (0x%llx).\n", __FUNCTION__, xfer_data->drive_name, (unsigned long long)device_byte);
        terminator_drive_increment_error_count(drive_handle);
        /* If the seek fails return the same error a drive would to indicate
            * that something was wrong with the cdb (it was beyond the capacity).
            */
        fbe_payload_cdb_set_scsi_status(payload_cdb_operation_p, FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION);
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_ERROR);

        fbe_payload_cdb_operation_get_sense_buffer(payload_cdb_operation_p, &sense_buffer_p);
        sas_drive_build_sense_data(sense_buffer_p,
                                    FBE_SCSI_SENSE_KEY_ILLEGAL_REQUEST,
                                    FBE_SCSI_ASC_INVALID_FIELD_IN_CDB,
                                    FBE_SCSI_ASCQ_NO_ADDITIONAL_SENSE_INFO);

        return FBE_STATUS_GENERIC_FAILURE;
    }

    fbe_payload_cdb_get_transfer_count(payload_cdb_operation_p, &transfer_count );
    if( (transfer_count % drive_get_block_size(drive)) != 0){
        status = FBE_STATUS_GENERIC_FAILURE;
        terminator_trace(FBE_TRACE_LEVEL_CRITICAL_ERROR, 
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s Transfer count %d not multiple of block size %d\n", 
                         __FUNCTION__, transfer_count,
                         drive_get_block_size(drive));
        terminator_drive_increment_error_count(drive_handle);
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }

    /* Allocate continous memory for operation */
    data_buffer = (fbe_u8_t *)fbe_terminator_allocate_memory((fbe_u32_t)(xfer_data->blocks * xfer_data->block_size));
    if (data_buffer == NULL)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR,
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s failed to allocate memory for data buffer at line %d.\n",
                         __FUNCTION__,
                         __LINE__);

        return FBE_STATUS_GENERIC_FAILURE;
    }

    //data_buffer = two_megabyte_buffer;
    data_buffer_pointer = data_buffer;

    terminator_io->is_pending = 1; /* It will be completed asyncronously */
    terminator_io->memory_ptr = data_buffer; /* The completion function will free this memory */
    terminator_io->opcode = FBE_PAYLOAD_BLOCK_OPERATION_OPCODE_READ;
    terminator_io->device_ptr = drive;

    terminator_io->xfer_data = fbe_terminator_allocate_memory(sizeof(sas_drive_xfer_data_t));
    if (terminator_io->xfer_data == NULL)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR,
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s failed to allocate memory for transfer data buffer at line %d.\n",
                         __FUNCTION__,
                         __LINE__);

        return FBE_STATUS_GENERIC_FAILURE;
    }

    fbe_copy_memory(terminator_io->xfer_data, xfer_data, sizeof(sas_drive_xfer_data_t));

    terminator_io->u.read.is_unmapped_allowed = FBE_FALSE;
    if ((payload_cdb_operation_p->payload_cdb_flags & FBE_PAYLOAD_CDB_FLAGS_ALLOW_UNMAP_READ) != 0 )
    {
        terminator_io->u.read.is_unmapped_allowed = FBE_TRUE;
    }
    /* Read the data */
    terminator_drive_trace_read(drive, terminator_io, FBE_TRUE /* b_start */);
    status = terminator_drive_read(drive, xfer_data->lba, xfer_data->blocks, xfer_data->block_size, data_buffer, terminator_io);

    /* If the read completed immediately invoke the completion function now
     */
    if (status != FBE_STATUS_PENDING)
    {
        /* If the I/O completed immediately, clear the pending and complete the
         * request.
         */
        terminator_io->is_pending = 0;      /* It completed immediately */
        status = sas_drive_process_xfer_read_completion((void *)terminator_io);
    }
    return status;
}
/* end of sas_drive_process_xfer_read() */

fbe_status_t
sas_drive_process_xfer_write_completion(void * context)
{
    fbe_terminator_io_t * terminator_io;

    terminator_io = (fbe_terminator_io_t *)context;

    /* Trace the write completion.
     */
    terminator_drive_trace_write((terminator_drive_t *)terminator_io->device_ptr, terminator_io, FBE_FALSE /* b_start */);

    /* Free any allocated memory now since the write is complete
     */
    if(terminator_io->memory_ptr != NULL)
    {
        fbe_terminator_free_memory(terminator_io->memory_ptr);
        terminator_io->memory_ptr = NULL;
    }

    /* Only invoked the completion if the I/O is pending
     */
    if (terminator_io->is_pending)
    {
        fbe_terminator_miniport_api_complete_io(terminator_io->miniport_port_index, terminator_io);
    }

    /* Always success
     */
    return FBE_STATUS_OK;
}
/* end of sas_drive_process_xfer_write_completion() */

static fbe_status_t
sas_drive_payload_write_same(fbe_terminator_io_t * terminator_io, 
                             fbe_terminator_device_ptr_t drive_handle,
                             fbe_bool_t b_is_zeros)
{
    fbe_status_t status = FBE_STATUS_OK;
    sas_drive_xfer_data_t xfer_data;
    fbe_u32_t             bytes_left_to_xfer;
    fbe_sg_element_t *    sg_elem_p = NULL;
    fbe_u32_t             sg_bytes = 0;
    terminator_drive_t * drive = (terminator_drive_t *)drive_handle;
    fbe_payload_cdb_operation_t * payload_cdb_operation_p = NULL;
    fbe_payload_ex_t * payload = terminator_io->payload;
    fbe_u8_t * cdb;
    fbe_u8_t cdb_opcode;
    fbe_u32_t transfer_count;
    fbe_bool_t is_unmap_cmd = FBE_FALSE;


    payload_cdb_operation_p = fbe_payload_ex_get_cdb_operation(payload);
    /* make sure we have the right operation */
    if (payload_cdb_operation_p == NULL) {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: Error ! Operation must be payload_cdb_operation \n", __FUNCTION__);
        return FBE_STATUS_GENERIC_FAILURE;
    }

    status = fbe_payload_cdb_operation_get_cdb(payload_cdb_operation_p, &cdb);
    if (status != FBE_STATUS_OK) {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s:Error !! fbe_payload_cdb_operation_get_cdb failed\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }

    cdb_opcode = cdb[0];

    /* determine if unmap command */
    switch(cdb_opcode)
    {
        case FBE_SCSI_WRITE_SAME:
        case FBE_SCSI_WRITE_SAME_16:
            if (cdb[1] == 0x08)
            {
                is_unmap_cmd = FBE_TRUE;
            }
            break;

        case FBE_SCSI_UNMAP:
            is_unmap_cmd = FBE_TRUE;
            break;
    }

    if (is_unmap_cmd)
    {
        /* TODO: Verify that unmap is supported. If not return 05/24. */
        terminator_io->u.zero.do_unmap = FBE_TRUE;
        b_is_zeros = FBE_TRUE;  /* treat any unmap cmd as zero's.  */
    }
    else 
    {
        terminator_io->u.zero.do_unmap = FBE_FALSE;
    }

    /* Use the correct translation based on cdb.
     */
    switch(cdb_opcode)
    {
        case FBE_SCSI_WRITE_10:
        case FBE_SCSI_WRITE_VERIFY: /* Ten Byte. */
        case FBE_SCSI_WRITE_SAME: /* Ten Byte. */
            status = sas_drive_payload_prepare_write_10_xfer(payload, drive_handle, &xfer_data);
            break;

        case FBE_SCSI_WRITE_16:
        case FBE_SCSI_WRITE_VERIFY_16:
        case FBE_SCSI_WRITE_SAME_16:
            status = sas_drive_payload_prepare_write_16_xfer(payload, drive_handle, &xfer_data);
            break;

        case FBE_SCSI_UNMAP:
            //TODO: add support
            terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
             "%s: unmap cmd not supported yet.\n", 
             __FUNCTION__);           
            break;

        default:
            terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s: Unsupported opcode: 0x%x\n", 
                         __FUNCTION__, cdb_opcode);
            fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
            return FBE_STATUS_GENERIC_FAILURE;
    }

    if (status != FBE_STATUS_OK){
        return status;
    }

    bytes_left_to_xfer = (fbe_u32_t) (xfer_data.blocks * xfer_data.block_size);


    /* Validate the data block size matches drive block_size */
    if (xfer_data.block_size != drive_get_block_size (drive)) {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s data block size 0x%x != drive block size 0x%x.\n",
                         __FUNCTION__,
                         xfer_data.block_size,
                         drive_get_block_size (drive));
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return(FBE_STATUS_GENERIC_FAILURE);
    }

    /* A Write same is allowed as big a range as possible, since 
     * the command only transfers a single block of data. 
     * Thus, we do not validate the 
     * bytes_left_to_xfer <= drive_get_maximum_transfer_bytes(drive) 
     */
    /* Check if xfer has valid LBA range, should not exceed the drive capacity */
    if (xfer_data.lba + xfer_data.blocks > drive_get_capacity(drive)) {
        fbe_u8_t *sense_buffer_p = NULL;
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s drive %s attempt to seek past end of disk (0x%llx).\n",
                         __FUNCTION__, xfer_data.drive_name,
             (unsigned long long)drive_get_capacity(drive));
        terminator_drive_increment_error_count(drive);
        /* If the seek fails return the same error a drive would to indicate
         * that something was wrong with the cdb (it was beyond the capacity).
         */
        fbe_payload_cdb_set_scsi_status(payload_cdb_operation_p, FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION);
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_ERROR);
        fbe_payload_cdb_operation_get_sense_buffer(payload_cdb_operation_p, &sense_buffer_p);
        sas_drive_build_sense_data(sense_buffer_p,
                                   FBE_SCSI_SENSE_KEY_ILLEGAL_REQUEST,
                                   FBE_SCSI_ASC_INVALID_FIELD_IN_CDB,
                                   FBE_SCSI_ASCQ_NO_ADDITIONAL_SENSE_INFO);

        return FBE_STATUS_GENERIC_FAILURE;
    }

    fbe_payload_cdb_get_transfer_count(payload_cdb_operation_p, &transfer_count );
    if( (transfer_count % drive_get_block_size(drive)) != 0){
        status = FBE_STATUS_GENERIC_FAILURE;
        terminator_trace(FBE_TRACE_LEVEL_CRITICAL_ERROR, 
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s Transfer count %d not multiple of block size %d\n", 
                         __FUNCTION__, transfer_count,
                         drive_get_block_size(drive));
        terminator_drive_increment_error_count(drive_handle);
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }

    sg_elem_p = xfer_data.sg_p;
    
    /* CBE WRITE SAME */
    if(sg_elem_p == NULL){ /* Quick and dirty */
        sg_elem_p = xfer_data.pre_sg_p;
    }

    sg_bytes = fbe_sg_element_count_list_bytes(sg_elem_p);

    if(sg_bytes % drive_get_block_size(drive) != 0){
        status = FBE_STATUS_GENERIC_FAILURE;
        terminator_trace(FBE_TRACE_LEVEL_CRITICAL_ERROR, 
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s SG Bytes %d not multiple of block size %d\n", 
                         __FUNCTION__, transfer_count,
                         drive_get_block_size(drive));
        terminator_drive_increment_error_count(drive_handle);
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }

    terminator_io->is_pending = 1; /* It will be completed asyncronously */
    terminator_io->opcode = FBE_PAYLOAD_BLOCK_OPERATION_OPCODE_ZERO;	
    terminator_io->lba = xfer_data.lba;
    terminator_io->block_count = xfer_data.blocks;
    terminator_io->block_size = xfer_data.block_size;
    terminator_io->device_ptr = drive;
    //fbe_sas_drive_is_zero_transfer
    /*! @note At one point the SAS PDO could not handle a write same that was 
     *        not a multiple of the native blocks size.  Now it can.
     */
    if ( b_is_zeros ||
        (sas_drive_is_zero_pattern_block(fbe_sg_element_address(sg_elem_p), drive_get_block_size(drive)) == FBE_TRUE)) {

        /* write zero pattern*/
        terminator_drive_trace_write_zero_pattern(drive, terminator_io, FBE_TRUE /* b_start */);
        status = terminator_drive_write_zero_pattern(drive, xfer_data.lba, xfer_data.blocks, xfer_data.block_size, fbe_sg_element_address(sg_elem_p), terminator_io);

        /* If the write completed immediately invoke the completion function now
         */
        if (status != FBE_STATUS_PENDING) {
            /* If the I/O completed immediately, clear the pending and complete the
             * request.
             */
            terminator_io->is_pending = 0;      /* It completed immediately */
            status = sas_drive_process_xfer_write_completion((void *)terminator_io);
        }
    }else{
        /*! @note Although compressed sgl processing doesn't have an issue, it 
         *        results in a huge amount of memory being allocated. 
         */
        terminator_trace(FBE_TRACE_LEVEL_DEBUG_LOW, FBE_TRACE_MESSAGE_ID_INFO,
                         "sas write same: %d_%d_%d lba: 0x%llx blks: 0x%x block_size: %d compressed sg unexpected\n",
                         drive->backend_number, drive->encl_number, drive->slot_number,
                         (unsigned long long)xfer_data.lba, (unsigned int)xfer_data.blocks, xfer_data.block_size);
        status = sas_drive_process_compressed_sg_write(terminator_io, drive_handle, &xfer_data);
    }
    return status;
}
/* end of sas_drive_payload_write_same */

static fbe_status_t
sas_drive_process_xfer_write(fbe_terminator_io_t * terminator_io, fbe_terminator_device_ptr_t drive_handle, sas_drive_xfer_data_t *xfer_data)
{
    /* By default we return good status. */
    fbe_status_t        status = FBE_STATUS_OK;
    fbe_payload_cdb_operation_t * payload_cdb_operation_p = NULL;
    fbe_u8_t *sense_buffer = NULL;
    fbe_u32_t device_byte;
    fbe_u32_t bytes_left_to_xfer;
    fbe_sg_element_t *current_sg_p;
    fbe_payload_sg_index_t sg_list_index;
    fbe_u8_t *sense_buffer_p = NULL;
    terminator_drive_t * drive = (terminator_drive_t *)drive_handle;
    fbe_u32_t sg_bytes_to_xfer;
    fbe_u32_t bytes_received;
    fbe_u8_t * data_buffer = NULL;
    fbe_u8_t * data_buffer_pointer = NULL;
    fbe_u8_t * sg_addr = NULL;
    fbe_payload_ex_t *payload_p = terminator_io->payload;
    fbe_key_handle_t    encryption_handle;
    terminator_key_info_t * key_info = NULL;
    fbe_u32_t transfer_count;
    fbe_bool_t is_compressed = FBE_FALSE;

    payload_cdb_operation_p = fbe_payload_ex_get_cdb_operation(payload_p);
    if(payload_cdb_operation_p == NULL)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s fbe_payload_ex_get_cdb_operation failed\n", __FUNCTION__);
        return(FBE_STATUS_GENERIC_FAILURE);
    }

    status = fbe_payload_cdb_operation_get_sense_buffer(payload_cdb_operation_p, &sense_buffer);
    if(status != FBE_STATUS_OK)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s fbe_payload_cdb_operation_get_sense_buffer failed\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }

    device_byte = (fbe_u32_t) (xfer_data->lba * xfer_data->block_size);
    bytes_left_to_xfer = (fbe_u32_t) (xfer_data->blocks * xfer_data->block_size);
    sg_list_index = FBE_PAYLOAD_SG_INDEX_INVALID;

    /* Validate request doesn't exceed per-drive transfer size*/
    if (bytes_left_to_xfer > drive_get_maximum_transfer_bytes(drive))
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s bytes_left_to_xfer: 0x%x is greater than maximum: 0x%x\n",
                         __FUNCTION__, bytes_left_to_xfer, drive_get_maximum_transfer_bytes(drive));
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);

        /* It's ok to return an error since the terminator ignores the return status */
        return(FBE_STATUS_GENERIC_FAILURE);
    }

    /* We have three sg lists.  We start with whichever is not empty.
     * If they are all empty the we return error.
     */
    if (xfer_data->pre_sg_p != NULL && fbe_sg_element_count(xfer_data->pre_sg_p) != 0) {
        sg_list_index = FBE_PAYLOAD_SG_INDEX_PRE_SG_LIST;
        current_sg_p = xfer_data->pre_sg_p;
    } else if (xfer_data->sg_p != NULL && fbe_sg_element_count(xfer_data->sg_p) != 0) {
        sg_list_index = FBE_PAYLOAD_SG_INDEX_SG_LIST;
        current_sg_p = xfer_data->sg_p;
    } else if (xfer_data->post_sg_p != NULL && fbe_sg_element_count(xfer_data->post_sg_p) != 0) {
        sg_list_index = FBE_PAYLOAD_SG_INDEX_POST_SG_LIST;
        current_sg_p = xfer_data->post_sg_p;
    }
    else { /* None of the sg lists is any good. */
        status = FBE_STATUS_GENERIC_FAILURE;
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s drive %s end of SG list hit unexpectedly.\n", __FUNCTION__, xfer_data->drive_name);
        terminator_drive_increment_error_count(drive_handle);
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }


    /* Check if xfer has valid LBA */
    if (xfer_data->lba + xfer_data->blocks > drive->capacity)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s drive %s attempt to seek past end of disk (0x%x).\n", __FUNCTION__, xfer_data->drive_name, device_byte);
        terminator_drive_increment_error_count(drive_handle);
        /* If the seek fails return the same error a drive would to indicate
            * that something was wrong with the cdb (it was beyond the capacity).
            */
        fbe_payload_cdb_set_scsi_status(payload_cdb_operation_p, FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION);
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_ERROR);

        fbe_payload_cdb_operation_get_sense_buffer(payload_cdb_operation_p, &sense_buffer_p);
        sas_drive_build_sense_data(sense_buffer_p,
                                    FBE_SCSI_SENSE_KEY_ILLEGAL_REQUEST,
                                    FBE_SCSI_ASC_INVALID_FIELD_IN_CDB,
                                    FBE_SCSI_ASCQ_NO_ADDITIONAL_SENSE_INFO);

        return FBE_STATUS_GENERIC_FAILURE;
    }

    fbe_payload_cdb_get_transfer_count(payload_cdb_operation_p, &transfer_count );
    if( (transfer_count % drive_get_block_size(drive)) != 0){
        status = FBE_STATUS_GENERIC_FAILURE;
        terminator_trace(FBE_TRACE_LEVEL_CRITICAL_ERROR, 
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s Transfer count %d not multiple of block size %d\n", 
                         __FUNCTION__, transfer_count,
                         drive_get_block_size(drive));
        terminator_drive_increment_error_count(drive_handle);
        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return status;
    }

    /* Allocate continous memory for operation */
    data_buffer = (fbe_u8_t *)fbe_terminator_allocate_memory((fbe_u32_t)(xfer_data->blocks * xfer_data->block_size));
    if (data_buffer == NULL)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR,
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s failed to allocate memory for data buffer at line %d.\n",
                         __FUNCTION__,
                         __LINE__);

        return FBE_STATUS_GENERIC_FAILURE;
    }

    /* Check if we want to encrypt the write. If so do encryption */
    fbe_payload_ex_get_key_handle(payload_p, &encryption_handle);
    if(encryption_handle != FBE_INVALID_KEY_HANDLE)
    {
        /* We may want to do better job of translating handle to key info, but it is good enough for now */
        key_info = (terminator_key_info_t *)(fbe_ptrhld_t)encryption_handle;
    }

    /* If compressed copy doesn't succeed, go back to normal process */
    status = terminator_drive_compress_buffer(xfer_data, data_buffer, key_info);
    if (status == FBE_STATUS_OK) {
        is_compressed = FBE_TRUE;
    } else {

        //data_buffer = two_megabyte_buffer;
        data_buffer_pointer = data_buffer;

        while ( bytes_left_to_xfer > 0 ) {
            /* If we hit the end of the sg list or
             * we find a NULL address, then exit with error.
             */
            if (current_sg_p == NULL || fbe_sg_element_address(current_sg_p) == NULL || fbe_sg_element_count(current_sg_p) == 0 ) {
                /* Error, we could not transfer what we expected. */
                bytes_received = 0;
                terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s drive %s end of SG list hit unexpectedly.\n", __FUNCTION__, xfer_data->drive_name);
                terminator_drive_increment_error_count(drive_handle);
                fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
                fbe_terminator_free_memory(data_buffer);
                return FBE_STATUS_GENERIC_FAILURE;
            }

            sg_bytes_to_xfer = fbe_sg_element_count(current_sg_p);

            if (sg_bytes_to_xfer > bytes_left_to_xfer) {
                /* The sg is longer than this transfer,
                 * simply transfer the amount specified.
                 */
                sg_bytes_to_xfer = bytes_left_to_xfer;
            }

            /* Transfer bytes. */
            sg_addr = fbe_sg_element_address(current_sg_p);
            /* fbe_copy_memory(void * dst, const void * src, fbe_u32_t length) */
            fbe_copy_memory(data_buffer_pointer, sg_addr, sg_bytes_to_xfer);
            data_buffer_pointer += sg_bytes_to_xfer;
            bytes_received = sg_bytes_to_xfer;

            current_sg_p++;
            bytes_left_to_xfer -= sg_bytes_to_xfer;

            /* When we hit the end of one SG list, try to goto the next
            * list. Only goto the next list if we are not already at
            * the end. There are three sg list and we will iterate
            * over each in turn.
            */
            if (bytes_left_to_xfer > 0 && fbe_sg_element_count(current_sg_p) == 0 && sg_list_index < FBE_PAYLOAD_SG_INDEX_POST_SG_LIST) {
                /* Increment to the next sg list. */
                sg_list_index++;

                /* We now are either at the middle sg or the end sg. */
                if (sg_list_index == FBE_PAYLOAD_SG_INDEX_SG_LIST) {
                    /* Get the middle sg list ptr. */
                    current_sg_p = xfer_data->sg_p;
                } else if (sg_list_index == FBE_PAYLOAD_SG_INDEX_POST_SG_LIST) {
                    /* Get the end sg list ptr. */
                    current_sg_p = xfer_data->post_sg_p;
                }
            } /* If we hit the end of an sg list. */

        } /* end while bytes left and no error */

        if (key_info) {
            /* We need to encrypt the data */
            terminator_simulated_disk_encrypt_data(data_buffer, 
                                   (fbe_u32_t)(xfer_data->blocks * xfer_data->block_size),
                                   key_info->keys,
                                   FBE_ENCRYPTION_KEY_SIZE);
        }
    }
    
    /* Perform write */
    terminator_io->is_pending = 1; /* It will be completed asyncronously */
    terminator_io->memory_ptr = data_buffer; /* The completion function will free this memory */
    terminator_io->opcode = FBE_PAYLOAD_BLOCK_OPERATION_OPCODE_WRITE;
    terminator_io->device_ptr = drive;

    terminator_drive_trace_write((terminator_drive_t *)terminator_io->device_ptr, terminator_io, FBE_TRUE /* b_start */);

    if (!is_compressed) {
        terminator_io->is_compressed = FBE_FALSE;
        status = terminator_drive_write(drive, xfer_data->lba, xfer_data->blocks, xfer_data->block_size, data_buffer, terminator_io);
    } else {
        fbe_u32_t record_block_size;
        terminator_io->is_compressed = FBE_TRUE;
        if (terminator_io->block_size > FBE_BE_BYTES_PER_BLOCK) {
            record_block_size = sizeof(fbe_terminator_compressed_block_t) * (terminator_io->block_size / FBE_BE_BYTES_PER_BLOCK);
        } else {
            record_block_size = sizeof(fbe_terminator_compressed_block_t);
        }
		
        status = terminator_drive_write(drive, xfer_data->lba, xfer_data->blocks, 
                                        record_block_size, 
                                        data_buffer, terminator_io);
    }

    /* If the write completed immediately invoke the completion function now
     */
    if (status != FBE_STATUS_PENDING)
    {
        /* If the I/O completed immediately, clear the pending and complete the
         * request.
         */
        terminator_io->is_pending = 0;      /* It completed immediately */
        status = sas_drive_process_xfer_write_completion((void *)terminator_io);
    }

    return status;
}
/* end of sas_drive_process_xfer_write() */


static fbe_status_t
sas_drive_process_compressed_sg_write(fbe_terminator_io_t * terminator_io,
                                      fbe_terminator_device_ptr_t drive_handle,
                                      sas_drive_xfer_data_t *xfer_data)
{
    fbe_status_t status = FBE_STATUS_OK;
    terminator_drive_t * drive = (terminator_drive_t *)drive_handle;
    fbe_u8_t * data_buffer = NULL;
    fbe_u8_t * data_buffer_pointer = NULL;
    fbe_u32_t sg_bytes_to_xfer;
    fbe_u32_t bytes_received;
    fbe_payload_ex_t * payload_p = terminator_io->payload;
    /* Extract information from sg
     */
    fbe_u32_t bytes_left_to_xfer = (fbe_u32_t) (xfer_data->blocks * xfer_data->block_size);
    fbe_sg_element_t *sg_elem_p = xfer_data->sg_p;
    fbe_u32_t sg_bytes = fbe_sg_element_count_list_bytes(sg_elem_p);

    fbe_payload_cdb_operation_t * payload_cdb_operation_p = NULL;

    payload_cdb_operation_p = fbe_payload_ex_get_cdb_operation(payload_p);
    if (payload_cdb_operation_p == NULL) {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s fbe_payload_ex_get_cdb_operation failed\n", __FUNCTION__);
        return(FBE_STATUS_GENERIC_FAILURE);
    }

    /* Allocate continous memory for operation */
    data_buffer = (fbe_u8_t *)fbe_terminator_allocate_memory((fbe_u32_t)(xfer_data->blocks * xfer_data->block_size));
    if (data_buffer == NULL)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR,
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s failed to allocate memory for data buffer at line %d.\n",
                         __FUNCTION__,
                         __LINE__);

        return FBE_STATUS_GENERIC_FAILURE;
    }

    data_buffer_pointer = data_buffer;

    /* Execute the write.
     */
    while ( bytes_left_to_xfer > 0 && status == FBE_STATUS_OK) {
        /* If we hit a NULL pointer or
         * a NULL address, then exit with error.
         */
        if (sg_elem_p == NULL ||
            fbe_sg_element_address(sg_elem_p) == NULL ||
            fbe_sg_element_count(sg_elem_p) == 0 ) {
            /* Error, we could not transfer what we expected.
             */
            status = FBE_STATUS_GENERIC_FAILURE;
            bytes_received = 0;
            terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s drive %s end of SG list hit unexpectedly.\n",
                    __FUNCTION__, xfer_data->drive_name);
            terminator_drive_increment_error_count(drive_handle);
            fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
            fbe_terminator_free_memory(data_buffer);
            return status;
        } else {
            fbe_u32_t xferred_bytes = 0;
            fbe_sg_element_t *current_sg_p;
            sg_bytes_to_xfer = sg_bytes;
            bytes_received = 0;
            current_sg_p = sg_elem_p;
            if (sg_bytes_to_xfer > bytes_left_to_xfer) {
                /* The sg is longer than this transfer,
                 * simply transfer the amount specified.
                 */
                sg_bytes_to_xfer = bytes_left_to_xfer;
            }

            while (xferred_bytes < sg_bytes_to_xfer ||
                   fbe_sg_element_count(current_sg_p) != 0) {
                /* Write the bytes.
                 */
                fbe_copy_memory(data_buffer_pointer, fbe_sg_element_address(current_sg_p), fbe_sg_element_count(current_sg_p));
                data_buffer_pointer += fbe_sg_element_count(current_sg_p);
                bytes_received += fbe_sg_element_count(current_sg_p);
                xferred_bytes += fbe_sg_element_count(current_sg_p);
                fbe_sg_element_increment(&current_sg_p);
            }
        } /* end else transfer some number of bytes. */

        /* Check if we transferred enough.
         */
        if (bytes_received != sg_bytes_to_xfer) {
            /* Error, we didn't transfer what we expected.
             */
            status = FBE_STATUS_GENERIC_FAILURE;
            terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s drive %s unexpected transfer.\n",
                    __FUNCTION__, xfer_data->drive_name);
            terminator_drive_increment_error_count(drive_handle);
            fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_DATA_UNDERRUN);
            fbe_terminator_free_memory(data_buffer);
            return status;
        }

        bytes_left_to_xfer -= sg_bytes_to_xfer;

    } /* end while bytes left and no error */

    /* Perform write */
    terminator_io->is_pending = 1; /* It will be completed asyncronously */
    terminator_io->memory_ptr = data_buffer; /* The completion function will free this memory */
    terminator_io->opcode = FBE_PAYLOAD_BLOCK_OPERATION_OPCODE_WRITE;
    terminator_io->device_ptr = drive;

    terminator_drive_trace_write((terminator_drive_t *)terminator_io->device_ptr, terminator_io, FBE_TRUE /* b_start */);
    status = terminator_drive_write(drive, xfer_data->lba, xfer_data->blocks, xfer_data->block_size, data_buffer, terminator_io);			    

    /* If the write completed immediately invoke the completion function now
     */
    if (status != FBE_STATUS_PENDING)
    {
        /* If the I/O completed immediately, clear the pending and complete the
         * request.
         */
        terminator_io->is_pending = 0;      /* It completed immediately */
        status = sas_drive_process_xfer_write_completion((void *)terminator_io);
    }

    return status;
}
/* end sas_drive_process_compressed_sg_write() */

static fbe_status_t
sas_drive_process_xfer(fbe_terminator_io_t * terminator_io,
                                fbe_terminator_device_ptr_t drive_handle,
                                sas_drive_xfer_data_t *xfer_data)
{
    /* By default we return good status. */
//    fbe_status_t        status = FBE_STATUS_OK;
//    fbe_payload_cdb_operation_t * payload_cdb_operation_p = NULL;
//    fbe_u8_t *sense_buffer = NULL;
//	fbe_u64_t device_byte;
//    fbe_u32_t bytes_left_to_xfer;
//    fbe_sg_element_t *current_sg_p;
//    fbe_payload_sg_index_t sg_list_index;
//	fbe_u8_t *sense_buffer_p = NULL;
//	terminator_drive_t * drive = (terminator_drive_t *)drive_handle;
//	fbe_u32_t sg_bytes_to_xfer;
//    fbe_u32_t bytes_received;
//	fbe_u8_t * data_buffer = NULL;
//	fbe_u8_t * data_buffer_pointer = NULL;
//	fbe_u8_t * sg_addr = NULL;
//	fbe_payload_ex_t *payload_p = terminator_io->payload;

    terminator_io->lba = xfer_data->lba;
    terminator_io->block_count = xfer_data->blocks;
    terminator_io->block_size = xfer_data->block_size;
    if (xfer_data->direction_in) {
        fbe_status_t status;
        status = sas_drive_process_xfer_read(terminator_io, drive_handle, xfer_data);
        if (terminator_io->u.read.is_unmapped && !terminator_io->u.read.is_unmapped_allowed) 
        {
            terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_INFO, 
                 "Attempted to read an unmapped area\n");
        }
        return status;
    } else {
        return sas_drive_process_xfer_write(terminator_io, drive_handle, xfer_data);
    }

    /* unreachable code discovered by Converity, uncomment it if you change the logic before */
//    payload_cdb_operation_p = fbe_payload_ex_get_cdb_operation(payload_p);
//    if(payload_cdb_operation_p == NULL)
//    {
//        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s fbe_payload_ex_get_cdb_operation failed\n", __FUNCTION__);
//        return(FBE_STATUS_GENERIC_FAILURE);
//    }
//
//    status = fbe_payload_cdb_operation_get_sense_buffer(payload_cdb_operation_p, &sense_buffer);
//    if(status != FBE_STATUS_OK)
//    {
//        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s fbe_payload_cdb_operation_get_sense_buffer failed\n", __FUNCTION__);
//        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
//        return status;
//    }
//
//    device_byte =  (fbe_u64_t)(xfer_data->lba * xfer_data->block_size);
//    bytes_left_to_xfer = (fbe_u32_t) (xfer_data->blocks * xfer_data->block_size);
//    sg_list_index = FBE_PAYLOAD_SG_INDEX_INVALID;
//
//    /* Validate request doesn't exceed per-drive transfer size*/
//    if (bytes_left_to_xfer > drive_get_maximum_transfer_bytes(drive))
//    {
//        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
//                         "%s bytes_left_to_xfer: 0x%x is greater than maximum: 0x%x\n",
//                         __FUNCTION__, bytes_left_to_xfer, drive_get_maximum_transfer_bytes(drive));
//        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
//
//        /* It's ok to return an error since the terminator ignores the return status */
//        return(FBE_STATUS_GENERIC_FAILURE);
//    }
//
//    /* We have three sg lists.  We start with whichever is not empty.
//     * If they are all empty the we return error.
//     */
//    if (xfer_data->pre_sg_p != NULL && fbe_sg_element_count(xfer_data->pre_sg_p) != 0) {
//        sg_list_index = FBE_PAYLOAD_SG_INDEX_PRE_SG_LIST;
//        current_sg_p = xfer_data->pre_sg_p;
//    } else if (xfer_data->sg_p != NULL && fbe_sg_element_count(xfer_data->sg_p) != 0) {
//        sg_list_index = FBE_PAYLOAD_SG_INDEX_SG_LIST;
//        current_sg_p = xfer_data->sg_p;
//    } else if (xfer_data->post_sg_p != NULL && fbe_sg_element_count(xfer_data->post_sg_p) != 0) {
//        sg_list_index = FBE_PAYLOAD_SG_INDEX_POST_SG_LIST;
//        current_sg_p = xfer_data->post_sg_p;
//    }
//    else { /* None of the sg lists is any good. */
//        status = FBE_STATUS_GENERIC_FAILURE;
//        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s drive %s end of SG list hit unexpectedly.\n", __FUNCTION__, xfer_data->drive_name);
//        terminator_drive_increment_error_count(drive_handle);
//        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
//        return status;
//    }
//
//    /* Check if xfer has valid LBA */
//    if (xfer_data->lba + xfer_data->blocks > drive->capacity)
//    {
//        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s drive %s attempt to seek past end of disk (0x%llx).\n", __FUNCTION__, xfer_data->drive_name, device_byte);
//        terminator_drive_increment_error_count(drive_handle);
//        /* If the seek fails return the same error a drive would to indicate
//            * that something was wrong with the cdb (it was beyond the capacity).
//            */
//        fbe_payload_cdb_set_scsi_status(payload_cdb_operation_p, FBE_PAYLOAD_CDB_SCSI_STATUS_CHECK_CONDITION);
//        fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_ERROR);
//
//        fbe_payload_cdb_operation_get_sense_buffer(payload_cdb_operation_p, &sense_buffer_p);
//        sas_drive_build_sense_data(sense_buffer_p,
//                                    FBE_SCSI_SENSE_KEY_ILLEGAL_REQUEST,
//                                    FBE_SCSI_ASC_INVALID_FIELD_IN_CDB,
//                                    FBE_SCSI_ASCQ_NO_ADDITIONAL_SENSE_INFO);
//
//        return FBE_STATUS_GENERIC_FAILURE;
//    }
//
//    /* Allocate continous memory for operation */
//    data_buffer = (fbe_u8_t *)fbe_terminator_allocate_memory((fbe_u32_t)(xfer_data->blocks * xfer_data->block_size));
//    //data_buffer = two_megabyte_buffer;
//	data_buffer_pointer = data_buffer;
//	if(xfer_data->direction_in){
//		/* Read the data */
//        terminator_drive_read(drive, xfer_data->lba, xfer_data->blocks, xfer_data->block_size, data_buffer, NULL);
//    }
//
//    while ( bytes_left_to_xfer > 0 ) {
//		/* If we hit the end of the sg list or
//			* we find a NULL address, then exit with error.
//			*/
//		if (current_sg_p == NULL || fbe_sg_element_address(current_sg_p) == NULL || fbe_sg_element_count(current_sg_p) == 0 ) {
//			/* Error, we could not transfer what we expected. */
//			bytes_received = 0;
//			terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s drive %s end of SG list hit unexpectedly.\n", __FUNCTION__, xfer_data->drive_name);
//			terminator_drive_increment_error_count(drive_handle);
//			fbe_payload_cdb_set_request_status(payload_cdb_operation_p, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
//            fbe_terminator_free_memory(data_buffer);
//			return FBE_STATUS_GENERIC_FAILURE;
//		}
//
//        sg_bytes_to_xfer = fbe_sg_element_count(current_sg_p);
//
//        if (sg_bytes_to_xfer > bytes_left_to_xfer) {
//            /* The sg is longer than this transfer,
//                * simply transfer the amount specified.
//                */
//            sg_bytes_to_xfer = bytes_left_to_xfer;
//        }
//
//        /* Transfer bytes. */
//		sg_addr = fbe_sg_element_address(current_sg_p);
//        if (xfer_data->direction_in) {
//			/* fbe_copy_memory(void * dst, const void * src, fbe_u32_t length) */
//			fbe_copy_memory(sg_addr, data_buffer_pointer, sg_bytes_to_xfer);
//			data_buffer_pointer += sg_bytes_to_xfer;
//            bytes_received = sg_bytes_to_xfer;
//        }
//        else {
//			/* fbe_copy_memory(void * dst, const void * src, fbe_u32_t length) */
//			fbe_copy_memory(data_buffer_pointer, sg_addr, sg_bytes_to_xfer);
//			data_buffer_pointer += sg_bytes_to_xfer;
//            bytes_received = sg_bytes_to_xfer;
//        }
//
//        current_sg_p++;
//        bytes_left_to_xfer -= sg_bytes_to_xfer;
//
//        /* When we hit the end of one SG list, try to goto the next
//            * list. Only goto the next list if we are not already at
//            * the end. There are three sg list and we will iterate
//            * over each in turn.
//            */
//        if (bytes_left_to_xfer > 0 && fbe_sg_element_count(current_sg_p) == 0 && sg_list_index < FBE_PAYLOAD_SG_INDEX_POST_SG_LIST) {
//            /* Increment to the next sg list. */
//			sg_list_index++;
//
//			/* We now are either at the middle sg or the end sg. */
//			if (sg_list_index == FBE_PAYLOAD_SG_INDEX_SG_LIST) {
//				/* Get the middle sg list ptr. */
//				current_sg_p = xfer_data->sg_p;
//			} else if (sg_list_index == FBE_PAYLOAD_SG_INDEX_POST_SG_LIST) {
//				/* Get the end sg list ptr. */
//				current_sg_p = xfer_data->post_sg_p;
//			}
//		} /* If we hit the end of an sg list. */
//
//    } /* end while bytes left and no error */
//
//	/* Perform actual write */
//	if(!xfer_data->direction_in){
//		/* Perform write */
//        status = terminator_drive_write(drive, xfer_data->lba, xfer_data->blocks, xfer_data->block_size, data_buffer, NULL);
//    }
//
//	fbe_terminator_free_memory(data_buffer);
//
//	return status;
}

static fbe_bool_t sas_drive_is_zero_pattern_block(fbe_u8_t * data_buffer, fbe_block_size_t block_size)
{
    fbe_u64_t   zero_data = 0;
    fbe_u64_t   zero_metadata = ZERO_PATTERN_CHECKSUM;
    fbe_u64_t *  current_data = (fbe_u64_t *) data_buffer;
    fbe_u32_t i;
    fbe_block_size_t current_offset = 0;

    for(current_offset = 0; current_offset < block_size; current_offset += ZERO_PATTERN_SIZE)
    {
        /* check the zero */
        for (i = 0; i < (ZERO_PATTERN_SIZE/8 - 1); i++) {
            if (!fbe_equal_memory(current_data, &zero_data, sizeof(fbe_u64_t))){
                return FBE_FALSE;
            }
            current_data ++;
        }
        if (!fbe_equal_memory(current_data, &zero_metadata, sizeof(fbe_u64_t))) {
            return FBE_FALSE;
        }
        current_data = (fbe_u64_t *) (data_buffer + ZERO_PATTERN_SIZE) ;
    }
    return FBE_TRUE;
}


static fbe_status_t
terminator_drive_get_next_sg_element(sas_drive_xfer_data_t * xfer_data, 
                                     fbe_sg_element_t ** out_sg_p, 
                                     fbe_payload_sg_index_t *out_index)
{
    fbe_sg_element_t  * current_sg_p = *out_sg_p;
    fbe_payload_sg_index_t sg_list_index = *out_index;

    if (sg_list_index == 0) {
        current_sg_p = NULL;
        if (xfer_data->pre_sg_p != NULL && fbe_sg_element_count(xfer_data->pre_sg_p) != 0) {
            sg_list_index = FBE_PAYLOAD_SG_INDEX_PRE_SG_LIST;
            current_sg_p = xfer_data->pre_sg_p;
        } else if (xfer_data->sg_p != NULL && fbe_sg_element_count(xfer_data->sg_p) != 0) {
            sg_list_index = FBE_PAYLOAD_SG_INDEX_SG_LIST;
            current_sg_p = xfer_data->sg_p;
        } else if (xfer_data->post_sg_p != NULL && fbe_sg_element_count(xfer_data->post_sg_p) != 0) {
            sg_list_index = FBE_PAYLOAD_SG_INDEX_POST_SG_LIST;
            current_sg_p = xfer_data->post_sg_p;
        }
    } else {
        current_sg_p++;
        if (fbe_sg_element_count(current_sg_p) == 0 && sg_list_index < FBE_PAYLOAD_SG_INDEX_POST_SG_LIST) {
            /* Increment to the next sg list. */
            sg_list_index++;

            /* We now are either at the middle sg or the end sg. */
            if (sg_list_index == FBE_PAYLOAD_SG_INDEX_SG_LIST) {
                /* Get the middle sg list ptr. */
                current_sg_p = xfer_data->sg_p;
            } else if (sg_list_index == FBE_PAYLOAD_SG_INDEX_POST_SG_LIST) {
                /* Get the end sg list ptr. */
                current_sg_p = xfer_data->post_sg_p;
            }
        } /* If we hit the end of an sg list. */
    }

    if (current_sg_p == NULL || fbe_sg_element_count(current_sg_p) == 0) {
        terminator_trace(FBE_TRACE_LEVEL_CRITICAL_ERROR, FBE_TRACE_MESSAGE_ID_INFO, 
                         "sg element NULL\n");
        return FBE_STATUS_GENERIC_FAILURE;
    }

    *out_sg_p = current_sg_p;
    *out_index = sg_list_index;
    return FBE_STATUS_OK;
}

static fbe_status_t
terminator_drive_copy_fragmented_sg_element(sas_drive_xfer_data_t * xfer_data,
                                            fbe_u8_t * data_buffer, 
                                            fbe_u32_t total_bytes, 
                                            fbe_sg_element_t ** out_sg_p, 
                                            fbe_payload_sg_index_t *out_index,
                                            fbe_u8_t **out_sg_data_p,
                                            fbe_u32_t *out_bytes_left,
                                            fbe_bool_t from_sg)
{
    fbe_sg_element_t  * current_sg_p = *out_sg_p;
    fbe_payload_sg_index_t sg_list_index = *out_index;
    fbe_u32_t sg_bytes_left = *out_bytes_left;
    fbe_u32_t total_bytes_left = total_bytes, bytes_to_copy;
    fbe_u8_t *data_p = data_buffer;
    fbe_u8_t *sg_data_p = current_sg_p->address;

    sg_data_p += (fbe_sg_element_count(current_sg_p) - sg_bytes_left);
    while (total_bytes_left != 0) {
        if (sg_bytes_left == 0) {
            terminator_drive_get_next_sg_element(xfer_data, &current_sg_p, &sg_list_index);
            sg_data_p = fbe_sg_element_address(current_sg_p);
            sg_bytes_left = fbe_sg_element_count(current_sg_p);
        }

        bytes_to_copy = FBE_MIN(total_bytes_left, sg_bytes_left);
        if (from_sg) {
            fbe_copy_memory(data_p, sg_data_p, bytes_to_copy);
        } else {
            fbe_copy_memory(sg_data_p, data_p, bytes_to_copy);
        }
        sg_data_p += bytes_to_copy;
        sg_bytes_left -= bytes_to_copy;
        total_bytes_left -= bytes_to_copy;
    }

    *out_sg_p = current_sg_p;
    *out_index = sg_list_index;
    *out_sg_data_p = sg_data_p;
    *out_bytes_left = sg_bytes_left;
    return FBE_STATUS_OK;
}

static fbe_status_t
terminator_drive_compress_one_block(fbe_u8_t * data_buffer, fbe_u32_t block_size, fbe_u8_t * compressed_data)
{
    fbe_terminator_compressed_block_t * compressed_block = (fbe_terminator_compressed_block_t *)compressed_data;
    fbe_u32_t i, pattern_index = 0;
    fbe_u64_t * data_p = (fbe_u64_t *)data_buffer;
    fbe_u64_t current_pattern;
    fbe_u32_t count = 0, total_count = 0;

    current_pattern = *data_p;
    count = 1;
    data_p++;
    for (i = 1; i < (block_size/sizeof(fbe_u64_t)); i++) {
        if (current_pattern != *data_p) {
            if (pattern_index == (TERMINATOR_MAX_PATTERNS - 1)) {
                return FBE_STATUS_GENERIC_FAILURE;
            }
            compressed_block->data_pattern[pattern_index].count = count;
            compressed_block->data_pattern[pattern_index].pattern = current_pattern;
            pattern_index++;
            total_count += count;
            count = 1;
            current_pattern = *data_p;
        } else {
            count++;
        }
        data_p++;
    }
    /* Last pattern */
    compressed_block->data_pattern[pattern_index].count = count;
    compressed_block->data_pattern[pattern_index].pattern = current_pattern;
    pattern_index++;
    total_count += count;
    if (total_count != (block_size/sizeof(fbe_u64_t))) {
        terminator_trace(FBE_TRACE_LEVEL_CRITICAL_ERROR, FBE_TRACE_MESSAGE_ID_INFO, 
                         "Total count not correct %d\n", total_count);
    }

    return FBE_STATUS_OK;
}

fbe_status_t 
terminator_drive_compress_buffer(sas_drive_xfer_data_t * xfer_data, fbe_u8_t * data_buffer, terminator_key_info_t * key_info)
{
    fbe_status_t status;
    fbe_u8_t * compressed_data_p = data_buffer;
    fbe_u8_t * orig_data_p;
    fbe_sg_element_t *current_sg_p = NULL;
    fbe_payload_sg_index_t sg_list_index = 0;
    fbe_u32_t sg_bytes_to_xfer = 0;
    fbe_u32_t blocks_left_to_xfer = (fbe_u32_t)xfer_data->blocks;
    fbe_u32_t block_size = xfer_data->block_size;
    fbe_u8_t temp_buff[FBE_BE_BYTES_PER_BLOCK];

    if (!terminator_drive_data_compression_enabled) {
        return FBE_STATUS_GENERIC_FAILURE;
    }

    if ((terminator_simulated_drive_type != TERMINATOR_SIMULATED_DRIVE_TYPE_LOCAL_MEMORY) &&
        (terminator_simulated_drive_type != TERMINATOR_SIMULATED_DRIVE_TYPE_REMOTE_MEMORY)) {
        return FBE_STATUS_GENERIC_FAILURE;
    }

    if (xfer_data->block_size > FBE_BE_BYTES_PER_BLOCK) {
        if ((xfer_data->block_size % FBE_BE_BYTES_PER_BLOCK) == 0) {
            block_size = FBE_BE_BYTES_PER_BLOCK;
            blocks_left_to_xfer *= (xfer_data->block_size/FBE_BE_BYTES_PER_BLOCK);
        } else {
            return FBE_STATUS_GENERIC_FAILURE;
        }
    }

    terminator_drive_get_next_sg_element(xfer_data, &current_sg_p, &sg_list_index);
    orig_data_p = fbe_sg_element_address(current_sg_p);
    sg_bytes_to_xfer = fbe_sg_element_count(current_sg_p);

    while (blocks_left_to_xfer > 0) {
        if (sg_bytes_to_xfer >= block_size) {
            if (key_info) {
                fbe_copy_memory(temp_buff, orig_data_p, block_size);
                terminator_simulated_disk_encrypt_data(temp_buff, 
                                                       block_size,
                                                       key_info->keys,
                                                       FBE_ENCRYPTION_KEY_SIZE);
                status = terminator_drive_compress_one_block(temp_buff, block_size, compressed_data_p);
            } else {
                status = terminator_drive_compress_one_block(orig_data_p, block_size, compressed_data_p);
            }
            if (status != FBE_STATUS_OK) {
                return FBE_STATUS_GENERIC_FAILURE;
            }
            compressed_data_p += sizeof(fbe_terminator_compressed_block_t);
            orig_data_p += block_size;
            sg_bytes_to_xfer -= block_size;
        } else if (sg_bytes_to_xfer == 0) {
            terminator_drive_get_next_sg_element(xfer_data, &current_sg_p, &sg_list_index);
            orig_data_p = fbe_sg_element_address(current_sg_p);
            sg_bytes_to_xfer = fbe_sg_element_count(current_sg_p);
            continue;
        } else {
            terminator_drive_copy_fragmented_sg_element(xfer_data, temp_buff, block_size, 
                                                        &current_sg_p, &sg_list_index, &orig_data_p, &sg_bytes_to_xfer, 
                                                        FBE_TRUE);
            if (key_info) {
                terminator_simulated_disk_encrypt_data(temp_buff, 
                                                       (fbe_u32_t)(FBE_BE_BYTES_PER_BLOCK),
                                                       key_info->keys,
                                                       FBE_ENCRYPTION_KEY_SIZE);
            }

            status = terminator_drive_compress_one_block(temp_buff, block_size, compressed_data_p);
            if (status != FBE_STATUS_OK) {
                return FBE_STATUS_GENERIC_FAILURE;
            }
            compressed_data_p += sizeof(fbe_terminator_compressed_block_t);
        }

        blocks_left_to_xfer--;
    }

    terminator_trace(FBE_TRACE_LEVEL_DEBUG_HIGH,
                     FBE_TRACE_MESSAGE_ID_INFO,
                     "%s LBA 0x%llx block_count 0x%llx\n",
                     __FUNCTION__, xfer_data->lba, xfer_data->blocks);

    return FBE_STATUS_OK;
}

static fbe_status_t 
terminator_drive_decompress_one_block(fbe_u8_t * data_buffer_pointer, 
                                      fbe_block_size_t block_size,
                                      fbe_u8_t * record_data_pointer)
{
    fbe_u64_t * data_p = (fbe_u64_t *)data_buffer_pointer;
    fbe_terminator_compressed_block_data_pattern_t * current_pattern;
    fbe_u32_t i, pattern_index;
    fbe_u32_t total_count = 0;

    current_pattern = (fbe_terminator_compressed_block_data_pattern_t *)record_data_pointer;
    for (pattern_index = 0; (pattern_index < TERMINATOR_MAX_PATTERNS) && (total_count < (block_size/sizeof(fbe_u64_t))); pattern_index++) {
        total_count += current_pattern->count;
        if (total_count > (block_size/sizeof(fbe_u64_t))) {
            break;
        }
        for (i = 0; i < current_pattern->count; i++) {
            *data_p = current_pattern->pattern;
			data_p++;
        }
        current_pattern++;
    }

    if (total_count != (block_size/sizeof(fbe_u64_t))) {
        terminator_trace(FBE_TRACE_LEVEL_CRITICAL_ERROR, FBE_TRACE_MESSAGE_ID_INFO, 
                         "Total count not correct %d\n", total_count);
    }

    return FBE_STATUS_OK;
}

fbe_status_t terminator_drive_decompress_buffer(sas_drive_xfer_data_t * xfer_data, fbe_u8_t * data_buffer, fbe_u32_t data_size, terminator_key_info_t *key_info)
{
    fbe_status_t status;
    fbe_u8_t * compressed_data_p = data_buffer;
    fbe_u8_t * orig_data_p;
    fbe_sg_element_t *current_sg_p = NULL;
    fbe_payload_sg_index_t sg_list_index = 0;
    fbe_u32_t sg_bytes_to_xfer = 0;
    fbe_u32_t blocks_left_to_xfer = (data_size/sizeof(fbe_terminator_compressed_block_t));
    fbe_u32_t block_size = xfer_data->block_size;
    fbe_u8_t temp_buff[FBE_BE_BYTES_PER_BLOCK];

    if (!terminator_drive_data_compression_enabled) {
        return FBE_STATUS_GENERIC_FAILURE;
    }

    if ((terminator_simulated_drive_type != TERMINATOR_SIMULATED_DRIVE_TYPE_LOCAL_MEMORY) &&
        (terminator_simulated_drive_type != TERMINATOR_SIMULATED_DRIVE_TYPE_REMOTE_MEMORY)) {
        return FBE_STATUS_GENERIC_FAILURE;
    }

    if (block_size > FBE_BE_BYTES_PER_BLOCK) {
        //blocks_left_to_xfer *= (block_size/FBE_BE_BYTES_PER_BLOCK);
        block_size = FBE_BE_BYTES_PER_BLOCK;
    }

    terminator_drive_get_next_sg_element(xfer_data, &current_sg_p, &sg_list_index);
    orig_data_p = fbe_sg_element_address(current_sg_p);
    sg_bytes_to_xfer = fbe_sg_element_count(current_sg_p);

    while (blocks_left_to_xfer > 0) {
        if (sg_bytes_to_xfer >= block_size) {
            status = terminator_drive_decompress_one_block(orig_data_p, block_size, compressed_data_p);
            if (status != FBE_STATUS_OK) {
                return FBE_STATUS_GENERIC_FAILURE;
            }
            if (key_info) {
                /* We need to decrypt the data */
                terminator_simulated_disk_decrypt_data(orig_data_p, 
                                       block_size,
                                       key_info->keys,
                                       FBE_ENCRYPTION_KEY_SIZE);
            }
            compressed_data_p += sizeof(fbe_terminator_compressed_block_t);
            orig_data_p += block_size;
            sg_bytes_to_xfer -= block_size;
        } else if (sg_bytes_to_xfer == 0) {
            terminator_drive_get_next_sg_element(xfer_data, &current_sg_p, &sg_list_index);
            orig_data_p = fbe_sg_element_address(current_sg_p);
            sg_bytes_to_xfer = fbe_sg_element_count(current_sg_p);
            continue;
        } else {
            status = terminator_drive_decompress_one_block(temp_buff, block_size, compressed_data_p);
            if (status != FBE_STATUS_OK) {
                return FBE_STATUS_GENERIC_FAILURE;
            }
            if (key_info) {
                /* We need to decrypt the data */
                terminator_simulated_disk_decrypt_data(temp_buff, 
                                       block_size,
                                       key_info->keys,
                                       FBE_ENCRYPTION_KEY_SIZE);
            }
            compressed_data_p += sizeof(fbe_terminator_compressed_block_t);
            terminator_drive_copy_fragmented_sg_element(xfer_data, temp_buff, block_size, 
                                                        &current_sg_p, &sg_list_index, &orig_data_p, &sg_bytes_to_xfer, 
                                                        FBE_FALSE);
        }

        blocks_left_to_xfer--;
    }

    terminator_trace(FBE_TRACE_LEVEL_DEBUG_HIGH,
                     FBE_TRACE_MESSAGE_ID_INFO,
                     "%s LBA 0x%llx block_count 0x%llx\n",
                     __FUNCTION__, xfer_data->lba, xfer_data->blocks);

    return FBE_STATUS_OK;
}

static fbe_status_t
sas_drive_process_payload_log_sense (fbe_payload_ex_t * payload, fbe_terminator_device_ptr_t drive_handle)
{
    fbe_status_t                        status = FBE_STATUS_GENERIC_FAILURE;
    fbe_u8_t                            *b_ptr = NULL;
    fbe_sg_element_t                    *sg_list;    
    fbe_payload_cdb_operation_t         *payload_cdb_operation = NULL;
    fbe_terminator_sas_drive_info_t drive_info = {0};
    fbe_u8_t                            *log_page = NULL;
    fbe_u32_t                            log_page_size;

    payload_cdb_operation = fbe_payload_ex_get_cdb_operation(payload);
    if (payload_cdb_operation == NULL)
    {
        terminator_trace(FBE_TRACE_LEVEL_WARNING,
                         FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                         "%s: fbe_payload_ex_get_cdb_operation() failed.\n",
                         __FUNCTION__);

        return FBE_STATUS_GENERIC_FAILURE;
    }

    terminator_get_sas_drive_info(drive_handle, &drive_info);

    fbe_payload_ex_get_sg_list(payload, &sg_list, NULL);

    b_ptr = (fbe_u8_t *)sg_list->address;
    if (sg_list->count == 0)
    {
        terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,"%s: sg list count is 0 or less than expected\n", __FUNCTION__);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
        return FBE_STATUS_GENERIC_FAILURE;
    }

    if ((payload_cdb_operation->cdb[2] & 0x3F) == 0x31)
    {
        /* place the full mode page data in the buffer */
        log_page = sas_drive_get_log_page_31((terminator_drive_t*)drive_handle, &log_page_size);
        if ((log_page == NULL) || (sg_list->count < sizeof(log_page)))
        {
            terminator_trace(FBE_TRACE_LEVEL_ERROR, FBE_TRACE_MESSAGE_ID_FUNCTION_FAILED,
                             "%s:Error !! LOG Page 31 not found or invalid\n", __FUNCTION__);
            fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
            return FBE_STATUS_GENERIC_FAILURE;
        }

        fbe_copy_memory(b_ptr, log_page, log_page_size);
        fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_SUCCESS);
        fbe_payload_cdb_set_transferred_count(payload_cdb_operation, log_page_size);    
        return FBE_STATUS_OK;
    }

    fbe_payload_cdb_set_request_status(payload_cdb_operation, FBE_PORT_REQUEST_STATUS_INVALID_REQUEST);
    return status;
}
